{
    "version": "https://jsonfeed.org/version/1",
    "title": "杂项笔记",
    "subtitle": "",
    "icon": "http://example.com/images/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/01/23/game-engine/unity/unityProject01/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%20-%20%E5%89%AF%E6%9C%AC%20(3)/",
            "url": "http://example.com/2025/01/23/game-engine/unity/unityProject01/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%20-%20%E5%89%AF%E6%9C%AC%20(3)/",
            "title": "背包系统优化",
            "date_published": "2025-01-23T02:37:59.661Z",
            "content_html": "<p>在原本的 Inventory 的基础上，我发现一个问题，每当我需要列出一个新的列表的时候，我都需要创建一个新的 list 和 dectionary 在 Inventory 的每个方法中重新注册一遍，这太麻烦了，违背了低耦合性的原则，所以我对 inventory 重新进行了整理。</p>\n<p>我创建了 IInventoryCategory 接口来对 Inventory 中常用的方法进行了抽象管理<br>\n <figure class=\"highlight c#\"><figcaption><span>IInventoryCategory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IInventoryCategory</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ItemType <span class=\"title\">GetItemType</span>()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AddItem</span>(<span class=\"params\">ItemData item</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">RemoveItem</span>(<span class=\"params\">ItemData item</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UpdateUI</span>()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UpdateSelectedItem</span>(<span class=\"params\">ItemData selectedItem</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后创建一个 InventoryCategory 用以管理大的类别<br>\n <figure class=\"highlight c#\"><figcaption><span>InventoryCategory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> List&lt;InventoryItem&gt; items = <span class=\"keyword\">new</span> List&lt;InventoryItem&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;ItemData, InventoryItem&gt; itemDictionary = <span class=\"keyword\">new</span> Dictionary&lt;ItemData, InventoryItem&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UI_ItemSlot[] uiSlots;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InventoryCategory</span>(<span class=\"params\">UI_ItemSlot[] slots</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        uiSlots = slots;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ItemType <span class=\"title\">GetItemType</span>()</span> =&gt; items.Count &gt; <span class=\"number\">0</span> ? items[<span class=\"number\">0</span>].data.itemType : ItemType.None;</span><br></pre></td></tr></table></figure></p>\n<p>同时将一些方法进行重写</p>\n<ul>\n<li>AddItem<br>\n<figure class=\"highlight c#\"><figcaption><span>AddItem</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加新物品到分类中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">AddItem</span>(<span class=\"params\">ItemData item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查物品是否已经存在于字典中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!itemDictionary.TryGetValue(item, <span class=\"keyword\">out</span> InventoryItem existingItem))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果物品不存在，创建一个新的 InventoryItem 并添加到列表和字典中</span></span><br><span class=\"line\">        InventoryItem newItem = <span class=\"keyword\">new</span> InventoryItem(item);</span><br><span class=\"line\">        items.Add(newItem);</span><br><span class=\"line\">        itemDictionary[item] = newItem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果物品已存在，则增加其堆叠数量</span></span><br><span class=\"line\">        existingItem.AddStack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 更新 UI 以反映最新的物品状态</span></span><br><span class=\"line\">    UpdateUI();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>RemoveItem<br>\n<figure class=\"highlight c#\"><figcaption><span>RemoveItem</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从分类中移除物品</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">RemoveItem</span>(<span class=\"params\">ItemData item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查物品是否存在于字典中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (itemDictionary.TryGetValue(item, <span class=\"keyword\">out</span> InventoryItem existingItem))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existingItem.stackSize &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果物品堆叠数量大于 1，减少堆叠数量</span></span><br><span class=\"line\">            existingItem.RemoveStack();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果堆叠数量为 1，移除物品</span></span><br><span class=\"line\">            items.Remove(existingItem);</span><br><span class=\"line\">            itemDictionary.Remove(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新 UI 以反映最新的物品状态</span></span><br><span class=\"line\">    UpdateUI();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>UpdateUI<br>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新 UI 槽位以显示当前的物品状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">UpdateUI</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清空所有 UI 槽位</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> slot <span class=\"keyword\">in</span> uiSlots)</span><br><span class=\"line\">        slot.CleanUpSlot();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将当前的物品更新到槽位中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; items.Count &amp;&amp; i &lt; uiSlots.Length; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        uiSlots[i].UpdateSlot(items[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>UpdateSelectedItem<br>\n<figure class=\"highlight c#\"><figcaption><span>UpdateSelectedItem</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新选中物品的状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">UpdateSelectedItem</span>(<span class=\"params\">ItemData selectedItem</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有物品，更新它们的选中状态</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> items)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果物品是选中的，则标记为选中，否则取消选中</span></span><br><span class=\"line\">        item.data.isSelect = item.data == selectedItem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>由于我需要单独列出 Equipment 下的小分类：Book 和 Weapon<br>\n 所以我需要再创建一个类来对 Equipment 中的小分类进行单独的筛选以及其他操作<br>\n <figure class=\"highlight c#\"><figcaption><span>EquipmentCategory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"comment\">// 管理装备类型物品的分类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">EquipmentCategory</span> : <span class=\"title\">MonoBehaviour</span>, <span class=\"title\">IInventoryCategory</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每种装备类型与其物品列表的映射</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;EquipmentType, List&lt;InventoryItem&gt;&gt; typeToItems;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每种装备类型与其 UI 槽位数组的映射</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;EquipmentType, UI_ItemSlot[]&gt; typeToUISlots;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数，用于初始化装备分类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EquipmentCategory</span>(<span class=\"params\">Dictionary&lt;EquipmentType, UI_ItemSlot[]&gt; slotsMapping</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化字典</span></span><br><span class=\"line\">        typeToItems = <span class=\"keyword\">new</span> Dictionary&lt;EquipmentType, List&lt;InventoryItem&gt;&gt;();</span><br><span class=\"line\">        typeToUISlots = slotsMapping;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为每种装备类型创建空的物品列表</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> type <span class=\"keyword\">in</span> typeToUISlots.Keys)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            typeToItems[type] = <span class=\"keyword\">new</span> List&lt;InventoryItem&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回此分类的物品类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ItemType <span class=\"title\">GetItemType</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ItemType.Equipment;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加物品到分类中</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AddItem</span>(<span class=\"params\">ItemData item</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 确保物品是装备类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item <span class=\"keyword\">is</span> ItemData_Equipment equipment)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> type = equipment.equipmentType;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 获取该类型的物品列表</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> items = typeToItems[type];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 检查是否已经存在该物品</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> existingItem = items.FirstOrDefault(i =&gt; i.data == item);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (existingItem != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果已存在，增加堆叠数量</span></span><br><span class=\"line\">                existingItem.AddStack();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果不存在，添加新的物品</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> newItem = <span class=\"keyword\">new</span> InventoryItem(item);</span><br><span class=\"line\">                items.Add(newItem);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 更新对应类型的 UI</span></span><br><span class=\"line\">            UpdateEquipmentSlots(type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从分类中移除物品</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RemoveItem</span>(<span class=\"params\">ItemData item</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 确保物品是装备类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item <span class=\"keyword\">is</span> ItemData_Equipment equipment)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> type = equipment.equipmentType;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 获取该类型的物品列表</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> items = typeToItems[type];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 检查是否存在该物品</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> existingItem = items.FirstOrDefault(i =&gt; i.data == item);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (existingItem != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (existingItem.stackSize &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果堆叠数量大于 1，则减少数量</span></span><br><span class=\"line\">                    existingItem.RemoveStack();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果堆叠数量为 1，则完全移除</span></span><br><span class=\"line\">                    items.Remove(existingItem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 更新对应类型的 UI</span></span><br><span class=\"line\">                UpdateEquipmentSlots(type);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//...以及其他方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>然后在 Inventory 中统一注册管理这些 Category<br>\n<figure class=\"highlight c#\"><figcaption><span>Inventory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">InitializeCategories</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">equipment = <span class=\"keyword\">new</span> List&lt;InventoryItem&gt;();</span><br><span class=\"line\">equipmentDictionary = <span class=\"keyword\">new</span> Dictionary&lt;ItemData_Equipment, InventoryItem&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 获取 UI 格子组件</span></span><br><span class=\"line\">inventoryItemSlot = inventorySlotParent.GetComponentsInChildren&lt;UI_ItemSlot&gt;();</span><br><span class=\"line\">stashItemSlot = stashSlotParent.GetComponentsInChildren&lt;UI_ItemSlot&gt;();</span><br><span class=\"line\">equipmentSlot = equpmentSlotParent.GetComponentsInChildren&lt;UI_EquipmentSlot&gt;();</span><br><span class=\"line\">bookSlot = bookSlotParent.GetComponentsInChildren&lt;UI_ItemSlot&gt;();</span><br><span class=\"line\">weaponSlot = weaponSlotParent.GetComponentsInChildren&lt;UI_WeaponSlot&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 初始化每种装备类型对应的 UI</span></span><br><span class=\"line\">equipmentSlotsMapping = <span class=\"keyword\">new</span> Dictionary&lt;EquipmentType, UI_ItemSlot[]&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#123; EquipmentType.Book, bookSlot &#125;,</span><br><span class=\"line\">\t&#123; EquipmentType.Weapon, weaponSlot &#125;,</span><br><span class=\"line\">\t<span class=\"comment\">// &#123; EquipmentType.Armor, armorSlots &#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 将映射传递给 EquipmentCategory</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> equipmentCategory = <span class=\"keyword\">new</span> EquipmentCategory(equipmentSlotsMapping);</span><br><span class=\"line\">categories = <span class=\"keyword\">new</span> Dictionary&lt;ItemType, IInventoryCategory&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#123; ItemType.Equipment, equipmentCategory &#125;,</span><br><span class=\"line\">\t&#123; ItemType.Material, <span class=\"keyword\">new</span> InventoryCategory(stashItemSlot) &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 随后就可以逐一优化方法，有新的列表加入的时候就不再需要全部注册一遍方法了<br>\n以 AddItem 为例<br>\n <figure class=\"highlight c#\"><figcaption><span>AddItem</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AddItem</span>(<span class=\"params\">ItemData _item</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_item == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogWarning(<span class=\"string\">&quot;Cannot add a null item to inventory.&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据 ItemType 找到对应的分类</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (categories.TryGetValue(_item.itemType, <span class=\"keyword\">out</span> IInventoryCategory category))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是 Equipment 类型，需要进一步处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_item <span class=\"keyword\">is</span> ItemData_Equipment equipment)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 针对 Equipment 类型，调用分类管理的方法</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> equipmentCategory = category <span class=\"keyword\">as</span> EquipmentCategory;</span><br><span class=\"line\">                equipmentCategory?.AddItem(equipment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 针对非 Equipment 类型（如 Material），直接添加</span></span><br><span class=\"line\">                category.AddItem(_item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogWarning(<span class=\"string\">$&quot;No category found for ItemType <span class=\"subst\">&#123;_item.itemType&#125;</span>. Check your category setup.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "从零开始的恶魔城开发"
            ]
        },
        {
            "id": "http://example.com/2025/01/23/game-engine/unity/unityProject01/%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/",
            "url": "http://example.com/2025/01/23/game-engine/unity/unityProject01/%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/",
            "title": "存档系统",
            "date_published": "2025-01-23T02:37:59.103Z",
            "content_html": "<h3 id=\"1创建一个基类用于存储数据\"><a class=\"anchor\" href=\"#1创建一个基类用于存储数据\">#</a> 1. 创建一个基类用于存储数据</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>GameData.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">System.Serializable</span>] <span class=\"comment\">// 标记该类为可序列化，这样它可以被保存到文件或传输数据。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">GameData</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> souls; <span class=\"comment\">// 玩家拥有的灵魂数量，用于游戏中的资源或货币系统。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">string</span> saveName; <span class=\"comment\">// 存档的名称，玩家可以自定义以便区分不同的存档。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">string</span> saveTime; <span class=\"comment\">// 存档时间，以 &quot;yyyyMMdd_HHmmss&quot; 格式保存。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> encryptData; <span class=\"comment\">// 标志是否需要加密存档数据，增强数据安全性。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> SerializableDictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt; inventory; <span class=\"comment\">// 玩家背包，存储物品的名称及对应数量。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> SerializableDictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt; equipment; <span class=\"comment\">// 玩家装备，存储装备的名称及对应等级或强化值。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> SerializableDictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">bool</span>&gt; EXPTree; <span class=\"comment\">// 玩家技能树，存储技能名称及是否已解锁的状态。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数，在创建 GameData 对象时初始化默认值。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GameData</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.souls = <span class=\"number\">0</span>; <span class=\"comment\">// 初始化灵魂数量为 0。</span></span><br><span class=\"line\">        inventory = <span class=\"keyword\">new</span> SerializableDictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt;(); <span class=\"comment\">// 初始化背包为空。</span></span><br><span class=\"line\">        equipment = <span class=\"keyword\">new</span> SerializableDictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt;(); <span class=\"comment\">// 初始化装备为空。</span></span><br><span class=\"line\">        EXPTree = <span class=\"keyword\">new</span> SerializableDictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">bool</span>&gt;(); <span class=\"comment\">// 初始化技能树为空。</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.encryptData = <span class=\"literal\">true</span>; <span class=\"comment\">// 默认启用数据加密。</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.saveTime = System.DateTime.Now.ToString(<span class=\"string\">&quot;yyyyMMdd_HHmmss&quot;</span>); <span class=\"comment\">// 初始化存档时间为当前时间。</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.saveName = <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\">// 默认存档名称为空字符串。</span></span><br><span class=\"line\">        Debug.Log(<span class=\"string\">&quot;GameData Created!&quot;</span>); <span class=\"comment\">// 输出调试信息，确认 GameData 已创建。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>\n 由于字典类型无法序列化，所以创建一个类用于序列化字典类型数据<br>\n <figure class=\"highlight c#\"><figcaption><span>SerializableDictionary.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个可序列化的字典类，继承自 Dictionary&lt;TKey, TValue&gt;，并实现了 ISerializationCallbackReceiver 接口。</span></span><br><span class=\"line\"><span class=\"comment\">// 使得原本无法序列化的 Dictionary 可以在 Unity 的 Inspector 面板中显示并保存。</span></span><br><span class=\"line\">[<span class=\"meta\">System.Serializable</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">SerializableDictionary</span>&lt;<span class=\"title\">TKey</span>, <span class=\"title\">TValue</span>&gt; : <span class=\"title\">Dictionary</span>&lt;<span class=\"title\">TKey</span>, <span class=\"title\">TValue</span>&gt;, <span class=\"title\">ISerializationCallbackReceiver</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于序列化的键列表</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> List&lt;TKey&gt; keys = <span class=\"keyword\">new</span> List&lt;TKey&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 用于序列化的值列表</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> List&lt;TValue&gt; values = <span class=\"keyword\">new</span> List&lt;TValue&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在反序列化（加载数据）之后调用，负责将序列化的数据（键和值列表）还原成字典。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">OnAfterDeserialize</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 清空字典，以准备重新填充数据。</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.Clear();</span><br><span class=\"line\">        <span class=\"comment\">// 检查键值列表的数量是否一致，不一致说明数据损坏。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keys.Count != values.Count)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogError(<span class=\"string\">&quot;keys and values count not equal&quot;</span>); <span class=\"comment\">// 输出错误信息</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历键和值列表，将键值对重新添加到字典中。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; keys.Count; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Debug.Log(keys[i]); // 可选的调试信息，用于检查每个键的内容。</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.Add(keys[i], values[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在序列化（保存数据）之前调用，负责将字典中的数据转换成两个列表（键和值）。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">OnBeforeSerialize</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 清空键和值的列表，以确保没有旧数据。</span></span><br><span class=\"line\">        keys.Clear();</span><br><span class=\"line\">        values.Clear();</span><br><span class=\"line\">        <span class=\"comment\">// 遍历字典中的每个键值对，将键和值分别添加到对应的列表中。</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (KeyValuePair&lt;TKey, TValue&gt; pair <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            keys.Add(pair.Key);    <span class=\"comment\">// 添加键</span></span><br><span class=\"line\">            values.Add(pair.Value); <span class=\"comment\">// 添加值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-创建一个管理类\"><a class=\"anchor\" href=\"#2-创建一个管理类\">#</a> 2. 创建一个管理类</h3>\n<p>我们需要集成一个管理类用于管理所有需要存档的数据<br>\n <figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            Destroy(gameObject); <span class=\"comment\">// 如果已存在一个 SaveManager 实例，销毁当前对象。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">this</span>; <span class=\"comment\">// 设置实例。</span></span><br><span class=\"line\">            DontDestroyOnLoad(gameObject); <span class=\"comment\">// 确保对象在场景切换时不会被销毁。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        SceneManager.sceneLoaded += OnSceneLoaded; <span class=\"comment\">// 订阅场景加载事件。</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>\n 由于我们在开始界面进入存档时若销毁此管理类，将会导致 gameData 丢失，所以需要将此类注册为不被销毁的类用于管理存档。<br>\n<figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Start：初始化存档管理器。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    saveManagers = GetSaveManagers(); <span class=\"comment\">// 获取所有实现 ISaveManager 接口的对象。</span></span><br><span class=\"line\">    saveFolder = Application.persistentDataPath + <span class=\"string\">&quot;/Saves&quot;</span>; <span class=\"comment\">// 设置存档文件夹路径。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 将所有具有 save 和 load 方法的类统一管理</p>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载游戏数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">LoadGame</span>(<span class=\"params\">GameData _gameData</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    isSaveRequired = <span class=\"literal\">true</span>; <span class=\"comment\">// 标记需要保存数据。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Directory.Exists(saveFolder))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Directory.CreateDirectory(saveFolder); <span class=\"comment\">// 如果文件夹不存在，则创建。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果存档名称为空，则初始化默认存档。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_gameData == <span class=\"literal\">null</span> || <span class=\"built_in\">string</span>.IsNullOrEmpty(_gameData.saveName))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.gameData = <span class=\"keyword\">new</span> GameData();</span><br><span class=\"line\">        gameData.saveName = <span class=\"string\">&quot;Save_&quot;</span> + System.DateTime.Now.ToString(<span class=\"string\">&quot;yyyyMMdd_HHmmss&quot;</span>) + <span class=\"string\">&quot;.json&quot;</span>; <span class=\"comment\">// 自动生成存档名称。</span></span><br><span class=\"line\">        gameData.encryptData = encryptData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化文件处理器并加载存档数据。</span></span><br><span class=\"line\">    fileDataHandler = <span class=\"keyword\">new</span> FileDataHandler(Application.persistentDataPath + <span class=\"string\">&quot;/Saves&quot;</span>, gameData.saveName, gameData.encryptData);</span><br><span class=\"line\">    gameData = fileDataHandler.Load(gameData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用所有 ISaveManager 对象的加载方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (ISaveManager saveManager <span class=\"keyword\">in</span> saveManagers)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        saveManager.LoadData(gameData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\nLoad 的具体实现在另一个 FileDataHandler 中实现，这边后面再说<br>\n初始化存档并将数据注入各个具体存档实现的地方</p>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 保存游戏数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SaveGame</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isSaveRequired)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; <span class=\"comment\">// 如果不需要保存，则直接返回。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用所有 ISaveManager 对象的保存方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (ISaveManager saveManager <span class=\"keyword\">in</span> saveManagers)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        saveManager.SaveData(<span class=\"keyword\">ref</span> gameData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新存档时间并保存到文件。</span></span><br><span class=\"line\">    gameData.saveTime = System.DateTime.Now.ToString(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">    fileDataHandler.Save(gameData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在应用退出时保存游戏数据。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">OnApplicationQuit</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SaveGame();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 然后同理，在游戏退出时将所有存档实现类的数据都通过方法类中的 save 注入 JSON 文档，并存储在本地。</p>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取所有实现 ISaveManager 接口的对象。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> List&lt;ISaveManager&gt; <span class=\"title\">GetSaveManagers</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    IEnumerable&lt;ISaveManager&gt; saveManagers = FindObjectsOfType&lt;MonoBehaviour&gt;().OfType&lt;ISaveManager&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> List&lt;ISaveManager&gt;(saveManagers);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取所有存档的列表。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;GameData&gt; <span class=\"title\">GetSaveList</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    List&lt;GameData&gt; saveList = <span class=\"keyword\">new</span> List&lt;GameData&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">string</span>.IsNullOrEmpty(saveFolder))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        saveFolder = Application.persistentDataPath + <span class=\"string\">&quot;/Saves&quot;</span>; <span class=\"comment\">// 设置存档文件夹路径。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历存档文件夹中的所有 .json 文件。</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span>[] saveFiles = Directory.GetFiles(saveFolder, <span class=\"string\">&quot;*.json&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"built_in\">string</span> filePath <span class=\"keyword\">in</span> saveFiles)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> fileName = Path.GetFileName(filePath);</span><br><span class=\"line\">        FileDataHandler _fileDataHandler = <span class=\"keyword\">new</span> FileDataHandler(saveFolder, fileName, gameData.encryptData);</span><br><span class=\"line\">        saveList.Add(_fileDataHandler.Load()); <span class=\"comment\">// 加载存档文件。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> saveList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 由于在开始界面需要获取本地的所有存档，所以用此方法来返回所有的存档列表并供以操作。</p>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载数据的简化方法，适用于 UI 按钮等触发。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">UseOnToggle</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        saveManagers = GetSaveManagers(); <span class=\"comment\">// 获取所有 ISaveManager 对象。</span></span><br><span class=\"line\">        saveFolder = Application.persistentDataPath + <span class=\"string\">&quot;/Saves&quot;</span>;</span><br><span class=\"line\">        LoadGame(gameData); <span class=\"comment\">// 加载游戏数据。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景加载完成后调用。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">OnSceneLoaded</span>(<span class=\"params\">Scene scene, LoadSceneMode mode</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scene.name == <span class=\"string\">&quot;StartMenu&quot;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// 如果是主菜单场景，不进行存档加载。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        UseOnToggle(); <span class=\"comment\">// 在其他场景加载完成后自动加载存档数据。</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>\n 最后添加提供外部载入数据的方法，在开始界面点击存档后加载存档。</p>\n<h3 id=\"3load和save方法类实现\"><a class=\"anchor\" href=\"#3load和save方法类实现\">#</a> 3.load 和 save 方法类实现</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.IO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用于存档文件的读写和加解密的类。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FileDataHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">string</span> dataDirPath; <span class=\"comment\">// 数据存储的文件夹路径。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">string</span> dataFileName; <span class=\"comment\">// 数据存储的文件名。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> encryptData = <span class=\"literal\">false</span>; <span class=\"comment\">// 是否启用数据加密。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">string</span> codeWord = <span class=\"string\">&quot;1234&quot;</span>; <span class=\"comment\">// 加密解密的密钥。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数，用于初始化文件路径、文件名和加密设置。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileDataHandler</span>(<span class=\"params\"><span class=\"built_in\">string</span> _dataDirPath, <span class=\"built_in\">string</span> _dataFileName, <span class=\"built_in\">bool</span> _encryptData = <span class=\"literal\">false</span>, <span class=\"built_in\">string</span> _codeWord = <span class=\"string\">&quot;1234&quot;</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果未指定文件夹路径，使用默认路径。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">string</span>.IsNullOrEmpty(_dataDirPath))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dataDirPath = Application.persistentDataPath + <span class=\"string\">&quot;/Saves&quot;</span>; <span class=\"comment\">// 默认存储在持久化数据路径下的 &quot;Saves&quot; 文件夹。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dataDirPath = _dataDirPath; <span class=\"comment\">// 使用指定路径。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dataFileName = _dataFileName; <span class=\"comment\">// 设置文件名。</span></span><br><span class=\"line\">        encryptData = _encryptData; <span class=\"comment\">// 设置是否加密。</span></span><br><span class=\"line\">        codeWord = _codeWord; <span class=\"comment\">// 设置加密密钥。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存游戏数据到文件</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Save</span>(<span class=\"params\">GameData _data</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> fullPath = Path.Combine(dataDirPath, dataFileName); <span class=\"comment\">// 构建完整文件路径。</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Directory.CreateDirectory(Path.GetDirectoryName(fullPath)); <span class=\"comment\">// 确保文件夹存在，若不存在则创建。</span></span><br><span class=\"line\">            <span class=\"built_in\">string</span> dataToStore = JsonUtility.ToJson(_data); <span class=\"comment\">// 将 GameData 对象序列化为 JSON 字符串。</span></span><br><span class=\"line\">            Debug.Log(<span class=\"string\">&quot;Save data: &quot;</span> + dataToStore);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (encryptData)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dataToStore = EncryDecrypt(dataToStore); <span class=\"comment\">// 如果启用加密，则加密数据。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 使用文件流和流写入器写入文件。</span></span><br><span class=\"line\">            <span class=\"keyword\">using</span> (FileStream stream = <span class=\"keyword\">new</span> FileStream(fullPath, FileMode.Create))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">using</span> (StreamWriter writer = <span class=\"keyword\">new</span> StreamWriter(stream))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    writer.Write(dataToStore); <span class=\"comment\">// 写入数据到文件。</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogError(<span class=\"string\">&quot;Error in saving data path: &quot;</span> + fullPath + <span class=\"string\">&quot; Error: &quot;</span> + e.Message); <span class=\"comment\">// 捕获并输出保存过程中的错误信息。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加载游戏数据</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> GameData <span class=\"title\">Load</span>(<span class=\"params\">GameData _gameData = <span class=\"literal\">null</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> fullPath = Path.Combine(dataDirPath, dataFileName); <span class=\"comment\">// 构建完整文件路径。</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> dataToLoad = <span class=\"built_in\">string</span>.Empty; <span class=\"comment\">// 用于存储从文件中读取的数据。</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (File.Exists(fullPath))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 使用文件流和流读取器读取文件内容。</span></span><br><span class=\"line\">                <span class=\"keyword\">using</span> (FileStream stream = <span class=\"keyword\">new</span> FileStream(fullPath, FileMode.Open))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">using</span> (StreamReader reader = <span class=\"keyword\">new</span> StreamReader(stream))</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        dataToLoad = reader.ReadToEnd(); <span class=\"comment\">// 读取文件内容。</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (encryptData)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    dataToLoad = EncryDecrypt(dataToLoad); <span class=\"comment\">// 如果启用加密，则解密数据。</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> JsonUtility.FromJson&lt;GameData&gt;(dataToLoad); <span class=\"comment\">// 将 JSON 字符串反序列化为 GameData 对象并返回。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogError(<span class=\"string\">&quot;Error in loading data path: &quot;</span> + fullPath + <span class=\"string\">&quot; Error: &quot;</span> + e.Message); <span class=\"comment\">// 捕获并输出加载过程中的错误信息。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果文件不存在或加载失败，返回默认的 GameData。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_gameData == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _gameData = <span class=\"keyword\">new</span> GameData();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _gameData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除存档文件</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Delete</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> fullPath = Path.Combine(dataDirPath, dataFileName); <span class=\"comment\">// 构建完整文件路径。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (File.Exists(fullPath))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            File.Delete(fullPath); <span class=\"comment\">// 删除文件。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加密/解密数据的私有方法（使用简单的异或运算）。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">string</span> <span class=\"title\">EncryDecrypt</span>(<span class=\"params\"><span class=\"built_in\">string</span> _data</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> result = <span class=\"built_in\">string</span>.Empty; <span class=\"comment\">// 存储加密/解密后的结果。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; _data.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用密钥对数据进行异或操作，加密和解密使用相同的逻辑。</span></span><br><span class=\"line\">            result += (<span class=\"built_in\">char</span>)(_data[i] ^ codeWord[i % codeWord.Length]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4通过接口类管理需要存档的数据\"><a class=\"anchor\" href=\"#4通过接口类管理需要存档的数据\">#</a> 4. 通过接口类管理需要存档的数据</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>ISaveManager.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">ISaveManager</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LoadData</span>(<span class=\"params\">GameData _data</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SaveData</span>(<span class=\"params\"><span class=\"keyword\">ref</span> GameData _data</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在每个需要存储数据的模块都进行了实现，这边以 Inventory 进行举例</p>\n<p><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从存档数据中加载玩家的物品和装备</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">LoadData</span>(<span class=\"params\">GameData _data</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历存档中的背包物品</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (KeyValuePair&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt; pair <span class=\"keyword\">in</span> _data.inventory)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历物品数据库，寻找与存档匹配的物品</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"function\">ItemData item <span class=\"keyword\">in</span> <span class=\"title\">GetItemDataBase</span>())</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (item != <span class=\"literal\">null</span> &amp;&amp; item.itemID == pair.Key) <span class=\"comment\">// 检查物品 ID 是否匹配</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                InventoryItem itemToLoad = <span class=\"keyword\">new</span> InventoryItem(item); <span class=\"comment\">// 创建对应的 InventoryItem</span></span><br><span class=\"line\">                itemToLoad.stackSize = pair.Value; <span class=\"comment\">// 设置物品堆叠数量</span></span><br><span class=\"line\">                loadItems.Add(itemToLoad); <span class=\"comment\">// 将物品添加到加载的物品列表</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历存档中的装备</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (KeyValuePair&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">int</span>&gt; pair <span class=\"keyword\">in</span> _data.equipment)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历物品数据库，寻找与存档匹配的装备</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"function\">ItemData item <span class=\"keyword\">in</span> <span class=\"title\">GetItemDataBase</span>())</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (item != <span class=\"literal\">null</span> &amp;&amp; item.itemID == pair.Key) <span class=\"comment\">// 检查装备 ID 是否匹配</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                InventoryItem equipmentToLoad = <span class=\"keyword\">new</span> InventoryItem(item); <span class=\"comment\">// 创建对应的 InventoryItem</span></span><br><span class=\"line\">                equipmentToLoad.stackSize = pair.Value; <span class=\"comment\">// 设置装备堆叠数量（通常为 1）</span></span><br><span class=\"line\">                equipItems.Add(equipmentToLoad); <span class=\"comment\">// 将装备添加到加载的装备列表</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将玩家的物品和装备保存到存档数据中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SaveData</span>(<span class=\"params\"><span class=\"keyword\">ref</span> GameData _data</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清空存档中的背包和装备，以准备写入新的数据</span></span><br><span class=\"line\">    _data.inventory.Clear();</span><br><span class=\"line\">    _data.equipment.Clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历装备字典，将已装备的物品保存到存档</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (KeyValuePair&lt;ItemData_Equipment, InventoryItem&gt; item <span class=\"keyword\">in</span> equipmentDictionary)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _data.equipment.Add(item.Key.itemID, item.Value.stackSize); <span class=\"comment\">// 保存装备的 ID 和堆叠数量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有物品，将背包中的物品保存到存档</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"function\">KeyValuePair&lt;ItemData, InventoryItem&gt; item <span class=\"keyword\">in</span> <span class=\"title\">GetAllItems</span>())</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _data.inventory.Add(item.Key.itemID, item.Value.stackSize); <span class=\"comment\">// 保存物品的 ID 和堆叠数量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>由于我舍弃了 Inventory 的使用，所以我需要创建一个方法获取所有的物品，用以存储<br>\n <figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Dictionary&lt;ItemData, InventoryItem&gt; <span class=\"title\">GetAllItems</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Dictionary&lt;ItemData, InventoryItem&gt; allItems = <span class=\"keyword\">new</span> Dictionary&lt;ItemData, InventoryItem&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> category <span class=\"keyword\">in</span> categories)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据分类类型处理</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (category.Key)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> ItemType.Equipment:</span><br><span class=\"line\">                AddEquipmentItemsToDictionary(category.Value <span class=\"keyword\">as</span> EquipmentCategory, allItems);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"literal\">default</span>:</span><br><span class=\"line\">                AddCategoryItemsToDictionary(category.Value <span class=\"keyword\">as</span> InventoryCategory, allItems);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> allItems;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提取装备分类的逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddEquipmentItemsToDictionary</span>(<span class=\"params\">EquipmentCategory equipmentCategory, Dictionary&lt;ItemData, InventoryItem&gt; allItems</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (equipmentCategory == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历装备类型和对应的物品列表</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> equipmentCategory.GetTypeToItems())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (InventoryItem inventoryItem <span class=\"keyword\">in</span> item.Value)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!allItems.ContainsKey(inventoryItem.data)) <span class=\"comment\">// 避免重复添加</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                allItems.Add(inventoryItem.data, inventoryItem);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提取一般分类的逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddCategoryItemsToDictionary</span>(<span class=\"params\">InventoryCategory inventoryCategory, Dictionary&lt;ItemData, InventoryItem&gt; allItems</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inventoryCategory == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历分类中的物品列表</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (InventoryItem item <span class=\"keyword\">in</span> inventoryCategory.GetItems())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!allItems.ContainsKey(item.data)) <span class=\"comment\">// 避免重复添加</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            allItems.Add(item.data, item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>\n 两个辅助类用于分类管理多种类型的物品，最终返回所有物品及状态给存档</p>\n<h3 id=\"5加载存档与新的开始\"><a class=\"anchor\" href=\"#5加载存档与新的开始\">#</a> 5. 加载存档与新的开始</h3>\n<p><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LoadSaveList(); <span class=\"comment\">// 加载存档列表并动态生成按钮</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加载存档列表并动态生成按钮</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LoadSaveList</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取存档列表</span></span><br><span class=\"line\">        List&lt;GameData&gt; saveList = SaveManager.instance.GetSaveList();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历存档列表，为每个存档生成一个按钮</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (GameData save <span class=\"keyword\">in</span> saveList)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            GameObject button = Instantiate(saveButtonPrefab, saveListContainer); <span class=\"comment\">// 实例化存档按钮</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置按钮上的文本为存档名称和存档时间</span></span><br><span class=\"line\">            button.GetComponentInChildren&lt;TextMeshProUGUI&gt;().text = save.saveName + <span class=\"string\">&quot; - &quot;</span> + save.saveTime;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 为按钮添加点击事件</span></span><br><span class=\"line\">            button.GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                LoadSave(save); <span class=\"comment\">// 点击按钮后加载对应的存档</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>\n 获取存档列表并通过预制件加到 UI 当中去</p>\n<p><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载指定的存档</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LoadSave</span>(<span class=\"params\">GameData _gameData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Time.timeScale = <span class=\"number\">1f</span>; <span class=\"comment\">// 恢复时间缩放，确保游戏运行正常</span></span><br><span class=\"line\">        StartCoroutine(LoadSaveCoroutine(_gameData, <span class=\"number\">1.5f</span>)); <span class=\"comment\">// 开启协程加载存档</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 协程：加载存档时显示黑屏并延迟切换场景</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IEnumerator <span class=\"title\">LoadSaveCoroutine</span>(<span class=\"params\">GameData _gameData, <span class=\"built_in\">float</span> delay</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DarkScreen.SetActive(<span class=\"literal\">true</span>); <span class=\"comment\">// 激活黑屏效果</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">yield</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title\">WaitForSeconds</span>(<span class=\"params\">delay</span>)</span>; <span class=\"comment\">// 延迟指定的时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 切换到游戏场景并加载存档数据</span></span><br><span class=\"line\">        SaveManager.instance.gameData = _gameData; <span class=\"comment\">// 设置当前存档数据</span></span><br><span class=\"line\">        SceneManager.LoadScene(<span class=\"string\">&quot;GameScene&quot;</span>); <span class=\"comment\">// 加载游戏场景</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>\n 然后通过场景切换与画布过场动画进行跳转</p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "从零开始的恶魔城开发"
            ]
        },
        {
            "id": "http://example.com/2025/01/23/game-engine/unity/unityProject01/unity%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABscript%E9%94%99%E8%AF%AF/",
            "url": "http://example.com/2025/01/23/game-engine/unity/unityProject01/unity%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABscript%E9%94%99%E8%AF%AF/",
            "title": "unity无法识别script错误",
            "date_published": "2025-01-23T02:37:59.067Z",
            "content_html": "<p>在开发的过程中，碰到了一个很奇怪的问题<br>\n<img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/unity/unity2d/%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABscript.png\" alt><br>\n而且是本来能够挂载到对象上的 script 忽然报错显示挂载失败，虽然修改了程序中的一些可能造成报错的代码后挂载成功，但是还是很奇怪<br>\n实际上原因是因为 unity 自身加载失败的问题，把 library 文件删了再重新启动一遍项目即可解决。<br>\n同时可能存在的其他问题：如果 script 自身有编译错误或者类名和文件名不符也可能会产生这个报错。</p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "从零开始的恶魔城开发"
            ]
        },
        {
            "id": "http://example.com/2025/01/21/game-engine/unity/unityProject01/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/",
            "url": "http://example.com/2025/01/21/game-engine/unity/unityProject01/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/",
            "title": "背包系统优化",
            "date_published": "2025-01-21T11:20:31.518Z",
            "content_html": "<p>在原本的 Inventory 的基础上，我发现一个问题，每当我需要列出一个新的列表的时候，我都需要创建一个新的 list 和 dectionary 在 Inventory 的每个方法中重新注册一遍，这太麻烦了，违背了低耦合性的原则，所以我对 inventory 重新进行了整理。</p>\n<p>我创建了 IInventoryCategory 接口来对 Inventory 中常用的方法进行了抽象管理<br>\n <figure class=\"highlight c#\"><figcaption><span>IInventoryCategory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IInventoryCategory</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ItemType <span class=\"title\">GetItemType</span>()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AddItem</span>(<span class=\"params\">ItemData item</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">RemoveItem</span>(<span class=\"params\">ItemData item</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UpdateUI</span>()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UpdateSelectedItem</span>(<span class=\"params\">ItemData selectedItem</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后创建一个 InventoryCategory 用以管理大的类别<br>\n <figure class=\"highlight c#\"><figcaption><span>InventoryCategory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> List&lt;InventoryItem&gt; items = <span class=\"keyword\">new</span> List&lt;InventoryItem&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;ItemData, InventoryItem&gt; itemDictionary = <span class=\"keyword\">new</span> Dictionary&lt;ItemData, InventoryItem&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UI_ItemSlot[] uiSlots;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InventoryCategory</span>(<span class=\"params\">UI_ItemSlot[] slots</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        uiSlots = slots;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ItemType <span class=\"title\">GetItemType</span>()</span> =&gt; items.Count &gt; <span class=\"number\">0</span> ? items[<span class=\"number\">0</span>].data.itemType : ItemType.None;</span><br></pre></td></tr></table></figure></p>\n<p>同时将一些方法进行重写</p>\n<ul>\n<li>AddItem<br>\n<figure class=\"highlight c#\"><figcaption><span>AddItem</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加新物品到分类中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">AddItem</span>(<span class=\"params\">ItemData item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查物品是否已经存在于字典中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!itemDictionary.TryGetValue(item, <span class=\"keyword\">out</span> InventoryItem existingItem))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果物品不存在，创建一个新的 InventoryItem 并添加到列表和字典中</span></span><br><span class=\"line\">        InventoryItem newItem = <span class=\"keyword\">new</span> InventoryItem(item);</span><br><span class=\"line\">        items.Add(newItem);</span><br><span class=\"line\">        itemDictionary[item] = newItem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果物品已存在，则增加其堆叠数量</span></span><br><span class=\"line\">        existingItem.AddStack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 更新 UI 以反映最新的物品状态</span></span><br><span class=\"line\">    UpdateUI();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>RemoveItem<br>\n<figure class=\"highlight c#\"><figcaption><span>RemoveItem</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从分类中移除物品</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">RemoveItem</span>(<span class=\"params\">ItemData item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查物品是否存在于字典中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (itemDictionary.TryGetValue(item, <span class=\"keyword\">out</span> InventoryItem existingItem))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existingItem.stackSize &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果物品堆叠数量大于 1，减少堆叠数量</span></span><br><span class=\"line\">            existingItem.RemoveStack();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果堆叠数量为 1，移除物品</span></span><br><span class=\"line\">            items.Remove(existingItem);</span><br><span class=\"line\">            itemDictionary.Remove(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新 UI 以反映最新的物品状态</span></span><br><span class=\"line\">    UpdateUI();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>UpdateUI<br>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新 UI 槽位以显示当前的物品状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">UpdateUI</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清空所有 UI 槽位</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> slot <span class=\"keyword\">in</span> uiSlots)</span><br><span class=\"line\">        slot.CleanUpSlot();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将当前的物品更新到槽位中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; items.Count &amp;&amp; i &lt; uiSlots.Length; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        uiSlots[i].UpdateSlot(items[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>UpdateSelectedItem<br>\n<figure class=\"highlight c#\"><figcaption><span>UpdateSelectedItem</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新选中物品的状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">UpdateSelectedItem</span>(<span class=\"params\">ItemData selectedItem</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有物品，更新它们的选中状态</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> items)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果物品是选中的，则标记为选中，否则取消选中</span></span><br><span class=\"line\">        item.data.isSelect = item.data == selectedItem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>由于我需要单独列出 Equipment 下的小分类：Book 和 Weapon<br>\n 所以我需要再创建一个类来对 Equipment 中的小分类进行单独的筛选以及其他操作<br>\n <figure class=\"highlight c#\"><figcaption><span>EquipmentCategory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"comment\">// 管理装备类型物品的分类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">EquipmentCategory</span> : <span class=\"title\">MonoBehaviour</span>, <span class=\"title\">IInventoryCategory</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每种装备类型与其物品列表的映射</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;EquipmentType, List&lt;InventoryItem&gt;&gt; typeToItems;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每种装备类型与其 UI 槽位数组的映射</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;EquipmentType, UI_ItemSlot[]&gt; typeToUISlots;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数，用于初始化装备分类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EquipmentCategory</span>(<span class=\"params\">Dictionary&lt;EquipmentType, UI_ItemSlot[]&gt; slotsMapping</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化字典</span></span><br><span class=\"line\">        typeToItems = <span class=\"keyword\">new</span> Dictionary&lt;EquipmentType, List&lt;InventoryItem&gt;&gt;();</span><br><span class=\"line\">        typeToUISlots = slotsMapping;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为每种装备类型创建空的物品列表</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> type <span class=\"keyword\">in</span> typeToUISlots.Keys)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            typeToItems[type] = <span class=\"keyword\">new</span> List&lt;InventoryItem&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回此分类的物品类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ItemType <span class=\"title\">GetItemType</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ItemType.Equipment;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加物品到分类中</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AddItem</span>(<span class=\"params\">ItemData item</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 确保物品是装备类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item <span class=\"keyword\">is</span> ItemData_Equipment equipment)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> type = equipment.equipmentType;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 获取该类型的物品列表</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> items = typeToItems[type];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 检查是否已经存在该物品</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> existingItem = items.FirstOrDefault(i =&gt; i.data == item);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (existingItem != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果已存在，增加堆叠数量</span></span><br><span class=\"line\">                existingItem.AddStack();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果不存在，添加新的物品</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> newItem = <span class=\"keyword\">new</span> InventoryItem(item);</span><br><span class=\"line\">                items.Add(newItem);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 更新对应类型的 UI</span></span><br><span class=\"line\">            UpdateEquipmentSlots(type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从分类中移除物品</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RemoveItem</span>(<span class=\"params\">ItemData item</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 确保物品是装备类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item <span class=\"keyword\">is</span> ItemData_Equipment equipment)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> type = equipment.equipmentType;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 获取该类型的物品列表</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> items = typeToItems[type];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 检查是否存在该物品</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> existingItem = items.FirstOrDefault(i =&gt; i.data == item);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (existingItem != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (existingItem.stackSize &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果堆叠数量大于 1，则减少数量</span></span><br><span class=\"line\">                    existingItem.RemoveStack();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果堆叠数量为 1，则完全移除</span></span><br><span class=\"line\">                    items.Remove(existingItem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 更新对应类型的 UI</span></span><br><span class=\"line\">                UpdateEquipmentSlots(type);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//...以及其他方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>然后在 Inventory 中统一注册管理这些 Category<br>\n<figure class=\"highlight c#\"><figcaption><span>Inventory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">InitializeCategories</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">equipment = <span class=\"keyword\">new</span> List&lt;InventoryItem&gt;();</span><br><span class=\"line\">equipmentDictionary = <span class=\"keyword\">new</span> Dictionary&lt;ItemData_Equipment, InventoryItem&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 获取 UI 格子组件</span></span><br><span class=\"line\">inventoryItemSlot = inventorySlotParent.GetComponentsInChildren&lt;UI_ItemSlot&gt;();</span><br><span class=\"line\">stashItemSlot = stashSlotParent.GetComponentsInChildren&lt;UI_ItemSlot&gt;();</span><br><span class=\"line\">equipmentSlot = equpmentSlotParent.GetComponentsInChildren&lt;UI_EquipmentSlot&gt;();</span><br><span class=\"line\">bookSlot = bookSlotParent.GetComponentsInChildren&lt;UI_ItemSlot&gt;();</span><br><span class=\"line\">weaponSlot = weaponSlotParent.GetComponentsInChildren&lt;UI_WeaponSlot&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 初始化每种装备类型对应的 UI</span></span><br><span class=\"line\">equipmentSlotsMapping = <span class=\"keyword\">new</span> Dictionary&lt;EquipmentType, UI_ItemSlot[]&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#123; EquipmentType.Book, bookSlot &#125;,</span><br><span class=\"line\">\t&#123; EquipmentType.Weapon, weaponSlot &#125;,</span><br><span class=\"line\">\t<span class=\"comment\">// &#123; EquipmentType.Armor, armorSlots &#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 将映射传递给 EquipmentCategory</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> equipmentCategory = <span class=\"keyword\">new</span> EquipmentCategory(equipmentSlotsMapping);</span><br><span class=\"line\">categories = <span class=\"keyword\">new</span> Dictionary&lt;ItemType, IInventoryCategory&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#123; ItemType.Equipment, equipmentCategory &#125;,</span><br><span class=\"line\">\t&#123; ItemType.Material, <span class=\"keyword\">new</span> InventoryCategory(stashItemSlot) &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 随后就可以逐一优化方法，有新的列表加入的时候就不再需要全部注册一遍方法了<br>\n以 AddItem 为例<br>\n <figure class=\"highlight c#\"><figcaption><span>AddItem</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AddItem</span>(<span class=\"params\">ItemData _item</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_item == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogWarning(<span class=\"string\">&quot;Cannot add a null item to inventory.&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据 ItemType 找到对应的分类</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (categories.TryGetValue(_item.itemType, <span class=\"keyword\">out</span> IInventoryCategory category))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是 Equipment 类型，需要进一步处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_item <span class=\"keyword\">is</span> ItemData_Equipment equipment)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 针对 Equipment 类型，调用分类管理的方法</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> equipmentCategory = category <span class=\"keyword\">as</span> EquipmentCategory;</span><br><span class=\"line\">                equipmentCategory?.AddItem(equipment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 针对非 Equipment 类型（如 Material），直接添加</span></span><br><span class=\"line\">                category.AddItem(_item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogWarning(<span class=\"string\">$&quot;No category found for ItemType <span class=\"subst\">&#123;_item.itemType&#125;</span>. Check your category setup.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "从零开始的恶魔城开发"
            ]
        },
        {
            "id": "http://example.com/2025/01/19/game-engine/unity/unityProject01/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/",
            "url": "http://example.com/2025/01/19/game-engine/unity/unityProject01/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/",
            "title": "背包系统",
            "date_published": "2025-01-18T15:30:57.304Z",
            "content_html": "<h2 id=\"背包系统总结\"><a class=\"anchor\" href=\"#背包系统总结\">#</a> 背包系统总结</h2>\n<p>前言：这一部分并不复杂，所以我将通过功能模块的区分来记录而不是细分每一个文件的功能与彼此之间的逻辑来记录</p>\n<h3 id=\"1-存储模块\"><a class=\"anchor\" href=\"#1-存储模块\">#</a> 1. 存储模块</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>ItemData.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> ItemType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Material,</span><br><span class=\"line\">    Equipment</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[<span class=\"meta\">CreateAssetMenu(fileName = <span class=\"string\">&quot;New Item Data&quot;</span>, menuName = <span class=\"string\">&quot;Data/Item&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ItemData</span> : <span class=\"title\">ScriptableObject</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ItemType itemType;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">string</span> itemName;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Sprite icon;</span><br><span class=\"line\">    [<span class=\"meta\">Range(0,100)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> dropChance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先创建一个 itemdata 的基类，用来存储一些所有物品都会有的属性，其次在此基础上通过继承来创建一些其他的类，比如装备等<br>\n <figure class=\"highlight c#\"><figcaption><span>ItemData_Equipment.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Unity.VisualScripting;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 装备类型的枚举定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> EquipmentType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Weapon,       <span class=\"comment\">// 武器</span></span><br><span class=\"line\">    Armor,        <span class=\"comment\">// 防具</span></span><br><span class=\"line\">    Amulet,       <span class=\"comment\">// 护符</span></span><br><span class=\"line\">    Flask         <span class=\"comment\">// 药剂</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新的可创建的脚本资源菜单项</span></span><br><span class=\"line\">[<span class=\"meta\">CreateAssetMenu(fileName = <span class=\"string\">&quot;New Item Data&quot;</span>, menuName = <span class=\"string\">&quot;Data/Equipment&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ItemData_Equipment</span> : <span class=\"title\">ItemData</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 装备的类型，例如武器、防具等</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> EquipmentType equipmentType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 物品冷却时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> itemCooldown;</span><br><span class=\"line\">    <span class=\"comment\">// 物品效果数组</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ItemEffect[] itemEffects;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Major stats&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> strength;        <span class=\"comment\">// 力量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> agility;         <span class=\"comment\">// 敏捷</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> intelligence;    <span class=\"comment\">// 智力</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> vitality;        <span class=\"comment\">// 体力</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Offensive stats&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> damage;          <span class=\"comment\">// 攻击力</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> critChance;      <span class=\"comment\">// 暴击几率</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> critPower;       <span class=\"comment\">// 暴击伤害</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Defensive stats&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> health;          <span class=\"comment\">// 生命值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> armor;           <span class=\"comment\">// 护甲值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> evasion;         <span class=\"comment\">// 闪避值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> magicResistance; <span class=\"comment\">// 魔法抗性</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Magic stats&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> fireDamage;      <span class=\"comment\">// 火焰伤害</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> iceDamage;       <span class=\"comment\">// 冰霜伤害</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> lightingDamage;  <span class=\"comment\">// 闪电伤害</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Craft requirements&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;InventoryItem&gt; craftingMaterials; <span class=\"comment\">// 合成所需材料</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行物品效果</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Effect</span>(<span class=\"params\">Transform _enemyPosition</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有物品效果并在指定敌人位置执行效果</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> itemEffects)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            item.ExecuteEffect(_enemyPosition);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加物品的属性修饰符到玩家身上</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AddModifiers</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PlayerStats playerStats = PlayerManager.instance.player.GetComponent&lt;PlayerStats&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加主要属性的修饰符</span></span><br><span class=\"line\">        playerStats.strength.AddModifier(strength);</span><br><span class=\"line\">        playerStats.agility.AddModifier(agility);</span><br><span class=\"line\">        playerStats.intelligence.AddModifier(intelligence);</span><br><span class=\"line\">        playerStats.vitality.AddModifier(vitality);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加攻击属性的修饰符</span></span><br><span class=\"line\">        playerStats.damage.AddModifier(damage);</span><br><span class=\"line\">        playerStats.critChance.AddModifier(critChance);</span><br><span class=\"line\">        playerStats.critPower.AddModifier(critPower);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加防御属性的修饰符</span></span><br><span class=\"line\">        playerStats.maxHealth.AddModifier(health);</span><br><span class=\"line\">        playerStats.armor.AddModifier(armor);</span><br><span class=\"line\">        playerStats.evasion.AddModifier(evasion);</span><br><span class=\"line\">        playerStats.magicResistance.AddModifier(magicResistance);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加魔法属性的修饰符</span></span><br><span class=\"line\">        playerStats.fireDamage.AddModifier(fireDamage);</span><br><span class=\"line\">        playerStats.iceDamage.AddModifier(iceDamage);</span><br><span class=\"line\">        playerStats.lightingDamage.AddModifier(lightingDamage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移除物品的属性修饰符</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RemoveModifiers</span>()</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PlayerStats playerStats = PlayerManager.instance.player.GetComponent&lt;PlayerStats&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除主要属性的修饰符</span></span><br><span class=\"line\">        playerStats.strength.RemoveModifier(strength);</span><br><span class=\"line\">        playerStats.agility.RemoveModifier(agility);</span><br><span class=\"line\">        playerStats.intelligence.RemoveModifier(intelligence);</span><br><span class=\"line\">        playerStats.vitality.RemoveModifier(vitality);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除攻击属性的修饰符</span></span><br><span class=\"line\">        playerStats.damage.RemoveModifier(damage);</span><br><span class=\"line\">        playerStats.critChance.RemoveModifier(critChance);</span><br><span class=\"line\">        playerStats.critPower.RemoveModifier(critPower);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除防御属性的修饰符</span></span><br><span class=\"line\">        playerStats.maxHealth.RemoveModifier(health);</span><br><span class=\"line\">        playerStats.armor.RemoveModifier(armor);</span><br><span class=\"line\">        playerStats.evasion.RemoveModifier(evasion);</span><br><span class=\"line\">        playerStats.magicResistance.RemoveModifier(magicResistance);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除魔法属性的修饰符</span></span><br><span class=\"line\">        playerStats.fireDamage.RemoveModifier(fireDamage);</span><br><span class=\"line\">        playerStats.iceDamage.RemoveModifier(iceDamage);</span><br><span class=\"line\">        playerStats.lightingDamage.RemoveModifier(lightingDamage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>在此基础上通过 InventoryItem 来作为某个种类的仓库 (?) 来进行入栈出栈的操作以存储数据<br>\n <figure class=\"highlight c#\"><figcaption><span>InventoryItem.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\">[<span class=\"meta\">Serializable</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">InventoryItem</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ItemData data;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> stackSize;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InventoryItem</span>(<span class=\"params\">ItemData _newItemData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        data = _newItemData;</span><br><span class=\"line\">        AddStack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AddStack</span>()</span> =&gt; stackSize++;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RemoveStack</span>()</span> =&gt; stackSize--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后通过 Inventory 来联动仓库与 UI 的变动</p>\n<h3 id=\"2-人物装备模块\"><a class=\"anchor\" href=\"#2-人物装备模块\">#</a> 2. 人物装备模块</h3>\n<p>主要通过这部分代码来实现装备与仓库之间的联动与单个装备只能装备一个的功能<br>\n <figure class=\"highlight c#\"><figcaption><span>Inventory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">EquipItem</span>(<span class=\"params\">ItemData _item</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 装备新物品并替换旧物品</span></span><br><span class=\"line\">        ItemData_Equipment newEquipment = _item <span class=\"keyword\">as</span> ItemData_Equipment;</span><br><span class=\"line\">        InventoryItem newItem = <span class=\"keyword\">new</span> InventoryItem(newEquipment);</span><br><span class=\"line\"></span><br><span class=\"line\">        ItemData_Equipment oldEquipment = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 查找相同类型的已装备物品</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (KeyValuePair&lt;ItemData_Equipment, InventoryItem&gt; item <span class=\"keyword\">in</span> equipmentDictionary)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (item.Key.equipmentType == newEquipment.equipmentType)</span><br><span class=\"line\">                oldEquipment = item.Key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果存在旧装备，将其卸下并添加回背包</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldEquipment != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            UnequipItem(oldEquipment);</span><br><span class=\"line\">            AddItem(oldEquipment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 装备新物品并更新字典</span></span><br><span class=\"line\">        equipment.Add(newItem);</span><br><span class=\"line\">        equipmentDictionary.Add(newEquipment, newItem);</span><br><span class=\"line\">        newEquipment.AddModifiers();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从背包移除新装备</span></span><br><span class=\"line\">        RemoveItem(_item);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新 UI</span></span><br><span class=\"line\">        UpdateSlotUI();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>UI 当中在仓库点击装备<br>\n <figure class=\"highlight c#\"><figcaption><span>UI_ItemSlot</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnPointerDown</span>(<span class=\"params\">PointerEventData eventData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Input.GetKey(KeyCode.LeftControl))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Inventory.instance.RemoveItem(item.data);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item.data.itemType == ItemType.Equipment)</span><br><span class=\"line\">            Inventory.instance.EquipItem(item.data);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 UI 当中装备栏点击卸下<br>\n <figure class=\"highlight c#\"><figcaption><span>UI_EquipmentSlot.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">OnPointerDown</span>(<span class=\"params\">PointerEventData eventData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Inventory.instance.UnequipItem(item.data <span class=\"keyword\">as</span> ItemData_Equipment);</span><br><span class=\"line\">        Inventory.instance.AddItem(item.data <span class=\"keyword\">as</span> ItemData_Equipment);</span><br><span class=\"line\">        CleanUpSlot();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-敌人玩家死亡掉落系统\"><a class=\"anchor\" href=\"#3-敌人玩家死亡掉落系统\">#</a> 3. 敌人 / 玩家死亡掉落系统</h3>\n<h4 id=\"敌人掉落\"><a class=\"anchor\" href=\"#敌人掉落\">#</a> 敌人掉落</h4>\n<p>挂载 ItemDrop 方法在敌人身上，控制掉落</p>\n<p><figure class=\"highlight c#\"><figcaption><span>ItemDrop.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GenerateDrop</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有可能掉落的物品，按照掉落几率决定是否加入掉落列表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; possibleDrop.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Random.Range(<span class=\"number\">0</span>, <span class=\"number\">100</span>) &lt;= possibleDrop[i].dropChance) <span class=\"comment\">// 随机生成一个 0 到 100 的值，与掉落几率比较</span></span><br><span class=\"line\">                dropList.Add(possibleDrop[i]); <span class=\"comment\">// 将符合条件的物品加入掉落列表</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据掉落数量上限，从掉落列表中随机选择物品并掉落</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; possibleItemDrop; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ItemData randomItem = dropList[Random.Range(<span class=\"number\">0</span>, dropList.Count - <span class=\"number\">1</span>)]; <span class=\"comment\">// 随机选择一个物品</span></span><br><span class=\"line\">            dropList.Remove(randomItem); <span class=\"comment\">// 从列表中移除已掉落的物品，避免重复</span></span><br><span class=\"line\">            DropItem(randomItem); <span class=\"comment\">// w调用方法生成掉落物体</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建掉落物体的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">DropItem</span>(<span class=\"params\">ItemData _itemData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在当前物体位置生成一个新的掉落物体</span></span><br><span class=\"line\">        GameObject newDrop = Instantiate(dropPrefab, transform.position, Quaternion.identity);</span><br><span class=\"line\">        <span class=\"comment\">// 为掉落物体赋予一个随机的初始速度</span></span><br><span class=\"line\">        Vector2 randomVelocity = <span class=\"keyword\">new</span> Vector2(Random.Range(<span class=\"number\">-5</span>, <span class=\"number\">5</span>), Random.Range(<span class=\"number\">15</span>, <span class=\"number\">20</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置掉落物体的属性</span></span><br><span class=\"line\">        newDrop.GetComponent&lt;ItemObject&gt;().SetupItem(_itemData, randomVelocity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在 EnemyStatus 中敌人死去时下方挂上 DropItem 方法<br>\n <figure class=\"highlight c#\"><figcaption><span>EnemyStatus</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Die</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">base</span>.Die();</span><br><span class=\"line\">        enemy.Die();</span><br><span class=\"line\">        myDropSystem.GenerateDrop();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"玩家掉落\"><a class=\"anchor\" href=\"#玩家掉落\">#</a> 玩家掉落</h4>\n<p>玩家掉落这块重写了一个方法，因为玩家的掉落需要考虑是否有装备掉落或是材料掉落<br>\n <figure class=\"highlight c#\"><figcaption><span>PlayerItemDrop.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PlayerItemDrop</span> : <span class=\"title\">ItemDrop</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Player&#x27;s drop&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> chanceToLooseItems; <span class=\"comment\">// 玩家失去装备的几率</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> chanceToLooseMaterials; <span class=\"comment\">// 玩家失去材料的几率</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重写生成掉落物品的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">GenerateDrop</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Inventory inventory = Inventory.instance; <span class=\"comment\">// 获取玩家的物品管理实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;InventoryItem&gt; itemsToUnequip = <span class=\"keyword\">new</span> List&lt;InventoryItem&gt;(); <span class=\"comment\">// 用于存储需要卸下的装备</span></span><br><span class=\"line\">        List&lt;InventoryItem&gt; materialsToLoose = <span class=\"keyword\">new</span> List&lt;InventoryItem&gt;(); <span class=\"comment\">// 用于存储需要丢失的材料</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历玩家的装备列表，根据几率决定是否掉落装备</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (InventoryItem item <span class=\"keyword\">in</span> inventory.GetEquipmentList())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Random.Range(<span class=\"number\">0</span>, <span class=\"number\">100</span>) &lt;= chanceToLooseItems)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                DropItem(item.data); <span class=\"comment\">// 掉落该物品</span></span><br><span class=\"line\">                itemsToUnequip.Add(item); <span class=\"comment\">// 将物品加入需要卸下的列表</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 卸下所有被选中的装备</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; itemsToUnequip.Count; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            inventory.UnequipItem(itemsToUnequip[i].data <span class=\"keyword\">as</span> ItemData_Equipment); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历玩家的仓库列表，根据几率决定是否丢失材料</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (InventoryItem item <span class=\"keyword\">in</span> inventory.GetStashList())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Random.Range(<span class=\"number\">0</span>, <span class=\"number\">100</span>) &lt;= chanceToLooseMaterials)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                DropItem(item.data); <span class=\"comment\">// 掉落该材料</span></span><br><span class=\"line\">                materialsToLoose.Add(item); <span class=\"comment\">// 将材料加入需要丢失的列表</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从玩家仓库中移除所有被选中的材料</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; materialsToLoose.Count; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            inventory.RemoveItem(materialsToLoose[i].data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4特殊装备系统\"><a class=\"anchor\" href=\"#4特殊装备系统\">#</a> 4. 特殊装备系统</h3>\n<p>我们需要一些装备拥有一些特殊的性能，比如可以造成电击，抑或是可以恢复血量。<br>\n创建一个基类存储方法<br>\n <figure class=\"highlight c#\"><figcaption><span>ItemEffect.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ItemEffect</span> : <span class=\"title\">ScriptableObject</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">ExecuteEffect</span>(<span class=\"params\">Transform _enemyPosition</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Log(<span class=\"string\">&quot;Effect executed!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 在 Equipment 中创建数组储存 Effect 方法并创建一个方法用于调用这些方法<br>\n <figure class=\"highlight c#\"><figcaption><span>ItemData_Equipment.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 物品效果数组</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ItemEffect[] itemEffects;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 执行物品效果</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Effect</span>(<span class=\"params\">Transform _enemyPosition</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历所有物品效果并在指定敌人位置执行效果</span></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> itemEffects)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            item.ExecuteEffect(_enemyPosition);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>\n 同时在 Inventory 中创建获取指定装备的方法<br>\n <figure class=\"highlight c#\"><figcaption><span>Inventory.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ItemData_Equipment <span class=\"title\">GetEquipment</span>(<span class=\"params\">EquipmentType _type</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取指定类型的装备</span></span><br><span class=\"line\">        ItemData_Equipment equipedItem = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (KeyValuePair&lt;ItemData_Equipment, InventoryItem&gt; item <span class=\"keyword\">in</span> equipmentDictionary)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (item.Key.equipmentType == _type)</span><br><span class=\"line\">                equipedItem = item.Key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> equipedItem;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>\n 然后在 PlayerAnimationTriggers 中攻击时调用效果<br>\n <figure class=\"highlight c#\"><figcaption><span>PlayerAnimationTriggers.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AttackTrigger</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取攻击范围内的所有碰撞体</span></span><br><span class=\"line\">    Collider2D[] colliders = Physics2D.OverlapCircleAll(player.attackCheck.position, player.attackCheckRadius);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有碰撞体</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> hit <span class=\"keyword\">in</span> colliders)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查是否是敌人</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hit.GetComponent&lt;Enemy&gt;() != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取敌人的状态组件</span></span><br><span class=\"line\">            EnemyStats _target = hit.GetComponent&lt;EnemyStats&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果敌人状态存在，对敌人造成伤害</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(_target != <span class=\"literal\">null</span>) </span><br><span class=\"line\">                player.stats.DoDamage(_target);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 获取玩家当前装备的武器数据</span></span><br><span class=\"line\">            ItemData_Equipment weaponData = Inventory.instance.GetEquipment(EquipmentType.Weapon);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果有装备武器，执行武器的特殊效果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (weaponData != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                weaponData.Effect(_target.transform);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5一些特殊能力的实现\"><a class=\"anchor\" href=\"#5一些特殊能力的实现\">#</a> 5. 一些特殊能力的实现</h3>\n<p>这边以雷击效果举例，其他效果将不再赘述<br>\n将 controller 文件绑定在雷击动画上，并将其作为预制件<br>\n <figure class=\"highlight c#\"><figcaption><span>ThunderStrike_Controller.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ThunderStrike_Controller</span> : <span class=\"title\">MonoBehaviour</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">OnTriggerEnter2D</span>(<span class=\"params\">Collider2D collision</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(collision.GetComponent&lt;Enemy&gt;() != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            PlayerStats playerStats = PlayerManager.instance.player.GetComponent&lt;PlayerStats&gt;();</span><br><span class=\"line\">            EnemyStats enemyTarget = collision.GetComponent&lt;EnemyStats&gt;();</span><br><span class=\"line\">            playerStats.DoMagicalDamage(enemyTarget);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 然后，将预制件放在 effect 的 data 中，再将 effect 放在武器的 data 中，达成绑定效果。<br>\n<img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/unity/unity2d/%E7%BB%91%E5%AE%9Aprefab.png\" alt></p>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/unity%2Funity2d%2F%E7%BB%91%E5%AE%9Aeffect.png\" alt><br>\n然后是电击后的自动索敌效果，同理创建了一个 ShockStrike_Controller 控制类来实现逻辑<br>\n <figure class=\"highlight c#\"><figcaption><span>ShockStrike_Controller.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ShockStrike_Controller</span> : <span class=\"title\">MonoBehaviour</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> CharacterStats targetStats; <span class=\"comment\">// 目标的状态信息</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> speed; <span class=\"comment\">// 移动速度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> damage; <span class=\"comment\">// 造成的伤害值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Animator anim; <span class=\"comment\">// 动画控制器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> triggered; <span class=\"comment\">// 是否已经触发</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        anim = GetComponentInChildren&lt;Animator&gt;(); <span class=\"comment\">// 获取子物体中的动画组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化攻击的伤害值和目标状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Setup</span>(<span class=\"params\"><span class=\"built_in\">int</span> _damage, CharacterStats _targetStats</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        damage = _damage; <span class=\"comment\">// 设置伤害值</span></span><br><span class=\"line\">        targetStats = _targetStats; <span class=\"comment\">// 设置目标状态</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每帧更新</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!targetStats) <span class=\"comment\">// 如果没有目标，则退出</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (triggered) <span class=\"comment\">// 如果已经触发，则退出</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移动到目标位置</span></span><br><span class=\"line\">        transform.position = Vector2.MoveTowards(transform.position, targetStats.transform.position, speed * Time.deltaTime);</span><br><span class=\"line\">        <span class=\"comment\">// 调整朝向，指向目标</span></span><br><span class=\"line\">        transform.right = transform.position - targetStats.transform.position;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查是否到达目标</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Vector2.Distance(transform.position, targetStats.transform.position) &lt; <span class=\"number\">.1</span>f)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            anim.transform.localPosition = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">.5</span>f); <span class=\"comment\">// 调整动画位置</span></span><br><span class=\"line\">            anim.transform.localRotation = Quaternion.identity; <span class=\"comment\">// 重置动画旋转</span></span><br><span class=\"line\"></span><br><span class=\"line\">            transform.localRotation = Quaternion.identity; <span class=\"comment\">// 重置自身旋转</span></span><br><span class=\"line\">            transform.localScale = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">3</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 放大自身以展现效果</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 延迟执行伤害并销毁自身</span></span><br><span class=\"line\">            Invoke(<span class=\"string\">&quot;DamageAndSelfDestroy&quot;</span>, <span class=\"number\">.2</span>f);</span><br><span class=\"line\">            triggered = <span class=\"literal\">true</span>; <span class=\"comment\">// 标记为已触发</span></span><br><span class=\"line\">            anim.SetTrigger(<span class=\"string\">&quot;Hit&quot;</span>); <span class=\"comment\">// 播放击中动画</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对目标造成伤害并销毁自身</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">DamageAndSelfDestroy</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        targetStats.ApplyShock(<span class=\"literal\">true</span>); <span class=\"comment\">// 触发目标的震荡效果</span></span><br><span class=\"line\">        targetStats.TakeDamage(<span class=\"number\">1</span>); <span class=\"comment\">// 对目标造成 1 点伤害</span></span><br><span class=\"line\">        Destroy(gameObject, <span class=\"number\">.4</span>f); <span class=\"comment\">// 在 0.4 秒后销毁自身</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "从零开始的恶魔城开发"
            ]
        },
        {
            "id": "http://example.com/2025/01/18/game-engine/unity/unityProject01/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F02(Controller%20part)/",
            "url": "http://example.com/2025/01/18/game-engine/unity/unityProject01/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F02(Controller%20part)/",
            "title": "技能系统02(Controller part)",
            "date_published": "2025-01-18T03:47:49.086Z",
            "content_html": "<h1 id=\"skill-系统总结\"><a class=\"anchor\" href=\"#skill-系统总结\">#</a> Skill 系统总结</h1>\n<h2 id=\"skill\"><a class=\"anchor\" href=\"#skill\">#</a> Skill</h2>\n<p><code>Skill</code>  类是所有技能类的基础类，提供通用的技能逻辑和方法。</p>\n<hr>\n<h3 id=\"主要特点\"><a class=\"anchor\" href=\"#主要特点\">#</a> 主要特点</h3>\n<h3 id=\"1-冷却机制\"><a class=\"anchor\" href=\"#1-冷却机制\">#</a> 1. 冷却机制</h3>\n<ul>\n<li>\n<p>通过  <code>cooldown</code>  和  <code>cooldownTimer</code>  属性管理技能的冷却时间。</p>\n</li>\n<li>\n<p>每帧更新冷却计时器。</p>\n</li>\n</ul>\n<h4 id=\"实现方式\"><a class=\"anchor\" href=\"#实现方式\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cooldownTimer -= Time.deltaTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-技能使用逻辑\"><a class=\"anchor\" href=\"#2-技能使用逻辑\">#</a> 2. 技能使用逻辑</h3>\n<ul>\n<li>\n<p>提供  <code>CanUseSkill()</code>  方法检查技能是否可以使用。</p>\n</li>\n<li>\n<p>如果可以使用技能，则重置冷却时间并调用  <code>UseSkill()</code> 。</p>\n</li>\n</ul>\n<h4 id=\"实现方式-2\"><a class=\"anchor\" href=\"#实现方式-2\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"built_in\">bool</span> <span class=\"title\">CanUseSkill</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cooldownTimer &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UseSkill();</span><br><span class=\"line\">        cooldownTimer = cooldown;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    player.fx.CreatePopUpText(<span class=\"string\">&quot;Cooldown&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-解锁检测\"><a class=\"anchor\" href=\"#3-解锁检测\">#</a> 3. 解锁检测</h3>\n<ul>\n<li>\n<p>提供  <code>CheckUnlock()</code>  方法，用于子类实现具体的解锁逻辑。</p>\n</li>\n<li>\n<p>在  <code>Start()</code>  方法中调用。</p>\n</li>\n</ul>\n<h4 id=\"实现方式-3\"><a class=\"anchor\" href=\"#实现方式-3\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    player = PlayerManager.instance.player;</span><br><span class=\"line\">    CheckUnlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-最近敌人查找\"><a class=\"anchor\" href=\"#4-最近敌人查找\">#</a> 4. 最近敌人查找</h3>\n<ul>\n<li>提供  <code>FindClosestEnemy()</code>  方法，用于查找指定范围内最近的敌人。</li>\n</ul>\n<h4 id=\"实现方式-4\"><a class=\"anchor\" href=\"#实现方式-4\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> Transform <span class=\"title\">FindClosestEnemy</span>(<span class=\"params\">Transform _checkTransform</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在指定的 Transform（_checkTransform）周围的半径为25的范围内查找所有的碰撞体</span></span><br><span class=\"line\">    Collider2D[] colliders = Physics2D.OverlapCircleAll(_checkTransform.position, <span class=\"number\">25</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化最近敌人的距离为正无穷大，以便找到最近的敌人</span></span><br><span class=\"line\">    <span class=\"built_in\">float</span> closestDistance = Mathf.Infinity;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化最近敌人的 Transform 变量为 null</span></span><br><span class=\"line\">    Transform closestEnemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有检测到的碰撞体</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> hit <span class=\"keyword\">in</span> colliders)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查当前碰撞体是否附加了一个 Enemy 脚本（表示这是一个敌人）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hit.GetComponent&lt;Enemy&gt;() != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算 _checkTransform 到当前敌人的距离</span></span><br><span class=\"line\">            <span class=\"built_in\">float</span> distanceToEnemy = Vector2.Distance(_checkTransform.position, hit.transform.position);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果当前敌人距离小于之前记录的最近距离</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distanceToEnemy &lt; closestDistance)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 更新最近的距离</span></span><br><span class=\"line\">                closestDistance = distanceToEnemy;</span><br><span class=\"line\">                <span class=\"comment\">// 更新最近敌人的 Transform</span></span><br><span class=\"line\">                closestEnemy = hit.transform;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回最近敌人的 Transform（如果没有敌人，则返回 null）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> closestEnemy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"子类继承\"><a class=\"anchor\" href=\"#子类继承\">#</a> 子类继承</h3>\n<p><code>Skill</code>  类提供了基础功能，供所有技能类继承和扩展。例如：</p>\n<ul>\n<li>\n<p><code>Sword_Skill</code></p>\n</li>\n<li>\n<p><code>Dash_Skill</code></p>\n</li>\n<li>\n<p><code>Clone_Skill</code></p>\n</li>\n</ul>\n<p>子类可以重写以下方法以实现自定义逻辑：</p>\n<ul>\n<li>\n<p><code>Start()</code></p>\n</li>\n<li>\n<p><code>Update()</code></p>\n</li>\n<li>\n<p><code>UseSkill()</code></p>\n</li>\n<li>\n<p><code>CheckUnlock()</code></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"skillmanager\"><a class=\"anchor\" href=\"#skillmanager\">#</a> SkillManager</h2>\n<p><code>SkillManager</code>  类是技能系统的核心组件，负责初始化并提供对所有技能实例的全局访问。</p>\n<hr>\n<h3 id=\"主要特点-2\"><a class=\"anchor\" href=\"#主要特点-2\">#</a> 主要特点</h3>\n<h3 id=\"1-单例模式\"><a class=\"anchor\" href=\"#1-单例模式\">#</a> 1. 单例模式</h3>\n<ul>\n<li>\n<p>确保  <code>SkillManager</code>  全局仅有一个实例。</p>\n</li>\n<li>\n<p>可通过静态属性  <code>instance</code>  进行访问。</p>\n</li>\n</ul>\n<h4 id=\"实现方式-5\"><a class=\"anchor\" href=\"#实现方式-5\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void Awake()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (instance != null)</span><br><span class=\"line\">        Destroy(instance.gameObject);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>如果已有另一个实例，销毁当前游戏对象。</p>\n</li>\n<li>\n<p>否则，将当前对象设置为全局实例。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-技能实例管理\"><a class=\"anchor\" href=\"#2-技能实例管理\">#</a> 2. 技能实例管理</h3>\n<ul>\n<li>\n<p>为每个技能维护私有字段，并通过只读公共属性提供访问。</p>\n</li>\n<li>\n<p>动态加载附加在同一游戏对象上的技能组件。</p>\n</li>\n</ul>\n<h4 id=\"初始化方式\"><a class=\"anchor\" href=\"#初始化方式\">#</a> 初始化方式：</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void Start()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dash = GetComponent&lt;Dash_Skill&gt;();</span><br><span class=\"line\">    clone = GetComponent&lt;Clone_Skill&gt;();</span><br><span class=\"line\">    sword = GetComponent&lt;Sword_Skill&gt;();</span><br><span class=\"line\">    blackhole = GetComponent&lt;Blackhole_Skill&gt;();</span><br><span class=\"line\">    crystal = GetComponent&lt;Crystal_Skill&gt;();</span><br><span class=\"line\">    parry = GetComponent&lt;Parry_Skill&gt;();</span><br><span class=\"line\">    dodge = GetComponent&lt;Dodge_Skill&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>使用  <code>GetComponent&lt;T&gt;()</code>  获取以下组件：</p>\n<ul>\n<li>\n<p><code>Dash_Skill</code></p>\n</li>\n<li>\n<p><code>Clone_Skill</code></p>\n</li>\n<li>\n<p><code>Sword_Skill</code></p>\n</li>\n<li>\n<p><code>Blackhole_Skill</code></p>\n</li>\n<li>\n<p><code>Crystal_Skill</code></p>\n</li>\n<li>\n<p><code>Parry_Skill</code></p>\n</li>\n<li>\n<p><code>Dodge_Skill</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"管理的技能字段\"><a class=\"anchor\" href=\"#管理的技能字段\">#</a> 管理的技能字段</h3>\n<ul>\n<li>\n<p><code>dash</code> : 对应  <code>Dash_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>clone</code> : 对应  <code>Clone_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>sword</code> : 对应  <code>Sword_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>blackhole</code> : 对应  <code>Blackhole_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>crystal</code> : 对应  <code>Crystal_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>parry</code> : 对应  <code>Parry_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>dodge</code> : 对应  <code>Dodge_Skill</code>  实例。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"系统角色\"><a class=\"anchor\" href=\"#系统角色\">#</a> 系统角色</h3>\n<ul>\n<li>\n<p><code>SkillManager</code>  是所有技能相关操作的主要访问点。</p>\n</li>\n<li>\n<p>其他游戏组件通过该管理器与技能交互，确保操作集中化。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"各技能类\"><a class=\"anchor\" href=\"#各技能类\">#</a> 各技能类</h2>\n<h3 id=\"1-sword_skill\"><a class=\"anchor\" href=\"#1-sword_skill\">#</a> 1. Sword_Skill</h3>\n<p><code>Sword_Skill</code>  是  <code>Skill</code>  的派生类，专注于与剑相关的技能逻辑，包括多种剑类型及其相应的解锁和使用机制。</p>\n<h4 id=\"主要特点-3\"><a class=\"anchor\" href=\"#主要特点-3\">#</a> 主要特点</h4>\n<h5 id=\"1-剑的类型\"><a class=\"anchor\" href=\"#1-剑的类型\">#</a> 1. 剑的类型</h5>\n<ul>\n<li>\n<p>提供 4 种剑类型：</p>\n<ul>\n<li>\n<p>Regular（普通）</p>\n</li>\n<li>\n<p>Bounce（弹射）</p>\n</li>\n<li>\n<p>Pierce（穿刺）</p>\n</li>\n<li>\n<p>Spin（旋转）</p>\n</li>\n</ul>\n</li>\n<li>\n<p>不同类型剑有独特的属性，如重力、弹射次数、旋转持续时间等。</p>\n</li>\n</ul>\n<h5 id=\"类型定义\"><a class=\"anchor\" href=\"#类型定义\">#</a> 类型定义：</h5>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> SwordType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Regular,</span><br><span class=\"line\">    Bounce,</span><br><span class=\"line\">    Pierce,</span><br><span class=\"line\">    Spin</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"2-解锁机制\"><a class=\"anchor\" href=\"#2-解锁机制\">#</a> 2. 解锁机制</h4>\n<ul>\n<li>\n<p>每种剑类型通过解锁按钮控制。</p>\n</li>\n<li>\n<p>提供以下方法来解锁对应剑类型：</p>\n<ul>\n<li>\n<p><code>UnlockSword()</code></p>\n</li>\n<li>\n<p><code>UnlockBounceSword()</code></p>\n</li>\n<li>\n<p><code>UnlockPierceSword()</code></p>\n</li>\n<li>\n<p><code>UnlockSpinSword()</code></p>\n</li>\n<li>\n<p><code>UnlockTimeStop()</code> （时间停止被动技能）</p>\n</li>\n<li>\n<p><code>UnlockVulnurable()</code> （脆弱被动技能）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"解锁逻辑\"><a class=\"anchor\" href=\"#解锁逻辑\">#</a> 解锁逻辑：</h5>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">UnlockSword</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (swordUnlockButton.unlocked)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        swordType = SwordType.Regular;</span><br><span class=\"line\">        swordUnlocked = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"3-辅助瞄准\"><a class=\"anchor\" href=\"#3-辅助瞄准\">#</a> 3. 辅助瞄准</h4>\n<ul>\n<li>\n<p>提供瞄准点（Aim Dots）功能，显示剑的预计轨迹。</p>\n</li>\n<li>\n<p>瞄准点的位置由抛物线计算决定。</p>\n</li>\n</ul>\n<h5 id=\"实现方式-6\"><a class=\"anchor\" href=\"#实现方式-6\">#</a> 实现方式：</h5>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Vector2 <span class=\"title\">AimDirection</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector2 playerPosition = player.transform.position;</span><br><span class=\"line\">    Vector2 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);</span><br><span class=\"line\">    Vector2 direction = mousePosition - playerPosition;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> direction;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"4-创建剑\"><a class=\"anchor\" href=\"#4-创建剑\">#</a> 4. 创建剑</h4>\n<ul>\n<li>\n<p><code>CreateSword()</code>  方法用于生成剑，并根据当前剑类型配置剑的行为。</p>\n</li>\n<li>\n<p>每种剑类型调用对应的  <code>Setup</code>  方法配置独特行为。</p>\n</li>\n</ul>\n<h5 id=\"实现方式-7\"><a class=\"anchor\" href=\"#实现方式-7\">#</a> 实现方式：</h5>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">CreateSword</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新的剑实例，并将其位置设置为玩家的位置，方向与当前物体一致</span></span><br><span class=\"line\">        GameObject newSword = Instantiate(swordPrefab, player.transform.position, transform.rotation);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取新剑对象的 Sword_Skill_Controller 脚本</span></span><br><span class=\"line\">        Sword_Skill_Controller newSwordScript = newSword.GetComponent&lt;Sword_Skill_Controller&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 根据剑的类型设置对应的技能效果</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (swordType == SwordType.Bounce)</span><br><span class=\"line\">            newSwordScript.SetupBounce(<span class=\"literal\">true</span>, bounceAmount, bounceSpeed); <span class=\"comment\">// 设置反弹剑效果</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (swordType == SwordType.Pierce)</span><br><span class=\"line\">            newSwordScript.SetupPierce(pierceAmount); <span class=\"comment\">// 设置穿刺剑效果</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (swordType == SwordType.Spin)</span><br><span class=\"line\">            newSwordScript.SetupSpin(<span class=\"literal\">true</span>, maxTravelDistance, spinDuration, hitCooldown); <span class=\"comment\">// 设置旋转剑效果</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">// 设置通用剑属性，如方向、重力、玩家引用、冻结时间和返回速度</span></span><br><span class=\"line\">        newSwordScript.SetupSword(finalDir, swordGravity, player, freezeTimeDuration, returnSpeed);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将新创建的剑分配给玩家</span></span><br><span class=\"line\">        player.AssignNewSword(newSword);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 禁用某些点的显示（具体作用依赖于实现）</span></span><br><span class=\"line\">        DotsActive(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-其他功能\"><a class=\"anchor\" href=\"#5-其他功能\">#</a> 5. 其他功能</h4>\n<ul>\n<li>\n<p><strong>时间停止（Time Stop）和脆弱（Vulnerable）被动技能</strong>：</p>\n<ul>\n<li>解锁后会自动激活对应效果。</li>\n</ul>\n</li>\n<li>\n<p><strong>解锁状态检测</strong>：在  <code>CheckUnlock()</code>  方法中检查所有解锁按钮状态。</p>\n</li>\n</ul>\n<h4 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h4>\n<ul>\n<li>\n<p>提供与剑相关的技能逻辑和实现。</p>\n</li>\n<li>\n<p>支持多种剑类型和扩展功能，如辅助瞄准和被动技能。</p>\n</li>\n<li>\n<p>与  <code>Skill</code>  基类和  <code>SkillManager</code>  交互，共享技能系统的框架。</p>\n</li>\n</ul>\n<h3 id=\"2-blackhole_skillcs\"><a class=\"anchor\" href=\"#2-blackhole_skillcs\">#</a> 2. Blackhole_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现黑洞技能，生成黑洞并吸引敌人，同时支持黑洞的生长和收缩机制。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>黑洞的大小、持续时间、以及攻击次数可配置。</li>\n<li>可在特定状态下触发结束。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>调用  <code>SkillManager.instance</code>  来播放音效或控制黑洞状态。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-clone_skillcs\"><a class=\"anchor\" href=\"#3-clone_skillcs\">#</a> 3. Clone_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现召唤克隆体的技能，并支持多种克隆相关特性。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>支持攻击型克隆、侵略性克隆、多重克隆和水晶替代克隆。</li>\n<li>提供克隆生成的延迟机制。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li><code>Crystal_Skill</code>  可以替代克隆生成。</li>\n<li>与其他技能（如  <code>Dash_Skill</code>  和  <code>Dodge_Skill</code> ）的特性协同。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"4-crystal_skillcs\"><a class=\"anchor\" href=\"#4-crystal_skillcs\">#</a> 4. Crystal_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现水晶技能，水晶可以作为防御机制，也支持爆炸和移动特性。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>支持多层堆叠水晶的生成和使用。</li>\n<li>提供爆炸型和移动型水晶解锁机制。</li>\n<li>可与克隆技能互相替代。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>与  <code>Clone_Skill</code>  协作实现水晶和克隆的互相替代功能。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"5-dash_skillcs\"><a class=\"anchor\" href=\"#5-dash_skillcs\">#</a> 5. Dash_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现冲刺技能，支持冲刺时生成克隆体或抵达目标位置后生成克隆体。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>可解锁冲刺克隆和到达克隆两种特性。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>调用  <code>Clone_Skill</code>  来生成克隆。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"6-dodge_skillcs\"><a class=\"anchor\" href=\"#6-dodge_skillcs\">#</a> 6. Dodge_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现闪避技能，支持闪避镜像功能。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>提升闪避数值，并提供镜像闪避的解锁选项。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>使用  <code>Clone_Skill</code>  生成镜像。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"7-parry_skillcs\"><a class=\"anchor\" href=\"#7-parry_skillcs\">#</a> 7. Parry_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现格挡技能，可恢复生命值或生成镜像。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>支持恢复生命值的解锁选项。</li>\n<li>在成功格挡时触发镜像生成。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>通过  <code>Clone_Skill</code>  实现镜像生成。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"文件之间的联系\"><a class=\"anchor\" href=\"#文件之间的联系\">#</a> 文件之间的联系</h2>\n<ol>\n<li><strong>SkillManager.cs</strong> 负责管理所有技能类，是各技能的单一入口。</li>\n<li><strong>技能之间的交互</strong>：\n<ul>\n<li>多个技能通过  <code>SkillManager</code>  调用其他技能实例。例如：\n<ul>\n<li><code>Dash_Skill</code>  和  <code>Dodge_Skill</code>  会调用  <code>Clone_Skill</code> 。</li>\n<li><code>Sword_Skill</code>  和  <code>Crystal_Skill</code>  之间有能力互相替代。</li>\n</ul>\n</li>\n<li>大部分技能类使用基础类  <code>Skill.cs</code>  提供的通用逻辑。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>如需进一步补充或优化，请告诉我！</p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "从零开始的恶魔城开发"
            ]
        },
        {
            "id": "http://example.com/2025/01/17/game-engine/unity/unityProject01/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F01(Skill%20part)/",
            "url": "http://example.com/2025/01/17/game-engine/unity/unityProject01/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F01(Skill%20part)/",
            "title": "技能系统01(Skill part)",
            "date_published": "2025-01-17T12:09:40.699Z",
            "content_html": "<h1 id=\"skill-系统总结\"><a class=\"anchor\" href=\"#skill-系统总结\">#</a> Skill 系统总结</h1>\n<h2 id=\"skill\"><a class=\"anchor\" href=\"#skill\">#</a> Skill</h2>\n<p><code>Skill</code>  类是所有技能类的基础类，提供通用的技能逻辑和方法。</p>\n<hr>\n<h3 id=\"主要特点\"><a class=\"anchor\" href=\"#主要特点\">#</a> 主要特点</h3>\n<h3 id=\"1-冷却机制\"><a class=\"anchor\" href=\"#1-冷却机制\">#</a> 1. 冷却机制</h3>\n<ul>\n<li>\n<p>通过  <code>cooldown</code>  和  <code>cooldownTimer</code>  属性管理技能的冷却时间。</p>\n</li>\n<li>\n<p>每帧更新冷却计时器。</p>\n</li>\n</ul>\n<h4 id=\"实现方式\"><a class=\"anchor\" href=\"#实现方式\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cooldownTimer -= Time.deltaTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-技能使用逻辑\"><a class=\"anchor\" href=\"#2-技能使用逻辑\">#</a> 2. 技能使用逻辑</h3>\n<ul>\n<li>\n<p>提供  <code>CanUseSkill()</code>  方法检查技能是否可以使用。</p>\n</li>\n<li>\n<p>如果可以使用技能，则重置冷却时间并调用  <code>UseSkill()</code> 。</p>\n</li>\n</ul>\n<h4 id=\"实现方式-2\"><a class=\"anchor\" href=\"#实现方式-2\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"built_in\">bool</span> <span class=\"title\">CanUseSkill</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cooldownTimer &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UseSkill();</span><br><span class=\"line\">        cooldownTimer = cooldown;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    player.fx.CreatePopUpText(<span class=\"string\">&quot;Cooldown&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-解锁检测\"><a class=\"anchor\" href=\"#3-解锁检测\">#</a> 3. 解锁检测</h3>\n<ul>\n<li>\n<p>提供  <code>CheckUnlock()</code>  方法，用于子类实现具体的解锁逻辑。</p>\n</li>\n<li>\n<p>在  <code>Start()</code>  方法中调用。</p>\n</li>\n</ul>\n<h4 id=\"实现方式-3\"><a class=\"anchor\" href=\"#实现方式-3\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    player = PlayerManager.instance.player;</span><br><span class=\"line\">    CheckUnlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-最近敌人查找\"><a class=\"anchor\" href=\"#4-最近敌人查找\">#</a> 4. 最近敌人查找</h3>\n<ul>\n<li>提供  <code>FindClosestEnemy()</code>  方法，用于查找指定范围内最近的敌人。</li>\n</ul>\n<h4 id=\"实现方式-4\"><a class=\"anchor\" href=\"#实现方式-4\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> Transform <span class=\"title\">FindClosestEnemy</span>(<span class=\"params\">Transform _checkTransform</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在指定的 Transform（_checkTransform）周围的半径为25的范围内查找所有的碰撞体</span></span><br><span class=\"line\">    Collider2D[] colliders = Physics2D.OverlapCircleAll(_checkTransform.position, <span class=\"number\">25</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化最近敌人的距离为正无穷大，以便找到最近的敌人</span></span><br><span class=\"line\">    <span class=\"built_in\">float</span> closestDistance = Mathf.Infinity;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化最近敌人的 Transform 变量为 null</span></span><br><span class=\"line\">    Transform closestEnemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有检测到的碰撞体</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> hit <span class=\"keyword\">in</span> colliders)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查当前碰撞体是否附加了一个 Enemy 脚本（表示这是一个敌人）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hit.GetComponent&lt;Enemy&gt;() != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算 _checkTransform 到当前敌人的距离</span></span><br><span class=\"line\">            <span class=\"built_in\">float</span> distanceToEnemy = Vector2.Distance(_checkTransform.position, hit.transform.position);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果当前敌人距离小于之前记录的最近距离</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distanceToEnemy &lt; closestDistance)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 更新最近的距离</span></span><br><span class=\"line\">                closestDistance = distanceToEnemy;</span><br><span class=\"line\">                <span class=\"comment\">// 更新最近敌人的 Transform</span></span><br><span class=\"line\">                closestEnemy = hit.transform;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回最近敌人的 Transform（如果没有敌人，则返回 null）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> closestEnemy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"子类继承\"><a class=\"anchor\" href=\"#子类继承\">#</a> 子类继承</h3>\n<p><code>Skill</code>  类提供了基础功能，供所有技能类继承和扩展。例如：</p>\n<ul>\n<li>\n<p><code>Sword_Skill</code></p>\n</li>\n<li>\n<p><code>Dash_Skill</code></p>\n</li>\n<li>\n<p><code>Clone_Skill</code></p>\n</li>\n</ul>\n<p>子类可以重写以下方法以实现自定义逻辑：</p>\n<ul>\n<li>\n<p><code>Start()</code></p>\n</li>\n<li>\n<p><code>Update()</code></p>\n</li>\n<li>\n<p><code>UseSkill()</code></p>\n</li>\n<li>\n<p><code>CheckUnlock()</code></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"skillmanager\"><a class=\"anchor\" href=\"#skillmanager\">#</a> SkillManager</h2>\n<p><code>SkillManager</code>  类是技能系统的核心组件，负责初始化并提供对所有技能实例的全局访问。</p>\n<hr>\n<h3 id=\"主要特点-2\"><a class=\"anchor\" href=\"#主要特点-2\">#</a> 主要特点</h3>\n<h3 id=\"1-单例模式\"><a class=\"anchor\" href=\"#1-单例模式\">#</a> 1. 单例模式</h3>\n<ul>\n<li>\n<p>确保  <code>SkillManager</code>  全局仅有一个实例。</p>\n</li>\n<li>\n<p>可通过静态属性  <code>instance</code>  进行访问。</p>\n</li>\n</ul>\n<h4 id=\"实现方式-5\"><a class=\"anchor\" href=\"#实现方式-5\">#</a> 实现方式：</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void Awake()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (instance != null)</span><br><span class=\"line\">        Destroy(instance.gameObject);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>如果已有另一个实例，销毁当前游戏对象。</p>\n</li>\n<li>\n<p>否则，将当前对象设置为全局实例。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-技能实例管理\"><a class=\"anchor\" href=\"#2-技能实例管理\">#</a> 2. 技能实例管理</h3>\n<ul>\n<li>\n<p>为每个技能维护私有字段，并通过只读公共属性提供访问。</p>\n</li>\n<li>\n<p>动态加载附加在同一游戏对象上的技能组件。</p>\n</li>\n</ul>\n<h4 id=\"初始化方式\"><a class=\"anchor\" href=\"#初始化方式\">#</a> 初始化方式：</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void Start()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dash = GetComponent&lt;Dash_Skill&gt;();</span><br><span class=\"line\">    clone = GetComponent&lt;Clone_Skill&gt;();</span><br><span class=\"line\">    sword = GetComponent&lt;Sword_Skill&gt;();</span><br><span class=\"line\">    blackhole = GetComponent&lt;Blackhole_Skill&gt;();</span><br><span class=\"line\">    crystal = GetComponent&lt;Crystal_Skill&gt;();</span><br><span class=\"line\">    parry = GetComponent&lt;Parry_Skill&gt;();</span><br><span class=\"line\">    dodge = GetComponent&lt;Dodge_Skill&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>使用  <code>GetComponent&lt;T&gt;()</code>  获取以下组件：</p>\n<ul>\n<li>\n<p><code>Dash_Skill</code></p>\n</li>\n<li>\n<p><code>Clone_Skill</code></p>\n</li>\n<li>\n<p><code>Sword_Skill</code></p>\n</li>\n<li>\n<p><code>Blackhole_Skill</code></p>\n</li>\n<li>\n<p><code>Crystal_Skill</code></p>\n</li>\n<li>\n<p><code>Parry_Skill</code></p>\n</li>\n<li>\n<p><code>Dodge_Skill</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"管理的技能字段\"><a class=\"anchor\" href=\"#管理的技能字段\">#</a> 管理的技能字段</h3>\n<ul>\n<li>\n<p><code>dash</code> : 对应  <code>Dash_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>clone</code> : 对应  <code>Clone_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>sword</code> : 对应  <code>Sword_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>blackhole</code> : 对应  <code>Blackhole_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>crystal</code> : 对应  <code>Crystal_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>parry</code> : 对应  <code>Parry_Skill</code>  实例。</p>\n</li>\n<li>\n<p><code>dodge</code> : 对应  <code>Dodge_Skill</code>  实例。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"系统角色\"><a class=\"anchor\" href=\"#系统角色\">#</a> 系统角色</h3>\n<ul>\n<li>\n<p><code>SkillManager</code>  是所有技能相关操作的主要访问点。</p>\n</li>\n<li>\n<p>其他游戏组件通过该管理器与技能交互，确保操作集中化。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"各技能类\"><a class=\"anchor\" href=\"#各技能类\">#</a> 各技能类</h2>\n<h3 id=\"1-sword_skill\"><a class=\"anchor\" href=\"#1-sword_skill\">#</a> 1. Sword_Skill</h3>\n<p><code>Sword_Skill</code>  是  <code>Skill</code>  的派生类，专注于与剑相关的技能逻辑，包括多种剑类型及其相应的解锁和使用机制。</p>\n<h4 id=\"主要特点-3\"><a class=\"anchor\" href=\"#主要特点-3\">#</a> 主要特点</h4>\n<h5 id=\"1-剑的类型\"><a class=\"anchor\" href=\"#1-剑的类型\">#</a> 1. 剑的类型</h5>\n<ul>\n<li>\n<p>提供 4 种剑类型：</p>\n<ul>\n<li>\n<p>Regular（普通）</p>\n</li>\n<li>\n<p>Bounce（弹射）</p>\n</li>\n<li>\n<p>Pierce（穿刺）</p>\n</li>\n<li>\n<p>Spin（旋转）</p>\n</li>\n</ul>\n</li>\n<li>\n<p>不同类型剑有独特的属性，如重力、弹射次数、旋转持续时间等。</p>\n</li>\n</ul>\n<h5 id=\"类型定义\"><a class=\"anchor\" href=\"#类型定义\">#</a> 类型定义：</h5>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> SwordType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Regular,</span><br><span class=\"line\">    Bounce,</span><br><span class=\"line\">    Pierce,</span><br><span class=\"line\">    Spin</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"2-解锁机制\"><a class=\"anchor\" href=\"#2-解锁机制\">#</a> 2. 解锁机制</h4>\n<ul>\n<li>\n<p>每种剑类型通过解锁按钮控制。</p>\n</li>\n<li>\n<p>提供以下方法来解锁对应剑类型：</p>\n<ul>\n<li>\n<p><code>UnlockSword()</code></p>\n</li>\n<li>\n<p><code>UnlockBounceSword()</code></p>\n</li>\n<li>\n<p><code>UnlockPierceSword()</code></p>\n</li>\n<li>\n<p><code>UnlockSpinSword()</code></p>\n</li>\n<li>\n<p><code>UnlockTimeStop()</code> （时间停止被动技能）</p>\n</li>\n<li>\n<p><code>UnlockVulnurable()</code> （脆弱被动技能）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"解锁逻辑\"><a class=\"anchor\" href=\"#解锁逻辑\">#</a> 解锁逻辑：</h5>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">UnlockSword</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (swordUnlockButton.unlocked)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        swordType = SwordType.Regular;</span><br><span class=\"line\">        swordUnlocked = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"3-辅助瞄准\"><a class=\"anchor\" href=\"#3-辅助瞄准\">#</a> 3. 辅助瞄准</h4>\n<ul>\n<li>\n<p>提供瞄准点（Aim Dots）功能，显示剑的预计轨迹。</p>\n</li>\n<li>\n<p>瞄准点的位置由抛物线计算决定。</p>\n</li>\n</ul>\n<h5 id=\"实现方式-6\"><a class=\"anchor\" href=\"#实现方式-6\">#</a> 实现方式：</h5>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Vector2 <span class=\"title\">AimDirection</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector2 playerPosition = player.transform.position;</span><br><span class=\"line\">    Vector2 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);</span><br><span class=\"line\">    Vector2 direction = mousePosition - playerPosition;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> direction;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"4-创建剑\"><a class=\"anchor\" href=\"#4-创建剑\">#</a> 4. 创建剑</h4>\n<ul>\n<li>\n<p><code>CreateSword()</code>  方法用于生成剑，并根据当前剑类型配置剑的行为。</p>\n</li>\n<li>\n<p>每种剑类型调用对应的  <code>Setup</code>  方法配置独特行为。</p>\n</li>\n</ul>\n<h5 id=\"实现方式-7\"><a class=\"anchor\" href=\"#实现方式-7\">#</a> 实现方式：</h5>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">CreateSword</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新的剑实例，并将其位置设置为玩家的位置，方向与当前物体一致</span></span><br><span class=\"line\">        GameObject newSword = Instantiate(swordPrefab, player.transform.position, transform.rotation);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取新剑对象的 Sword_Skill_Controller 脚本</span></span><br><span class=\"line\">        Sword_Skill_Controller newSwordScript = newSword.GetComponent&lt;Sword_Skill_Controller&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 根据剑的类型设置对应的技能效果</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (swordType == SwordType.Bounce)</span><br><span class=\"line\">            newSwordScript.SetupBounce(<span class=\"literal\">true</span>, bounceAmount, bounceSpeed); <span class=\"comment\">// 设置反弹剑效果</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (swordType == SwordType.Pierce)</span><br><span class=\"line\">            newSwordScript.SetupPierce(pierceAmount); <span class=\"comment\">// 设置穿刺剑效果</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (swordType == SwordType.Spin)</span><br><span class=\"line\">            newSwordScript.SetupSpin(<span class=\"literal\">true</span>, maxTravelDistance, spinDuration, hitCooldown); <span class=\"comment\">// 设置旋转剑效果</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">// 设置通用剑属性，如方向、重力、玩家引用、冻结时间和返回速度</span></span><br><span class=\"line\">        newSwordScript.SetupSword(finalDir, swordGravity, player, freezeTimeDuration, returnSpeed);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将新创建的剑分配给玩家</span></span><br><span class=\"line\">        player.AssignNewSword(newSword);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 禁用某些点的显示（具体作用依赖于实现）</span></span><br><span class=\"line\">        DotsActive(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-其他功能\"><a class=\"anchor\" href=\"#5-其他功能\">#</a> 5. 其他功能</h4>\n<ul>\n<li>\n<p><strong>时间停止（Time Stop）和脆弱（Vulnerable）被动技能</strong>：</p>\n<ul>\n<li>解锁后会自动激活对应效果。</li>\n</ul>\n</li>\n<li>\n<p><strong>解锁状态检测</strong>：在  <code>CheckUnlock()</code>  方法中检查所有解锁按钮状态。</p>\n</li>\n</ul>\n<h4 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h4>\n<ul>\n<li>\n<p>提供与剑相关的技能逻辑和实现。</p>\n</li>\n<li>\n<p>支持多种剑类型和扩展功能，如辅助瞄准和被动技能。</p>\n</li>\n<li>\n<p>与  <code>Skill</code>  基类和  <code>SkillManager</code>  交互，共享技能系统的框架。</p>\n</li>\n</ul>\n<h3 id=\"2-blackhole_skillcs\"><a class=\"anchor\" href=\"#2-blackhole_skillcs\">#</a> 2. Blackhole_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现黑洞技能，生成黑洞并吸引敌人，同时支持黑洞的生长和收缩机制。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>黑洞的大小、持续时间、以及攻击次数可配置。</li>\n<li>可在特定状态下触发结束。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>调用  <code>SkillManager.instance</code>  来播放音效或控制黑洞状态。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-clone_skillcs\"><a class=\"anchor\" href=\"#3-clone_skillcs\">#</a> 3. Clone_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现召唤克隆体的技能，并支持多种克隆相关特性。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>支持攻击型克隆、侵略性克隆、多重克隆和水晶替代克隆。</li>\n<li>提供克隆生成的延迟机制。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li><code>Crystal_Skill</code>  可以替代克隆生成。</li>\n<li>与其他技能（如  <code>Dash_Skill</code>  和  <code>Dodge_Skill</code> ）的特性协同。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"4-crystal_skillcs\"><a class=\"anchor\" href=\"#4-crystal_skillcs\">#</a> 4. Crystal_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现水晶技能，水晶可以作为防御机制，也支持爆炸和移动特性。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>支持多层堆叠水晶的生成和使用。</li>\n<li>提供爆炸型和移动型水晶解锁机制。</li>\n<li>可与克隆技能互相替代。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>与  <code>Clone_Skill</code>  协作实现水晶和克隆的互相替代功能。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"5-dash_skillcs\"><a class=\"anchor\" href=\"#5-dash_skillcs\">#</a> 5. Dash_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现冲刺技能，支持冲刺时生成克隆体或抵达目标位置后生成克隆体。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>可解锁冲刺克隆和到达克隆两种特性。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>调用  <code>Clone_Skill</code>  来生成克隆。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"6-dodge_skillcs\"><a class=\"anchor\" href=\"#6-dodge_skillcs\">#</a> 6. Dodge_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现闪避技能，支持闪避镜像功能。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>提升闪避数值，并提供镜像闪避的解锁选项。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>使用  <code>Clone_Skill</code>  生成镜像。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"7-parry_skillcs\"><a class=\"anchor\" href=\"#7-parry_skillcs\">#</a> 7. Parry_Skill.cs</h3>\n<ul>\n<li><strong>功能</strong>：实现格挡技能，可恢复生命值或生成镜像。</li>\n<li><strong>特性</strong>：\n<ul>\n<li>支持恢复生命值的解锁选项。</li>\n<li>在成功格挡时触发镜像生成。</li>\n</ul>\n</li>\n<li><strong>技能关联</strong>：\n<ul>\n<li>通过  <code>Clone_Skill</code>  实现镜像生成。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"文件之间的联系\"><a class=\"anchor\" href=\"#文件之间的联系\">#</a> 文件之间的联系</h2>\n<ol>\n<li><strong>SkillManager.cs</strong> 负责管理所有技能类，是各技能的单一入口。</li>\n<li><strong>技能之间的交互</strong>：\n<ul>\n<li>多个技能通过  <code>SkillManager</code>  调用其他技能实例。例如：\n<ul>\n<li><code>Dash_Skill</code>  和  <code>Dodge_Skill</code>  会调用  <code>Clone_Skill</code> 。</li>\n<li><code>Sword_Skill</code>  和  <code>Crystal_Skill</code>  之间有能力互相替代。</li>\n</ul>\n</li>\n<li>大部分技能类使用基础类  <code>Skill.cs</code>  提供的通用逻辑。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>如需进一步补充或优化，请告诉我！</p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "从零开始的恶魔城开发"
            ]
        },
        {
            "id": "http://example.com/2025/01/03/game-engine/unity/unityBasics/%E5%B0%8F%E6%B1%BD%E8%BD%A6%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93(1)/",
            "url": "http://example.com/2025/01/03/game-engine/unity/unityBasics/%E5%B0%8F%E6%B1%BD%E8%BD%A6%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93(1)/",
            "title": "小汽车项目总结(1)",
            "date_published": "2025-01-03T07:15:07.057Z",
            "content_html": "<h2 id=\"一-生成世界随机地图模块\"><a class=\"anchor\" href=\"#一-生成世界随机地图模块\">#</a> 一、生成世界随机地图模块</h2>\n<h3 id=\"1-mathfperlinnoise源码推测\"><a class=\"anchor\" href=\"#1-mathfperlinnoise源码推测\">#</a> 1. Mathf.PerlinNoise 源码推测</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">float</span> <span class=\"title\">PerlinNoise</span>(<span class=\"params\"><span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> xi = Mathf.FloorToInt(x) &amp; <span class=\"number\">255</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> yi = Mathf.FloorToInt(y) &amp; <span class=\"number\">255</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">float</span> xf = x - Mathf.Floor(x);</span><br><span class=\"line\">    <span class=\"built_in\">float</span> yf = y - Mathf.Floor(y);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">float</span> u = Fade(xf);</span><br><span class=\"line\">    <span class=\"built_in\">float</span> v = Fade(yf);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> aa = Permutation[Permutation[xi] + yi];</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ab = Permutation[Permutation[xi] + yi + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ba = Permutation[Permutation[xi + <span class=\"number\">1</span>] + yi];</span><br><span class=\"line\">    <span class=\"built_in\">int</span> bb = Permutation[Permutation[xi + <span class=\"number\">1</span>] + yi + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">float</span> x1, x2, y1;</span><br><span class=\"line\">    x1 = Mathf.Lerp(Grad(aa, xf, yf), Grad(ba, xf - <span class=\"number\">1</span>, yf), u);</span><br><span class=\"line\">    x2 = Mathf.Lerp(Grad(ab, xf, yf - <span class=\"number\">1</span>), Grad(bb, xf - <span class=\"number\">1</span>, yf - <span class=\"number\">1</span>), u);</span><br><span class=\"line\">    y1 = Mathf.Lerp(x1, x2, v);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (y1 + <span class=\"number\">1</span>) * <span class=\"number\">0.5f</span>; <span class=\"comment\">// 将结果映射到 [0, 1]</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"built_in\">float</span> <span class=\"title\">Fade</span>(<span class=\"params\"><span class=\"built_in\">float</span> t</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * t * (t * (t * <span class=\"number\">6</span> - <span class=\"number\">15</span>) + <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"built_in\">float</span> <span class=\"title\">Grad</span>(<span class=\"params\"><span class=\"built_in\">int</span> hash, <span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> h = hash &amp; <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> u = h &lt; <span class=\"number\">2</span> ? x : y;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> v = h &lt; <span class=\"number\">2</span> ? y : x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((h &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span> ? u : -u) + ((h &amp; <span class=\"number\">2</span>) == <span class=\"number\">0</span> ? v : -v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个常见的伪随机排列表</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span>[] Permutation = &#123; ... &#125;; <span class=\"comment\">// 省略完整表</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2各个方法分析\"><a class=\"anchor\" href=\"#2各个方法分析\">#</a> 2. 各个方法分析</h3>\n<h4 id=\"21世界片段的生成与管理\"><a class=\"anchor\" href=\"#21世界片段的生成与管理\">#</a> 2.1 世界片段的生成与管理</h4>\n<ol>\n<li>创建世界片段（圆柱体<br>\n <figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GenerateWorldPiece</span>(<span class=\"params\"><span class=\"built_in\">int</span> i</span>)</span>&#123; </span><br><span class=\"line\">\t<span class=\"comment\">// 创建新的圆柱体，并将其存储在 pieces 数组中 </span></span><br><span class=\"line\">\tpieces[i] = CreateCylinder(); </span><br><span class=\"line\">\t<span class=\"comment\">// 根据索引设置片段的位置</span></span><br><span class=\"line\">\tpieces[i].transform.Translate(Vector3.forward * (dimensions.y * scale * Mathf.PI) * i); </span><br><span class=\"line\">\t<span class=\"comment\">// 更新片段，使其包含终点并能够移动 </span></span><br><span class=\"line\">\tUpdateSinglePiece(pieces[i]); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>创建圆柱形片段<br>\n<strong>模块： <code>CreateCylinder</code> </strong></li>\n</ol>\n<ul>\n<li><strong>功能</strong>：\n<ul>\n<li>创建一个圆柱形的世界片段，添加必要的组件（ <code>MeshFilter</code> 、 <code>MeshRenderer</code> 、 <code>MeshCollider</code> ）。</li>\n<li>为圆柱体生成网格形状并赋予材质。</li>\n</ul>\n</li>\n<li><strong>主要方法</strong>：<br>\n<figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> GameObject <span class=\"title\">CreateCylinder</span>()</span>&#123; </span><br><span class=\"line\">\t<span class=\"comment\">// 创建新的圆柱体并命名 </span></span><br><span class=\"line\">\tGameObject newCylinder = <span class=\"keyword\">new</span> GameObject(); </span><br><span class=\"line\">\tnewCylinder.name = <span class=\"string\">&quot;World piece&quot;</span>; </span><br><span class=\"line\">\t<span class=\"comment\">// 设置当前圆柱体为新创建的对象 </span></span><br><span class=\"line\">\tcurrentCylinder = newCylinder; </span><br><span class=\"line\">\t<span class=\"comment\">// 添加 MeshFilter 和 MeshRenderer 组件 </span></span><br><span class=\"line\">\tMeshFilter meshFilter = newCylinder.AddComponent&lt;MeshFilter&gt;(); </span><br><span class=\"line\">\tMeshRenderer meshRenderer = newCylinder.AddComponent&lt;MeshRenderer&gt;(); </span><br><span class=\"line\">\t<span class=\"comment\">// 为圆柱体设置材质 </span></span><br><span class=\"line\">\tmeshRenderer.material = meshMaterial; </span><br><span class=\"line\">\t<span class=\"comment\">// 生成网格并赋值 </span></span><br><span class=\"line\">\tmeshFilter.mesh = Generate(); </span><br><span class=\"line\">\t<span class=\"comment\">// 为圆柱体添加匹配网格的碰撞器 </span></span><br><span class=\"line\">\tnewCylinder.AddComponent&lt;MeshCollider&gt;(); </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newCylinder; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>为圆柱体生成实际网格并返回</li>\n</ol>\n<ul>\n<li><strong>功能</strong>：\n<ul>\n<li>为圆柱体生成实际的网格。</li>\n<li>定义顶点、UV 坐标、三角形索引，构建一个 3D 几何体。</li>\n<li>调用 <code>CreateShape</code>  完成网格顶点和形状的定义。</li>\n</ul>\n</li>\n<li><strong>主要方法</strong>：<br>\n<figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Mesh <span class=\"title\">Generate</span>()</span>&#123; </span><br><span class=\"line\">\t<span class=\"comment\">// 创建并命名新网格 </span></span><br><span class=\"line\">\tMesh mesh = <span class=\"keyword\">new</span> Mesh(); </span><br><span class=\"line\">\tmesh.name = <span class=\"string\">&quot;MESH&quot;</span>; </span><br><span class=\"line\">\t<span class=\"comment\">// 初始化顶点、UV和三角形数组 </span></span><br><span class=\"line\">\tVector3[] vertices = <span class=\"literal\">null</span>; </span><br><span class=\"line\">\tVector2[] uvs = <span class=\"literal\">null</span>; </span><br><span class=\"line\">\t<span class=\"built_in\">int</span>[] triangles = <span class=\"literal\">null</span>; </span><br><span class=\"line\">\t<span class=\"comment\">// 填充网格数据 </span></span><br><span class=\"line\">\tCreateShape(<span class=\"keyword\">ref</span> vertices, <span class=\"keyword\">ref</span> uvs, <span class=\"keyword\">ref</span> triangles); </span><br><span class=\"line\">\t<span class=\"comment\">// 为网格设置顶点、UV和三角形 </span></span><br><span class=\"line\">\tmesh.vertices = vertices; </span><br><span class=\"line\">\tmesh.uv = uvs; </span><br><span class=\"line\">\tmesh.triangles = triangles; </span><br><span class=\"line\">\t<span class=\"comment\">// 重新计算法线 </span></span><br><span class=\"line\">\tmesh.RecalculateNormals(); </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mesh; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li>计算顶点位置并基于柏林噪声修改高度<br>\n<strong>模块： <code>CreateShape</code> </strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>功能</strong>：</p>\n<ul>\n<li>计算圆柱体的每个顶点位置，并基于 Perlin 噪声修改高度。</li>\n<li>处理世界片段之间的平滑过渡，确保多个片段连接时没有明显的断裂。</li>\n<li>根据顶点生成网格的 UV 坐标和三角形。<br>\n<figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateShape</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Vector3[] vertices, <span class=\"keyword\">ref</span> Vector2[] uvs, <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span>[] triangles</span>)</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取当前片段在x轴和z轴的大小</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> xCount = (<span class=\"built_in\">int</span>)dimensions.x;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> zCount = (<span class=\"built_in\">int</span>)dimensions.y;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 初始化顶点数组和UV数组，根据片段的维度大小</span></span><br><span class=\"line\">    vertices = <span class=\"keyword\">new</span> Vector3[(xCount + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>)];</span><br><span class=\"line\">    uvs = <span class=\"keyword\">new</span> Vector2[(xCount + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>)];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">int</span> index = <span class=\"number\">0</span>; <span class=\"comment\">// 当前顶点索引</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取圆柱体的半径</span></span><br><span class=\"line\">    <span class=\"built_in\">float</span> radius = xCount * scale * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 嵌套循环遍历x轴和z轴上的所有顶点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> x = <span class=\"number\">0</span>; x &lt;= xCount; x++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> z = <span class=\"number\">0</span>; z &lt;= zCount; z++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算顶点在圆柱上的角度</span></span><br><span class=\"line\">            <span class=\"built_in\">float</span> angle = x * Mathf.PI * <span class=\"number\">2f</span> / xCount;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 使用角度的余弦和正弦值确定顶点位置</span></span><br><span class=\"line\">            vertices[index] = <span class=\"keyword\">new</span> Vector3(Mathf.Cos(angle) * radius, Mathf.Sin(angle) * radius, z * scale * Mathf.PI);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 更新UV坐标，用于纹理映射</span></span><br><span class=\"line\">            uvs[index] = <span class=\"keyword\">new</span> Vector2(x * scale, z * scale);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 根据Perlin噪声缩放和偏移值，计算用于噪声的x和z值</span></span><br><span class=\"line\">            <span class=\"built_in\">float</span> pX = (vertices[index].x * perlinScale) + offset;</span><br><span class=\"line\">            <span class=\"built_in\">float</span> pZ = (vertices[index].z * perlinScale) + offset;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 获取圆柱的中心位置，但保持z值不变，用于指向中心</span></span><br><span class=\"line\">            Vector3 center = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, vertices[index].z);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 根据Perlin噪声值和波浪高度，调整顶点向圆柱中心的移动</span></span><br><span class=\"line\">            vertices[index] += (center - vertices[index]).normalized * Mathf.PerlinNoise(pX, pZ) * waveHeight;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 以下部分处理片段之间的平滑过渡：</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 检查是否有起始点（beginPoints）并且当前顶点位于网格的起始部分（z越小越靠近片段开头）</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(z &lt; startTransitionLength &amp;&amp; beginPoints[<span class=\"number\">0</span>] != Vector3.zero)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 计算当前顶点的Perlin噪声占比，越靠近新片段，噪声占比越高</span></span><br><span class=\"line\">                <span class=\"built_in\">float</span> perlinPercentage = z * (<span class=\"number\">1f</span> / startTransitionLength);</span><br><span class=\"line\">                <span class=\"comment\">// 从起始点获取对应的顶点，但保持z值为当前顶点的z</span></span><br><span class=\"line\">                Vector3 beginPoint = <span class=\"keyword\">new</span> Vector3(beginPoints[x].x, beginPoints[x].y, vertices[index].z);</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 将起始点和当前顶点通过线性插值结合，实现片段之间的平滑过渡</span></span><br><span class=\"line\">                vertices[index] = (perlinPercentage * vertices[index]) + ((<span class=\"number\">1f</span> - perlinPercentage) * beginPoint);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(z == zCount)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前顶点是最后一行顶点，更新起始点（beginPoints），以便下一个片段平滑连接</span></span><br><span class=\"line\">                beginPoints[x] = vertices[index];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 随机在网格顶点位置生成物品（如障碍物或门）</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Random.Range(<span class=\"number\">0</span>, startObstacleChance) == <span class=\"number\">0</span> &amp;&amp; !(gate == <span class=\"literal\">null</span> &amp;&amp; obstacles.Length == <span class=\"number\">0</span>))</span><br><span class=\"line\">                CreateItem(vertices[index], x);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 增加当前顶点索引</span></span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 初始化三角形数组（每个小方块由2个三角形组成，每个三角形由3个顶点组成，所以每个方块有6个顶点）</span></span><br><span class=\"line\">    triangles = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[xCount * zCount * <span class=\"number\">6</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 用于构建方块的顶点索引基础</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span>[] boxBase = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">6</span>];</span><br><span class=\"line\">    <span class=\"built_in\">int</span> current = <span class=\"number\">0</span>; <span class=\"comment\">// 当前三角形数组的索引</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遍历x轴上的所有位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> x = <span class=\"number\">0</span>; x &lt; xCount; x++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个基础，用于填充当前x位置的一行方块</span></span><br><span class=\"line\">        boxBase = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[]&#123; </span><br><span class=\"line\">            x * (zCount + <span class=\"number\">1</span>), </span><br><span class=\"line\">            x * (zCount + <span class=\"number\">1</span>) + <span class=\"number\">1</span>,</span><br><span class=\"line\">            (x + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>),</span><br><span class=\"line\">            x * (zCount + <span class=\"number\">1</span>) + <span class=\"number\">1</span>,</span><br><span class=\"line\">            (x + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>) + <span class=\"number\">1</span>,</span><br><span class=\"line\">            (x + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>),</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 遍历z轴上的所有位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> z = <span class=\"number\">0</span>; z &lt; zCount; z++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 增加基础顶点索引，移动到下一个方块的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++)&#123;</span><br><span class=\"line\">                boxBase[i] = boxBase[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 为当前方块添加两个三角形的顶点索引</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">6</span>; j++)&#123;                    </span><br><span class=\"line\">                triangles[current + j] = boxBase[j] - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 增加当前三角形数组的索引</span></span><br><span class=\"line\">            current += <span class=\"number\">6</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"22-过渡-片段之间更新\"><a class=\"anchor\" href=\"#22-过渡-片段之间更新\">#</a> 2.2 过渡 片段之间更新</h4>\n<ol>\n<li>使连接更加丝滑<br>\n<strong>模块： <code>UpdateWorldPieces</code> </strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>功能</strong>：</p>\n<ul>\n<li>移除不再显示的旧片段。</li>\n<li>创建新的片段，衔接在当前场景的末端。</li>\n<li>保证两个片段的边界平滑连接。</li>\n<li>动态调整场景片段，形成 “无限滚动” 的效果。<br>\n<figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">IEnumerator <span class=\"title\">UpdateWorldPieces</span>()</span>&#123; </span><br><span class=\"line\">\t<span class=\"comment\">// 移除第一个片段（不再可见） </span></span><br><span class=\"line\">\tDestroy(pieces[<span class=\"number\">0</span>]); </span><br><span class=\"line\">\t<span class=\"comment\">// 将第二个片段赋值为第一个片段 </span></span><br><span class=\"line\">\tpieces[<span class=\"number\">0</span>] = pieces[<span class=\"number\">1</span>]; </span><br><span class=\"line\">\t<span class=\"comment\">// 创建新的第二个片段 </span></span><br><span class=\"line\">\tpieces[<span class=\"number\">1</span>] = CreateCylinder(); </span><br><span class=\"line\">\t<span class=\"comment\">// 设置新片段的位置和旋转，保证与前一个片段衔接 </span></span><br><span class=\"line\">\tpieces[<span class=\"number\">1</span>].transform.position = pieces[<span class=\"number\">0</span>].transform.position + Vector3.forward * (dimensions.y * scale * Mathf.PI); </span><br><span class=\"line\">\tpieces[<span class=\"number\">1</span>].transform.rotation = pieces[<span class=\"number\">0</span>].transform.rotation; </span><br><span class=\"line\">\t<span class=\"comment\">// 更新新生成的片段 </span></span><br><span class=\"line\">\tUpdateSinglePiece(pieces[<span class=\"number\">1</span>]); </span><br><span class=\"line\">\t<span class=\"comment\">// 等待一帧 </span></span><br><span class=\"line\">\t<span class=\"keyword\">yield</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"23-动态调整模块场景中的物品管理\"><a class=\"anchor\" href=\"#23-动态调整模块场景中的物品管理\">#</a> 2.3 动态调整模块：场景中的物品管理</h4>\n<ol>\n<li><strong>模块： <code>UpdateAllItems</code> </strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>功能</strong>：</p>\n<ul>\n<li>找到所有带有标签 <code>Item</code>  的物品（如障碍物和门）。</li>\n<li>判断物品是否接近玩家，若接近则显示物品。</li>\n<li>对底部的物品开启阴影投射，上部物品则关闭阴影，避免不必要的阴影绘制。<br>\n<figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UpdateAllItems</span>()</span>&#123; </span><br><span class=\"line\">\t<span class=\"comment\">// 查找所有带有 &quot;Item&quot; 标签的物体 </span></span><br><span class=\"line\">\tGameObject[] items = GameObject.FindGameObjectsWithTag(<span class=\"string\">&quot;Item&quot;</span>); </span><br><span class=\"line\">\t<span class=\"comment\">// 遍历所有物品 </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; items.Length; i++)&#123; </span><br><span class=\"line\">\t<span class=\"comment\">// 获取物品的所有 MeshRenderer 组件 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">foreach</span>(MeshRenderer renderer <span class=\"keyword\">in</span> items[i].GetComponentsInChildren&lt;MeshRenderer&gt;())&#123; </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 判断物品是否足够接近玩家 </span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">bool</span> show = items[i].transform.position.z &lt; showItemDistance; </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果需要显示物品，更新阴影投射模式 </span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 圆柱体世界中，仅底部的物体需要投射阴影 </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(show) renderer.shadowCastingMode = (items[i].transform.position.y &lt; shadowHeight) ? ShadowCastingMode.On : ShadowCastingMode.Off; </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 根据是否展示物品启用或禁用 </span></span><br><span class=\"line\">\t\t\tRenderer renderer.enabled = show; </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>模块： <code>CreateItem</code> </strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>功能</strong>：</p>\n<ul>\n<li>根据随机概率在片段上生成物品（障碍物或门）。</li>\n<li>将物品位置设置在网格的某些顶点处。</li>\n<li>确保物品的朝向正确，使其面向圆柱体中心。<br>\n<figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateItem</span>(<span class=\"params\">Vector3 vert, <span class=\"built_in\">int</span> x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取圆柱体的中心位置，但保持z值与顶点的z值一致</span></span><br><span class=\"line\">    Vector3 zCenter = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, vert.z);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查中心点与顶点之间是否有正确的角度</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果向量为零或顶点位于圆柱体的四分之一或四分之三处（特定位置），则不生成物品</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(zCenter - vert == Vector3.zero || x == (<span class=\"built_in\">int</span>)dimensions.x / <span class=\"number\">4</span> || x == (<span class=\"built_in\">int</span>)dimensions.x / <span class=\"number\">4</span> * <span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据随机概率生成新物品，有小概率生成门（gate），大概率生成障碍物</span></span><br><span class=\"line\">    GameObject newItem = Instantiate((Random.Range(<span class=\"number\">0</span>, gateChance) == <span class=\"number\">0</span>) ? gate : obstacles[Random.Range(<span class=\"number\">0</span>, obstacles.Length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将物品朝向圆柱体中心方向旋转</span></span><br><span class=\"line\">    newItem.transform.rotation = Quaternion.LookRotation(zCenter - vert, Vector3.up);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置物品的位置为当前顶点位置</span></span><br><span class=\"line\">    newItem.transform.position = vert;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将新生成的物品设置为当前圆柱体的子物体，以便随圆柱体一起移动和旋转</span></span><br><span class=\"line\">    newItem.transform.SetParent(currentCylinder.transform, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"24-场景控制模块片段的移动与过渡\"><a class=\"anchor\" href=\"#24-场景控制模块片段的移动与过渡\">#</a> 2.4 场景控制模块：片段的移动与过渡</h4>\n<ol>\n<li><strong>模块： <code>UpdateSinglePiece</code> </strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>功能</strong>：</p>\n<ul>\n<li>为片段添加移动功能，使其沿 <code>z</code>  轴向玩家方向移动。</li>\n<li>根据灯光的旋转速度设置片段的旋转速度。</li>\n<li>更新 Perlin 噪声的偏移量，确保每个片段的地形独特。</li>\n<li>动态调整障碍物的出现概率，增加游戏难度。<br>\n<figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UpdateSinglePiece</span>(<span class=\"params\">GameObject piece</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为新生成的片段添加基础移动脚本，使其向玩家方向移动</span></span><br><span class=\"line\">    BasicMovement movement = piece.AddComponent&lt;BasicMovement&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 设置移动速度为全局速度的负值（向玩家方向移动）</span></span><br><span class=\"line\">    movement.movespeed = -globalSpeed;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果灯光（Directional Light）有移动脚本，则设置片段的旋转速度与灯光的旋转速度一致</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lampMovement != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        movement.rotateSpeed = lampMovement.rotateSpeed;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 为当前片段创建一个终点对象，用于标记片段的末尾</span></span><br><span class=\"line\">    GameObject endPoint = <span class=\"keyword\">new</span> GameObject();</span><br><span class=\"line\">    <span class=\"comment\">// 设置终点的位置为片段当前位置加上z轴方向的偏移量</span></span><br><span class=\"line\">    endPoint.transform.position = piece.transform.position + Vector3.forward * (dimensions.y * scale * Mathf.PI);</span><br><span class=\"line\">    <span class=\"comment\">// 将终点设置为当前片段的子物体</span></span><br><span class=\"line\">    endPoint.transform.parent = piece.transform;</span><br><span class=\"line\">    <span class=\"comment\">// 为终点命名</span></span><br><span class=\"line\">    endPoint.name = <span class=\"string\">&quot;End Point&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 增加Perlin噪声的偏移量，确保每个片段的地形形状不同</span></span><br><span class=\"line\">    offset += randomness;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 减小障碍物生成的概率，随着时间推移增加障碍物的密度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(startObstacleChance &gt; <span class=\"number\">5</span>)</span><br><span class=\"line\">        startObstacleChance -= obstacleChanceAcceleration;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3一些理解\"><a class=\"anchor\" href=\"#3一些理解\">#</a> 3. 一些理解</h3>\n<p>实现方案：地图为两个圆柱体进行嵌套，使整个场景达成了一种伪无限的效果，并且由于柏林噪声的平滑随机性，使圆柱体中的地形会有一些波动。所以在一开始创建了顶点、uv 三角形的数组后通过计算角度将数值注入数组，并通过柏林噪声以及传入值 waveHeight 波动圆柱体表面的数组值以达成总体圆柱体但是细节有坡度的效果。</p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "unity基础"
            ]
        },
        {
            "id": "http://example.com/2024/12/16/computer/dataStructure/hello-world/",
            "url": "http://example.com/2024/12/16/computer/dataStructure/hello-world/",
            "title": "算法基础总结",
            "date_published": "2024-12-16T11:54:49.158Z",
            "content_html": "<h2 id=\"排序类题目\"><a class=\"anchor\" href=\"#排序类题目\">#</a> 排序类题目</h2>\n<ol>\n<li>可以用迭代和递归来做</li>\n</ol>\n",
            "tags": [
                "计算机科学",
                "数据结构"
            ]
        },
        {
            "id": "http://example.com/2024/11/10/game-engine/unity/unityBasics/%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F/",
            "url": "http://example.com/2024/11/10/game-engine/unity/unityBasics/%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F/",
            "title": "摄像机跟随",
            "date_published": "2024-11-10T00:38:50.999Z",
            "content_html": "<p>代码<br>\n <figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LateUpdate</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查是否有目标对象（camTarget）可供跟随</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (camTarget == <span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// 若 camTarget 为空，停止执行，以防止空引用错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取摄像机当前的水平旋转角度（绕Y轴）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">float</span> currentRotationAngle = transform.eulerAngles.y;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取目标对象的水平旋转角度（绕Y轴）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">float</span> wantedRotationAngle = camTarget.eulerAngles.y;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算目标对象的期望高度，即目标对象的Y坐标加上预设的高度偏移量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">float</span> wantedHeight = camTarget.position.y + height;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取摄像机当前的高度（Y坐标）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">float</span> currentHeight = transform.position.y;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 平滑过渡摄像机的当前旋转角度，使其逐渐接近目标旋转角度</span></span><br><span class=\"line\"></span><br><span class=\"line\">        currentRotationAngle = Mathf.LerpAngle(currentRotationAngle, wantedRotationAngle, rotationDamping * Time.deltaTime);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 平滑过渡摄像机的高度，使其逐渐接近目标高度</span></span><br><span class=\"line\"></span><br><span class=\"line\">        currentHeight = Mathf.Lerp(currentHeight, wantedHeight, heightDamping * Time.deltaTime);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建一个绕Y轴旋转currentRotationAngle度的旋转，表示摄像机当前的旋转方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Quaternion currentRotation = Quaternion.Euler(<span class=\"number\">0</span>, currentRotationAngle, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置摄像机的位置为目标对象的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        transform.position = camTarget.position;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在目标位置的基础上，沿当前旋转的后方方向（Vector3.forward的负方向）拉远一定距离</span></span><br><span class=\"line\"></span><br><span class=\"line\">        transform.position -= currentRotation * Vector3.forward * distance;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重置摄像机的高度，使其为计算得到的currentHeight</span></span><br><span class=\"line\"></span><br><span class=\"line\">        transform.position = <span class=\"keyword\">new</span> Vector3(transform.position.x, currentHeight, transform.position.z);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将摄像机朝向目标对象，使其始终面向目标</span></span><br><span class=\"line\"></span><br><span class=\"line\">        transform.LookAt(camTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br>\n 通常首选在  <code>LateUpdate</code>  而不是  <code>Update</code>  中使用此函数，因为  <code>LateUpdate</code>  在帧中的所有  <code>Update</code>  调用之后运行。以下是它对相机跟随功能产生影响的原因：</p>\n<ol>\n<li>\n<p><strong>确保摄像机位置一致</strong>： <code>LateUpdate</code>  确保在所有其他游戏对象（如目标）完成帧的移动或更新后，调整摄像机的位置和旋转。这一点很重要，因为如果在  <code>Update</code>  期间目标的位置或旋转发生变化，并且您也在  <code>Update</code>  中移动摄像机，则可能会出现轻微的滞后或抖动，因为摄像机可能并不总是与最新的目标位置同步。</p>\n</li>\n<li>\n<p><strong>消除抖动和滞后</strong>：通过使用  <code>LateUpdate</code> ，您可以确保在摄像机移动之前考虑目标位置或旋转的任何变化。这使得相机可以平滑、精确地跟随，而不会出现抖动或滞后一帧。</p>\n</li>\n<li>\n<p><strong>优化摄像机逻辑</strong>：在其他更新完成后移动摄像机有助于优化渲染管道。摄像机只需根据对象的最终位置定位自身，这可确保摄像机在帧结束时渲染的内容是准确和最新的。</p>\n</li>\n</ol>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "unity基础"
            ]
        },
        {
            "id": "http://example.com/2024/11/07/game-engine/unity/unityBasics/Mesh%E7%9A%84%E4%BD%BF%E7%94%A8%20%E6%B1%BD%E8%BD%A6%E5%9C%B0%E5%BD%A2%E5%88%9B%E5%BB%BA/",
            "url": "http://example.com/2024/11/07/game-engine/unity/unityBasics/Mesh%E7%9A%84%E4%BD%BF%E7%94%A8%20%E6%B1%BD%E8%BD%A6%E5%9C%B0%E5%BD%A2%E5%88%9B%E5%BB%BA/",
            "title": "Mesh的使用 汽车地形创建",
            "date_published": "2024-11-07T11:29:08.336Z",
            "content_html": "<h3 id=\"1-基本概念\"><a class=\"anchor\" href=\"#1-基本概念\">#</a> 1. 基本概念</h3>\n<ul>\n<li><strong>MeshFilter</strong>：负责存储 Mesh 数据。它将 Mesh（包含顶点、边、面等几何数据）赋予对象，使其具有形状。</li>\n<li><strong>MeshRenderer</strong>：负责渲染 Mesh。它使用材质（Material）对 Mesh 进行渲染，使其在场景中可见。</li>\n<li><strong>MeshCollider</strong>：一种碰撞器组件，允许物体根据 Mesh 形状进行碰撞检测。</li>\n</ul>\n<h3 id=\"2-mesh-的基本结构\"><a class=\"anchor\" href=\"#2-mesh-的基本结构\">#</a> 2. Mesh 的基本结构</h3>\n<p>Mesh 通常由以下元素组成：</p>\n<ul>\n<li><strong>顶点（Vertices）</strong>：Mesh 的基本组成单位，一个顶点就是一个 3D 空间中的点。Mesh 的形状通过连接这些顶点来定义。</li>\n<li><strong>三角形（Triangles）</strong>：由顶点组成的面，用于定义 Mesh 的表面。</li>\n<li><strong>法线（Normals）</strong>：用于定义每个顶点的方向，影响光照效果。</li>\n<li><strong>UV 坐标（UV Coordinates）</strong>：用于将纹理贴图应用到 Mesh 上，定义了每个顶点在纹理图上的位置。</li>\n</ul>\n<h3 id=\"3创建mesh\"><a class=\"anchor\" href=\"#3创建mesh\">#</a> 3. 创建 Mesh</h3>\n<h4 id=\"1-顶点-vertices\"><a class=\"anchor\" href=\"#1-顶点-vertices\">#</a> 1. 顶点 (Vertices)</h4>\n<p><strong>顶点</strong>是 3D 空间中的一个点，是构成 3D 模型的基本单元。一个 3D 模型的形状是由多个顶点和顶点之间的连接方式决定的。</p>\n<ul>\n<li><strong>表示方式</strong>：在 Unity 中，顶点通常用  <code>Vector3</code>  表示，包括  <code>x</code> 、 <code>y</code>  和  <code>z</code>  坐标。</li>\n<li><strong>用途</strong>：顶点的集合决定了物体的形状，通过连接顶点可以形成边和面。顶点位置的改变会直接影响模型的形状。</li>\n<li><strong>示例</strong>：一个简单的正方形平面可以由 4 个顶点定义，如  <code>[(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]</code> 。</li>\n</ul>\n<h4 id=\"2-三角形-triangles\"><a class=\"anchor\" href=\"#2-三角形-triangles\">#</a> 2. 三角形 (Triangles)</h4>\n<p><strong>三角形</strong>是由三个顶点构成的一个平面，是 3D 模型的基本面。所有复杂的 3D 模型都是由大量三角形组合而成的，因为三角形是最简单的平面，可以稳定地定义在 3D 空间中。</p>\n<ul>\n<li><strong>表示方式</strong>：在 Unity 中，三角形通过一个顶点索引数组来定义。例如， <code>[0, 1, 2]</code>  表示使用第 0、1、2 个顶点构成一个三角形。</li>\n<li><strong>用途</strong>：三角形是 Mesh 的渲染基础。Unity 会根据三角形数据来生成物体的表面，并在这些表面上应用纹理和光照。</li>\n<li><strong>示例</strong>：一个由 4 个顶点组成的正方形平面需要用 2 个三角形表示，如  <code>[(0, 1, 2), (0, 2, 3)]</code></li>\n</ul>\n<h4 id=\"3-法线-normals\"><a class=\"anchor\" href=\"#3-法线-normals\">#</a> 3. 法线 (Normals)</h4>\n<p><strong>法线</strong>是一个垂直于三角形或顶点表面的向量，用于定义表面朝向。它影响模型如何与光源交互，从而影响视觉效果，如阴影和高光。</p>\n<ul>\n<li><strong>表示方式</strong>：在 Unity 中，法线通常用  <code>Vector3</code>  表示，包括  <code>x</code> 、 <code>y</code>  和  <code>z</code>  坐标。</li>\n<li><strong>用途</strong>：法线决定了光照如何应用在模型表面。正确的法线可以让光照看起来更自然，模型更有立体感。</li>\n<li><strong>示例</strong>：如果一个平面在 X-Z 平面上，法线通常会指向 Y 轴正方向  <code>(0, 1, 0)</code> ，表示平面朝上。</li>\n</ul>\n<h4 id=\"4-uv-坐标-uv-coordinates\"><a class=\"anchor\" href=\"#4-uv-坐标-uv-coordinates\">#</a> 4. UV 坐标 (UV Coordinates)</h4>\n<p><strong>UV 坐标</strong>用于将 2D 纹理贴图映射到 3D 模型的表面。UV 坐标定义了模型表面上每个顶点在纹理图上的位置。</p>\n<ul>\n<li><strong>表示方式</strong>：UV 坐标通常用  <code>Vector2</code>  表示，包括  <code>U</code>  和  <code>V</code>  分量，范围为  <code>[0, 1]</code> 。\n<ul>\n<li><code>U</code>  表示纹理的水平坐标。</li>\n<li><code>V</code>  表示纹理的垂直坐标。</li>\n</ul>\n</li>\n<li><strong>用途</strong>：UV 坐标控制了纹理在模型表面的显示方式。通过调整 UV 坐标，可以改变纹理的平铺、缩放和对齐方式。</li>\n<li><strong>示例</strong>：一个简单的正方形平面的 UV 坐标可能是  <code>[(0, 0), (1, 0), (1, 1), (0, 1)]</code> ，表示将整个纹理贴图到平面上。</li>\n</ul>\n<h4 id=\"示例在-unity-中创建一个简单的-mesh\"><a class=\"anchor\" href=\"#示例在-unity-中创建一个简单的-mesh\">#</a> 示例：在 Unity 中创建一个简单的 Mesh</h4>\n<p>假设我们要创建一个 1x1 的正方形平面，以下是顶点、三角形、法线和 UV 的示例：</p>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mesh mesh = <span class=\"keyword\">new</span> Mesh();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义 4 个顶点，组成正方形的四个角</span></span><br><span class=\"line\">Vector3[] vertices = <span class=\"keyword\">new</span> Vector3[]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>),  <span class=\"comment\">// 顶点 0</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector3(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>),  <span class=\"comment\">// 顶点 1</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector3(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>),  <span class=\"comment\">// 顶点 2</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>)   <span class=\"comment\">// 顶点 3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义 2 个三角形，使 4 个顶点形成一个平面</span></span><br><span class=\"line\"><span class=\"built_in\">int</span>[] triangles = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>,  <span class=\"comment\">// 三角形 1</span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>   <span class=\"comment\">// 三角形 2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义每个顶点的法线，表示该平面朝向 Z 轴正方向</span></span><br><span class=\"line\">Vector3[] normals = <span class=\"keyword\">new</span> Vector3[]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>),  <span class=\"comment\">// 顶点 0 的法线</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>),  <span class=\"comment\">// 顶点 1 的法线</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>),  <span class=\"comment\">// 顶点 2 的法线</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>)   <span class=\"comment\">// 顶点 3 的法线</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义每个顶点的 UV 坐标，使纹理完全覆盖整个平面</span></span><br><span class=\"line\">Vector2[] uv = <span class=\"keyword\">new</span> Vector2[]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector2(<span class=\"number\">0</span>, <span class=\"number\">0</span>),  <span class=\"comment\">// 顶点 0 的 UV</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector2(<span class=\"number\">1</span>, <span class=\"number\">0</span>),  <span class=\"comment\">// 顶点 1 的 UV</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector2(<span class=\"number\">1</span>, <span class=\"number\">1</span>),  <span class=\"comment\">// 顶点 2 的 UV</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vector2(<span class=\"number\">0</span>, <span class=\"number\">1</span>)   <span class=\"comment\">// 顶点 3 的 UV</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 Mesh 的顶点、三角形、法线和 UV</span></span><br><span class=\"line\">mesh.vertices = vertices;</span><br><span class=\"line\">mesh.triangles = triangles;</span><br><span class=\"line\">mesh.normals = normals;</span><br><span class=\"line\">mesh.uv = uv;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-动态生成和修改-mesh\"><a class=\"anchor\" href=\"#4-动态生成和修改-mesh\">#</a> 4. 动态生成和修改 Mesh</h3>\n<p>在游戏过程中，可以动态修改 Mesh 数据。例如，改变顶点的位置可以让 Mesh 变形。以下是如何动态修改 Mesh 顶点位置的示例：</p>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class=\"line\">    Vector3[] vertices = mesh.vertices;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 修改每个顶点的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; vertices.Length; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vertices[i].y = Mathf.Sin(Time.time + i); <span class=\"comment\">// 根据时间生成动态效果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mesh.vertices = vertices;</span><br><span class=\"line\">    mesh.RecalculateNormals(); <span class=\"comment\">// 更新法线以影响光照</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5-mesh-的应用\"><a class=\"anchor\" href=\"#5-mesh-的应用\">#</a> 5. Mesh 的应用</h3>\n<ul>\n<li><strong>地形生成</strong>：可以通过 Perlin Noise 或其他算法生成地形。</li>\n<li><strong>角色建模和动画</strong>：Mesh 可以应用于角色建模，还可以通过骨骼动画（Skinned Mesh）进行变形。</li>\n<li><strong>破碎效果</strong>：通过分割 Mesh，可以实现物体破碎的视觉效果。</li>\n<li><strong>动态水面</strong>：修改 Mesh 顶点可以实现水面波动的效果。</li>\n</ul>\n<h3 id=\"6-注意事项\"><a class=\"anchor\" href=\"#6-注意事项\">#</a> 6. 注意事项</h3>\n<ul>\n<li><strong>性能</strong>：修改 Mesh 可能影响性能，尤其是复杂的 Mesh 或频繁更新的情况。</li>\n<li><strong>法线和 UV</strong>：需要正确设置法线和 UV，确保光照和纹理显示正常。</li>\n<li><strong>Recalculate</strong>：修改 Mesh 后需要调用  <code>RecalculateNormals</code>  和  <code>RecalculateBounds</code>  等方法来更新法线和边界框。</li>\n</ul>\n<h2 id=\"完整示例代码\"><a class=\"anchor\" href=\"#完整示例代码\">#</a> 完整示例代码</h2>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">WorldGenerator</span> : <span class=\"title\">MonoBehaviour</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Vector2 dimesions;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Material meshMaterial;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> perlinScale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> offset;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> scale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Start is called before the first frame update</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CreateCylinder();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Update is called once per frame</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">CreateCylinder</span>()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Mesh通过网格绘制的，MeshFiltrer 持有的Mesh的引用，MeshRenderer持有的材质的引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建 gameobject并且命名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        GameObject newCylinder = <span class=\"keyword\">new</span> GameObject();</span><br><span class=\"line\"></span><br><span class=\"line\">        newCylinder.name = <span class=\"string\">&quot;World piece&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//添加MeshFilter组件 和 MeshRenderer组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        MeshFilter meshFilter = newCylinder.AddComponent&lt;MeshFilter&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        MeshRenderer meshRenderer = newCylinder.AddComponent&lt;MeshRenderer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//添加材质 包含纹理，shader等</span></span><br><span class=\"line\"></span><br><span class=\"line\">        meshRenderer.material = meshMaterial;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个网格</span></span><br><span class=\"line\"></span><br><span class=\"line\">        meshFilter.mesh =Generate();</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建网格以后，添加碰撞，适配新的mesh</span></span><br><span class=\"line\"></span><br><span class=\"line\">        newCylinder.AddComponent&lt;MeshCollider&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Mesh <span class=\"title\">Generate</span>()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Mesh mesh = <span class=\"keyword\">new</span> Mesh();</span><br><span class=\"line\"></span><br><span class=\"line\">        mesh.name = <span class=\"string\">&quot;MESH&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//顶点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Vector3[] vertices = <span class=\"keyword\">new</span> Vector3[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//三角形</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] triangles = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//UV</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Vector2[] uv = <span class=\"keyword\">new</span> Vector2[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        CreateShape(<span class=\"keyword\">ref</span> vertices, <span class=\"keyword\">ref</span> uv, <span class=\"keyword\">ref</span> triangles);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//再去赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\">        mesh.vertices = vertices;</span><br><span class=\"line\"></span><br><span class=\"line\">        mesh.triangles = triangles;</span><br><span class=\"line\"></span><br><span class=\"line\">        mesh.uv = uv;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mesh;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateShape</span>(<span class=\"params\"><span class=\"keyword\">ref</span> Vector3[] vertices, <span class=\"keyword\">ref</span> Vector2[] uvs, <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span>[] triangles</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> xCount = (<span class=\"built_in\">int</span>)dimesions.x;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> zCount = (<span class=\"built_in\">int</span>)dimesions.y;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        vertices = <span class=\"keyword\">new</span> Vector3[(xCount + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">        uvs = <span class=\"keyword\">new</span> Vector2[(xCount + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">        triangles = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[xCount * zCount * <span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将半径设置为固定值，避免受到分段数和scale的影响</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">float</span> radius = <span class=\"number\">5.0f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> x = <span class=\"number\">0</span>; x &lt;= xCount; x++)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> z = <span class=\"number\">0</span>; z &lt;= zCount; z++)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">float</span> angle = x * Mathf.PI * <span class=\"number\">2f</span> / xCount;</span><br><span class=\"line\"></span><br><span class=\"line\">                vertices[index] = <span class=\"keyword\">new</span> Vector3(</span><br><span class=\"line\"></span><br><span class=\"line\">                    Mathf.Cos(angle) * radius,</span><br><span class=\"line\"></span><br><span class=\"line\">                    Mathf.Sin(angle) * radius,</span><br><span class=\"line\"></span><br><span class=\"line\">                    z * scale</span><br><span class=\"line\"></span><br><span class=\"line\">                );</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                uvs[index] = <span class=\"keyword\">new</span> Vector2(x * scale, z * scale);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">float</span> pX = (vertices[index].x * perlinScale) + offset;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">float</span> pY = (vertices[index].y * perlinScale) + offset;</span><br><span class=\"line\"></span><br><span class=\"line\">                Vector3 center = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, vertices[index].z);</span><br><span class=\"line\"></span><br><span class=\"line\">                vertices[index] += (center - vertices[index]).normalized * Mathf.PerlinNoise(pX, pY) * waveHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                index++;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> triIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> x = <span class=\"number\">0</span>; x &lt; xCount; x++)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> z = <span class=\"number\">0</span>; z &lt; zCount; z++)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">int</span> topLeft = x * (zCount + <span class=\"number\">1</span>) + z;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">int</span> bottomLeft = (x + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>) + z;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = topLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = topLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = bottomLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = topLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = bottomLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = bottomLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-顶点创建代码解析\"><a class=\"anchor\" href=\"#1-顶点创建代码解析\">#</a> 1. 顶点创建代码解析</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取横向（圆周）和纵向（高度）方向的分段数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> xCount = (<span class=\"built_in\">int</span>)dimesions.x;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> zCount = (<span class=\"built_in\">int</span>)dimesions.y;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化顶点和 UV 数组，数组大小基于网格的尺寸</span></span><br><span class=\"line\"></span><br><span class=\"line\">        vertices = <span class=\"keyword\">new</span> Vector3[(xCount + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">        uvs = <span class=\"keyword\">new</span> Vector2[(xCount + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>)];</span><br><span class=\"line\"></span><br><span class=\"line\">        triangles = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[xCount * zCount * <span class=\"number\">6</span>];  <span class=\"comment\">// 每个矩形需要两个三角形，每个三角形有 3 个顶点</span></span><br></pre></td></tr></table></figure></p>\n<p>为什么数组的下标初始化为 <code>(xCount + 1) * (zCount + 1)</code>  呢？<br>\n考虑一个简单的例子：一个 2×2 的网格。这个网格包含 4 个单元格（每个单元格可以被两个三角形定义）。但要定义这 4 个单元格的顶点，实际需要 9 个顶点。<br>\n<figure class=\"highlight mathematica\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">顶点布局 <span class=\"punctuation\">(</span><span class=\"variable\">xCount</span> <span class=\"operator\">=</span> <span class=\"number\">2</span><span class=\"operator\">,</span> <span class=\"variable\">zCount</span> <span class=\"operator\">=</span> <span class=\"number\">2</span><span class=\"punctuation\">)</span>：</span><br><span class=\"line\"><span class=\"built_in\">O</span><span class=\"operator\">---</span><span class=\"built_in\">O</span><span class=\"operator\">---</span><span class=\"built_in\">O</span></span><br><span class=\"line\"><span class=\"operator\">|</span>   <span class=\"operator\">|</span>   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"built_in\">O</span><span class=\"operator\">---</span><span class=\"built_in\">O</span><span class=\"operator\">---</span><span class=\"built_in\">O</span></span><br><span class=\"line\"><span class=\"operator\">|</span>   <span class=\"operator\">|</span>   <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"built_in\">O</span><span class=\"operator\">---</span><span class=\"built_in\">O</span><span class=\"operator\">---</span><span class=\"built_in\">O</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">O</span> 表示顶点，网格有 <span class=\"number\">4</span> 个单元格，但需要 <span class=\"number\">9</span> 个顶点</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"解释为什么需要额外的顶点\"><a class=\"anchor\" href=\"#解释为什么需要额外的顶点\">#</a> 解释为什么需要额外的顶点</h4>\n<ol>\n<li>\n<p><strong>边界共享</strong>：每个单元格的边界与相邻单元格共享顶点，因此在  <code>x</code>  和  <code>z</code>  方向上都需要比单元格数量多 1 个顶点来包围网格的边界。</p>\n</li>\n<li>\n<p><strong>顶点数量计算</strong>：这样，每一行有  <code>xCount + 1</code>  个顶点，每一列有  <code>zCount + 1</code>  个顶点。总顶点数为 (xCount+1)×(zCount+1)。</p>\n</li>\n</ol>\n<h3 id=\"2-顶点循环初始化\"><a class=\"anchor\" href=\"#2-顶点循环初始化\">#</a> 2. 顶点循环初始化</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> index = <span class=\"number\">0</span>; <span class=\"comment\">// 用于遍历顶点和 UV 数组的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">float</span> radius = <span class=\"number\">5.0f</span>; <span class=\"comment\">// 固定半径，避免受到分段数和 scale 的影响</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历 x 和 z 方向，为每个顶点计算位置和 UV</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> x = <span class=\"number\">0</span>; x &lt;= xCount; x++)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> z = <span class=\"number\">0</span>; z &lt;= zCount; z++)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 计算当前 x 的角度（沿圆周分布）</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">float</span> angle = x * Mathf.PI * <span class=\"number\">2f</span> / xCount;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 使用三角函数计算圆周上的 x 和 y 坐标，z 方向拉伸</span></span><br><span class=\"line\"></span><br><span class=\"line\">                vertices[index] = <span class=\"keyword\">new</span> Vector3(</span><br><span class=\"line\"></span><br><span class=\"line\">                    Mathf.Cos(angle) * radius,    <span class=\"comment\">// x 位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    Mathf.Sin(angle) * radius,    <span class=\"comment\">// y 位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    z * scale                     <span class=\"comment\">// z 位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                );</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 设置 UV 坐标，用于贴图映射</span></span><br><span class=\"line\"></span><br><span class=\"line\">                uvs[index] = <span class=\"keyword\">new</span> Vector2(x * scale, z * scale);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 应用 Perlin 噪声，为网格增加波动效果</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">float</span> pX = (vertices[index].x * perlinScale) + offset;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">float</span> pY = (vertices[index].y * perlinScale) + offset;</span><br><span class=\"line\"></span><br><span class=\"line\">                Vector3 center = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, vertices[index].z);</span><br><span class=\"line\"></span><br><span class=\"line\">                vertices[index] += (center - vertices[index]).normalized * Mathf.PerlinNoise(pX, pY) * waveHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                index++; <span class=\"comment\">// 移动到下一个顶点索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"圆柱体平面\"><a class=\"anchor\" href=\"#圆柱体平面\">#</a> 圆柱体平面</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算当前 x 的角度（沿圆周分布）</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">float</span> angle = x * Mathf.PI * <span class=\"number\">2f</span> / xCount;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 使用三角函数计算圆周上的 x 和 y 坐标，z 方向拉伸</span></span><br><span class=\"line\"></span><br><span class=\"line\">                vertices[index] = <span class=\"keyword\">new</span> Vector3(</span><br><span class=\"line\"></span><br><span class=\"line\">                    Mathf.Cos(angle) * radius,    <span class=\"comment\">// x 位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    Mathf.Sin(angle) * radius,    <span class=\"comment\">// y 位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    z * scale                     <span class=\"comment\">// z 位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                );</span><br></pre></td></tr></table></figure><br>\n 可以参考一个圆的横截面，radius 是半径，通过不同的 x/xCount 遍历不同的角度以达到不同的角度<br>\n同时我认为 xCount 的大小会影响圆面的平滑情况，因为遍历是以 1 为递增的，xCount 越大，两个圆顶点的距离就越小，圆就越平滑</p>\n<h4 id=\"柏林噪声\"><a class=\"anchor\" href=\"#柏林噪声\">#</a> 柏林噪声</h4>\n<h5 id=\"1-center-verticesindex\"><a class=\"anchor\" href=\"#1-center-verticesindex\">#</a> 1.  <code>(center - vertices[index])</code></h5>\n<ul>\n<li><code>center</code>  是一个三维向量，代表当前顶点在  <code>z</code>  轴方向上的中心点坐标  <code>Vector3(0, 0, vertices[index].z)</code> 。</li>\n<li><code>vertices[index]</code>  是当前顶点的坐标。</li>\n<li><code>(center - vertices[index])</code>  计算了从  <code>vertices[index]</code>  指向  <code>center</code>  的向量，即当前顶点指向中心的方向。</li>\n</ul>\n<p>这样，我们就可以让噪声影响顶点在朝向中心的方向上产生波动效果，使得顶点偏移不固定在某一方向，而是会朝向柱体中心产生偏移。</p>\n<h5 id=\"2-center-verticesindexnormalized\"><a class=\"anchor\" href=\"#2-center-verticesindexnormalized\">#</a> 2.  <code>(center - vertices[index]).normalized</code></h5>\n<ul>\n<li><code>.normalized</code>  将这个向量单位化，使其长度为 1，仅保留方向而去除大小。</li>\n<li>这样可以确保后续的偏移量是沿着<strong>顶点指向中心的方向</strong>发生的，而不会影响偏移量的大小。</li>\n</ul>\n<h5 id=\"3-mathfperlinnoisepx-py\"><a class=\"anchor\" href=\"#3-mathfperlinnoisepx-py\">#</a> 3.  <code>Mathf.PerlinNoise(pX, pY)</code></h5>\n<ul>\n<li><code>Mathf.PerlinNoise(pX, pY)</code>  使用 Perlin 噪声生成一个 0 到 1 之间的浮点数。</li>\n<li>其中  <code>pX</code>  和  <code>pY</code>  是顶点的  <code>x</code>  和  <code>y</code>  值经过缩放和偏移后的坐标，用于产生不同的噪声值。</li>\n<li>Perlin 噪声生成的数值是平滑连续的，使用它可以创建出平滑的波动效果，而不是完全随机的变化。</li>\n</ul>\n<h5 id=\"4-mathfperlinnoisepx-py-waveheight\"><a class=\"anchor\" href=\"#4-mathfperlinnoisepx-py-waveheight\">#</a> 4.  <code>Mathf.PerlinNoise(pX, pY) * waveHeight</code></h5>\n<ul>\n<li><code>waveHeight</code>  是一个常数，控制波动的幅度，决定噪声的强度或影响力。</li>\n<li><code>Mathf.PerlinNoise(pX, pY) * waveHeight</code>  表示噪声值的实际偏移距离。噪声值在 0 到  <code>waveHeight</code>  之间波动，控制了每个顶点的偏移幅度。</li>\n</ul>\n<h5 id=\"5-center-verticesindexnormalized-mathfperlinnoisepx-py-waveheight\"><a class=\"anchor\" href=\"#5-center-verticesindexnormalized-mathfperlinnoisepx-py-waveheight\">#</a> 5.  <code>(center - vertices[index]).normalized * Mathf.PerlinNoise(pX, pY) * waveHeight</code></h5>\n<ul>\n<li>将噪声值乘以  <code>(center - vertices[index]).normalized</code> ，将波动效果应用在顶点指向中心的方向上。</li>\n<li>因此， <code>Mathf.PerlinNoise(pX, pY) * waveHeight</code>  生成的随机偏移量沿着  <code>center</code>  指向当前顶点的方向，产生平滑的 “凹凸” 波动效果。</li>\n</ul>\n<h5 id=\"6-verticesindex\"><a class=\"anchor\" href=\"#6-verticesindex\">#</a> 6.  <code>vertices[index] += (...)</code></h5>\n<ul>\n<li><code>vertices[index] +=</code>  将最终的偏移量加到  <code>vertices[index]</code>  上，改变当前顶点的位置。</li>\n<li>这样每个顶点都会根据 Perlin 噪声的值产生偏移，效果上使得圆柱表面在朝向中心的方向上发生不规则的波动。</li>\n</ul>\n<h3 id=\"三角形的遍历创建\"><a class=\"anchor\" href=\"#三角形的遍历创建\">#</a> 三角形的遍历创建</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"built_in\">int</span> triIndex = <span class=\"number\">0</span>; <span class=\"comment\">// 三角形数组的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为每个网格单元创建两个三角形</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> x = <span class=\"number\">0</span>; x &lt; xCount; x++)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> z = <span class=\"number\">0</span>; z &lt; zCount; z++)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 计算当前单元格左上角和左下角顶点的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">int</span> topLeft = x * (zCount + <span class=\"number\">1</span>) + z;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">int</span> bottomLeft = (x + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>) + z;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 第一个三角形的顶点</span></span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = topLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = topLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = bottomLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 第二个三角形的顶点</span></span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = topLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = bottomLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = bottomLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"顶点问题\"><a class=\"anchor\" href=\"#顶点问题\">#</a> 顶点问题</h4>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                <span class=\"comment\">// 计算当前单元格左上角和左下角顶点的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">int</span> topLeft = x * (zCount + <span class=\"number\">1</span>) + z;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">int</span> bottomLeft = (x + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>) + z;</span><br></pre></td></tr></table></figure><br>\n 这里的  <code>topLeft</code>  和  <code>bottomLeft</code>  计算当前网格单元的左上角和左下角的顶点索引。</p>\n<h5 id=\"1-topleft-x-zcount-1-z\"><a class=\"anchor\" href=\"#1-topleft-x-zcount-1-z\">#</a> 1.  <code>topLeft = x * (zCount + 1) + z;</code></h5>\n<ul>\n<li><strong> <code>x * (zCount + 1)</code> </strong>：计算在  <code>x</code>  行的开始位置的顶点索引。\n<ul>\n<li>由于每行包含  <code>zCount + 1</code>  个顶点（多一个用于共享边界），所以每增加一行，顶点索引需要加上  <code>zCount + 1</code> 。</li>\n</ul>\n</li>\n<li><strong> <code>+ z</code> </strong>：在当前行的基础上，增加  <code>z</code>  偏移，用来定位该行的特定顶点位置。</li>\n</ul>\n<h5 id=\"2-bottomleft-x-1-zcount-1-z\"><a class=\"anchor\" href=\"#2-bottomleft-x-1-zcount-1-z\">#</a> 2.  <code>bottomLeft = (x + 1) * (zCount + 1) + z;</code></h5>\n<ul>\n<li><strong> <code>(x + 1) * (zCount + 1)</code> </strong>：定位到下一行的开始位置。\n<ul>\n<li>由于是  <code>x</code>  行的下一行（ <code>x + 1</code> ），所以这里要加上  <code>(x + 1) * (zCount + 1)</code> 。</li>\n</ul>\n</li>\n<li><strong> <code>+ z</code> </strong>：在下一行的基础上，通过  <code>z</code>  偏移找到下一行的特定顶点位置。</li>\n</ul>\n<h5 id=\"示例\"><a class=\"anchor\" href=\"#示例\">#</a> 示例</h5>\n<p>假设我们有一个  <code>2 x 2</code>  的网格（即  <code>xCount = 2</code> ， <code>zCount = 2</code> ），需要 3 x 3 个顶点：<br>\n<figure class=\"highlight lua\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">顶点布局：</span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"comment\">--- 1 --- 2</span></span><br><span class=\"line\">|     |     |</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"comment\">--- 4 --- 5</span></span><br><span class=\"line\">|     |     |</span><br><span class=\"line\"><span class=\"number\">6</span> <span class=\"comment\">--- 7 --- 8</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"计算顶点索引\"><a class=\"anchor\" href=\"#计算顶点索引\">#</a> 计算顶点索引</h5>\n<ul>\n<li>\n<p>对于第一个单元格（ <code>x = 0</code> ,  <code>z = 0</code> ）：</p>\n<ul>\n<li><code>topLeft = 0 * (2 + 1) + 0 = 0</code> ：顶点索引为  <code>0</code></li>\n<li><code>bottomLeft = (0 + 1) * (2 + 1) + 0 = 3</code> ：顶点索引为  <code>3</code></li>\n</ul>\n<p>这样我们可以确定第一个单元格的顶点  <code>0</code>  和  <code>3</code>  的索引位置。</p>\n</li>\n<li>\n<p>对于第二个单元格（ <code>x = 0</code> ,  <code>z = 1</code> ）：</p>\n<ul>\n<li><code>topLeft = 0 * (2 + 1) + 1 = 1</code> ：顶点索引为  <code>1</code></li>\n<li><code>bottomLeft = (0 + 1) * (2 + 1) + 1 = 4</code> ：顶点索引为  <code>4</code></li>\n</ul>\n<p>这样我们可以确定第二个单元格的顶点  <code>1</code>  和  <code>4</code>  的索引位置。</p>\n</li>\n</ul>\n<h3 id=\"遍历过程\"><a class=\"anchor\" href=\"#遍历过程\">#</a> 遍历过程</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> x = <span class=\"number\">0</span>; x &lt; xCount; x++)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> z = <span class=\"number\">0</span>; z &lt; zCount; z++)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 计算当前单元格左上角和左下角顶点的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">int</span> topLeft = x * (zCount + <span class=\"number\">1</span>) + z;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">int</span> bottomLeft = (x + <span class=\"number\">1</span>) * (zCount + <span class=\"number\">1</span>) + z;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 第一个三角形的顶点</span></span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = topLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = topLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = bottomLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 第二个三角形的顶点</span></span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = topLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = bottomLeft + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                triangles[triIndex++] = bottomLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里三角形的顶点值并不是具体的大小，而是对应的顶点下标。<br>\n而为什么需要六个点呢，因为两个三角形构成一个矩形，而矩形有四个点，两个三角形有六个点，需要通过两个三角形才能确定一个矩形，故需要六个点来创建。</p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "unity基础"
            ]
        },
        {
            "id": "http://example.com/2024/11/04/computer/database/lec12%20Query%20Processing%20and%20Evaluation/",
            "url": "http://example.com/2024/11/04/computer/database/lec12%20Query%20Processing%20and%20Evaluation/",
            "title": "lec_12 Query Processing and Evaluation",
            "date_published": "2024-11-04T02:02:43.305Z",
            "content_html": "<h2 id=\"查询处理的基本步骤\"><a class=\"anchor\" href=\"#查询处理的基本步骤\">#</a> 查询处理的基本步骤</h2>\n<h3 id=\"1-查询处理的主要问题\"><a class=\"anchor\" href=\"#1-查询处理的主要问题\">#</a> 1. <strong>查询处理的主要问题</strong></h3>\n<ul>\n<li><strong>查询处理</strong>包含以下三个关键问题：\n<ol>\n<li>如何将 SQL 查询转换为 DBMS 理解的形式（处理阶段）。</li>\n<li>如何找到执行查询的最佳策略（优化阶段）。</li>\n<li>执行查询的具体标准是什么（执行阶段）​。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-dbms的内部结构\"><a class=\"anchor\" href=\"#2-dbms的内部结构\">#</a> 2. <strong>DBMS 的内部结构</strong></h3>\n<ul>\n<li><strong>组件概览</strong>：包括前端应用接口、SQL 接口、查询处理和优化引擎、事务管理器、并发控制、文件和访问方法、缓冲管理器和磁盘空间管理器。</li>\n<li><strong>查询处理和优化引擎</strong>负责将 SQL 命令转换为可执行的查询计划，并通过优化选择最低成本的查询执行方式。</li>\n<li><strong>系统目录</strong>存储数据库的元数据，辅助查询优化和执行​。</li>\n</ul>\n<h3 id=\"3-查询处理的基本步骤\"><a class=\"anchor\" href=\"#3-查询处理的基本步骤\">#</a> 3. <strong>查询处理的基本步骤</strong></h3>\n<ul>\n<li><strong>步骤 1：解析与转换</strong>\n<ul>\n<li>检查 SQL 语法和语义，将 SQL 查询转换为关系代数表达式（逻辑查询计划）。</li>\n<li>例如，将视图替换为实际子查询。</li>\n</ul>\n</li>\n<li><strong>步骤 2：查询优化</strong>\n<ul>\n<li>通过启发式方法重组查询，最小化中间结果的大小。</li>\n<li>选择具有最低成本的查询计划，并根据成本估算选择最优的执行策略。</li>\n</ul>\n</li>\n<li><strong>步骤 3：查询执行</strong>\n<ul>\n<li>执行查询计划中的操作，例如在执行树中使用不同的操作算法​。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-查询处理示例\"><a class=\"anchor\" href=\"#4-查询处理示例\">#</a> 4. <strong>查询处理示例</strong></h3>\n<ul>\n<li>示例查询： <code>SELECT name FROM student NATURAL JOIN enrolled WHERE uosCode='COMP9120';</code></li>\n<li><strong>转换为关系代数表达式</strong>：按条件选择、投影、连接等步骤分解成关系代数操作。</li>\n<li><strong>查询执行计划</strong>：使用嵌套循环、索引扫描、表访问等方式执行查询​。</li>\n</ul>\n<h2 id=\"查询优化\"><a class=\"anchor\" href=\"#查询优化\">#</a> 查询优化</h2>\n<h3 id=\"逻辑查询计划基于启发式的优化\"><a class=\"anchor\" href=\"#逻辑查询计划基于启发式的优化\">#</a> 逻辑查询计划：基于启发式的优化</h3>\n<h4 id=\"1-等价代数表达式\"><a class=\"anchor\" href=\"#1-等价代数表达式\">#</a> 1. 等价代数表达式</h4>\n<ul>\n<li>提出了通过代数表达式将 SQL 查询转换为逻辑查询计划的概念，目标是确保等价转换的正确性和提高执行效率。</li>\n<li>强调了逻辑操作层面的转换规则，并举例展示了如何将初始查询表示为等价的代数表达式查询优化策略</li>\n<li><strong>启发式优化（Heuristic Optimization）</strong>：通过重新排列查询树中的操作顺序来减少中间结果大小。\n<ul>\n<li>例如，优先执行选择和投影操作，以尽量缩小参与连接的关系大小。</li>\n</ul>\n</li>\n<li><strong>代数转换规则</strong>：应用一系列代数规则进行等价转换，优化执行计划。例如：\n<ul>\n<li><strong>投影级联</strong>：通过级联操作消除多余的属性。</li>\n<li><strong>选择级联</strong>：将选择条件合并，以减少筛选操作次数 。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-选择分布律可以将选择条件在连接之前应用到各个关系上以减少连接的复杂度\"><a class=\"anchor\" href=\"#2-选择分布律可以将选择条件在连接之前应用到各个关系上以减少连接的复杂度\">#</a> 2. - <strong>选择分布律</strong>：可以将选择条件在连接之前应用到各个关系上，以减少连接的复杂度。</h4>\n<p><figure class=\"highlight sql\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> 示例：对于查询`<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> Deposit, Customer, Branch <span class=\"keyword\">WHERE</span> Customercity<span class=\"operator\">=</span><span class=\"string\">&#x27;Sydney&#x27;</span>`，可将条件`Customercity<span class=\"operator\">=</span><span class=\"string\">&#x27;Sydney&#x27;</span>`应用于`Customer`表，从而减少最终的连接操作 。</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>投影优化</strong>：尽可能不必要的属性，降低数据处理量。</li>\n<li>示例展示了在查询执行中尽量早地移除不需要的列，从而优化整体查询性能 。</li>\n</ul>\n<h3 id=\"4-查询优化规则总结\"><a class=\"anchor\" href=\"#4-查询优化规则总结\">#</a> 4. 查询优化规则总结</h3>\n<ul>\n<li>提出了五条 1. <strong>连接交换律</strong>：R1 ⋈ R2 = R2 ⋈ R1 2. <strong>连接结合律</strong>：((R1 ⋈ R2) ⋈ R3) = (R1 ⋈ (R2 ⋈ R3)) 3. <strong>投影级联</strong>：若属性集 <code>B1, ..., Bn</code>  是属性集 <code>A1, ..., An</code>  的子集，则 <code>ΠB1,...,Bn (ΠA1,...,An (R)) = ΠB1,...,Bn (R)</code>  4. <strong>选择级联</strong>：σΘ1 (σΘ2 (R)) = σΘ1∧Θ2 (R) 5. <strong>选择分布律</strong>：σθ(R1 ⋈ R2) = (σθ(R1)) ⋈ R2 。</li>\n</ul>\n<h3 id=\"5-投影和选择的进一步优化\"><a class=\"anchor\" href=\"#5-投影和选择的进一步优化\">#</a> 5. 投影和选择的进一步优化</h3>\n<ul>\n<li>投影优化策略可以通过剔除据量。</li>\n<li>选择操作的分布则可以减少参与连接的记录数量，有助于提高执行效率。</li>\n<li>这些优化策略的目标是减少查询的中间结果大小，从而优化 I/O 成本 。</li>\n</ul>\n<h2 id=\"物理查询计划成本估算优化\"><a class=\"anchor\" href=\"#物理查询计划成本估算优化\">#</a> 物理查询计划：成本估算优化</h2>\n<h4 id=\"1-物理查询计划-physical-query-plan\"><a class=\"anchor\" href=\"#1-物理查询计划-physical-query-plan\">#</a> 1. 物理查询计划 (Physical Query Plan)</h4>\n<ul>\n<li>物理查询计划将逻辑查询操作转化为实际的执行步骤，包含具体的算法选择。主要目标是通过优化 I/O 操作来找到最低成本的执行计划查询执行计划 (Query Execution Plan)</li>\n<li>查询执行计划是一种详细的评估策略，使用物理操作符来指定查询的实际执行方式。</li>\n<li>例如，给定自然连接的关系 R (A,B,C) 和 S (C,D)，可以通过<strong>索引扫描</strong>、<strong>表扫描</strong>和<strong>嵌套循环连接</strong>等方式实现查询操作 。</li>\n</ul>\n<h4 id=\"3-查询优化器会计算不同执行计划的成本主要通过io操作数来估算代价\"><a class=\"anchor\" href=\"#3-查询优化器会计算不同执行计划的成本主要通过io操作数来估算代价\">#</a> 3. - 查询优化器会计算不同执行计划的成本，主要通过<strong> I/O 操作数</strong>来估算代价。</h4>\n<ul>\n<li>影响成本的因素包括可用的访问方法（如索引、扫描）和数据的物理组织方式（如数据是否排序） 。</li>\n</ul>\n<h4 id=\"4-连接操作-joi-嵌套循环连接nested-loop-join适用于任意连接条件但在io方面代价较高-需要逐一扫描每一页来查找匹配项\"><a class=\"anchor\" href=\"#4-连接操作-joi-嵌套循环连接nested-loop-join适用于任意连接条件但在io方面代价较高-需要逐一扫描每一页来查找匹配项\">#</a> 4. 连接操作 (Joi - <strong>嵌套循环连接（Nested Loop Join）</strong>：适用于任意连接条件，但在 I/O 方面代价较高。需要逐一扫描每一页来查找匹配项。</h4>\n<ul>\n<li>（Nested Loop Join)<br>\n<img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2Fnested%E4%BE%8B%E5%AD%90.png\" alt><br>\n<img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2Fnested%20loop.png\" alt></li>\n<li><strong>块嵌套循环连接（Block-Nested Loop Join）</strong>：优化了嵌套循环连接，通过一次加载块中的多条记录来减少内层扫描次数 。</li>\n</ul>\n<ol>\n<li>工作原理</li>\n</ol>\n<p>块嵌套循环连接是对简单嵌套循环连接的优化。通过将外表的数据分块，可以减少内层扫描的次数，降低 I/O 成本。</p>\n<ul>\n<li>具体步骤：\n<ol>\n<li>将外表 RRR 分成多个块（block），每个块可以包含多个页面（page）。</li>\n<li>将一个块加载到内存中，然后遍历内表 SSS 的所有页面。</li>\n<li>对于内表 SSS 中的每条记录，检查是否有匹配的外表记录。</li>\n<li>若匹配，将结果加入到结果集中。</li>\n<li>重复以上步骤，直到外表的所有块都处理完毕。</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li>I/O 成本</li>\n</ol>\n<p>假设：</p>\n<ul>\n<li>外表 RRR 有 bRb_RbR​ 个页面。</li>\n<li>内表 SSS 有 bSb_SbS​ 个页面。</li>\n<li>内存可容纳 MMM 个页面。</li>\n</ul>\n<p>总的 I/O 成本为：</p>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2Fio%E5%85%AC%E5%BC%8F1.png\" alt></p>\n<p>其中：</p>\n<ul>\n<li><strong>bRb_RbR​</strong> 表示首次将外表 RRR 加载到内存的成本。</li>\n<li><strong>bRM−1\\frac{b_R}{M - 1}M−1bR​​</strong> 表示将外表 RRR 分成的块数，因为内存中一个块最多可以放 M−1M - 1M−1 个页面。</li>\n<li>每个块都需要扫描内表 SSS 一次，因此需要乘以 bSb_SbS​。</li>\n</ul>\n<ol start=\"3\">\n<li>优缺点</li>\n</ol>\n<ul>\n<li><strong>优点</strong>：\n<ul>\n<li>通过分块减少了内层扫描的次数，比简单嵌套循环连接效率更高。</li>\n<li>适合内存较大的情况，因为更多的内存可以容纳更大的块，从而减少内表的扫描次数。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：\n<ul>\n<li>如果内存较小，块的大小受限，效果不如预期。</li>\n<li>对于特别大的数据集，仍然可能需要大量的 I/O 操作。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>应用场景</li>\n</ol>\n<p>块嵌套循环连接适用于没有索引且内存相对充足的情况。特别是在数据量大而内表没有索引时，块嵌套循环连接是一个不错的选择。<br>\n<img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2Fblock%20nested.png\" alt></p>\n<ul>\n<li><strong>索引嵌套循环连接（Index-Neste）</strong>：利用内层表的索引来查找外层表的匹配记录。此方法的成本主要由外层表的页数和索引查找成本组成 。</li>\n</ul>\n<ol>\n<li>工作原理</li>\n</ol>\n<p>索引嵌套循环连接是利用内表的索引来优化嵌套循环连接。每次在外表中读取一条记录时，不需要扫描内表的所有记录，而是通过索引直接找到匹配记录。<br>\n2. 具体步骤：<br>\n1. 对于外表 RRR 中的每条记录 rrr，使用内表 SSS 上的索引查找与 rrr 匹配的记录。<br>\n2. 如果找到匹配的记录，将匹配的记录对加入结果集。<br>\n3. 重复此操作，直到外表 RRR 的所有记录都处理完毕。</p>\n<ol start=\"3\">\n<li>I/O 成本</li>\n</ol>\n<p>假设：</p>\n<ul>\n<li>外表 RRR 有 bRb_RbR​ 个页面，总记录数为 TRT_RTR​。</li>\n<li>内表 SSS 有索引，访问索引的成本为 CCC（通常表示为读取索引和数据页的 I/O 成本）。</li>\n</ul>\n<p>总的 I/O 成本为：</p>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2Fio%E5%85%AC%E5%BC%8F2.png\" alt></p>\n<p>其中：</p>\n<ul>\n<li><strong>bRb_RbR​</strong> 是读取外表的 I/O 成本。</li>\n<li><strong>TR×CT_R \\times CTR​×C</strong> 表示对每条外表记录，通过索引在内表中查找匹配记录的 I/O 成本。</li>\n</ul>\n<ol start=\"4\">\n<li>优缺点</li>\n</ol>\n<ul>\n<li><strong>优点</strong>：\n<ul>\n<li>当内表有索引时，索引嵌套循环连接能显著降低 I/O 成本，因为它不需要对内表进行全表扫描。</li>\n<li>适合等值连接（Equality Join），因为索引可以快速定位特定值。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：\n<ul>\n<li>需要内表上有合适的索引。如果内表没有索引，则索引嵌套循环连接的效率会很低。</li>\n<li>对于范围连接（如  <code>BETWEEN</code>  操作），性能优势不如等值连接明显，因为范围查询可能需要扫描多个索引条目。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>应用场景</li>\n</ol>\n<p>索引嵌套循环连接适用于以下情况：</p>\n<ul>\n<li>外表的记录数相对较少，而内表有适合的索引。</li>\n<li>需要进行等值连接的场景，如主键 - 外键连接。<br>\n<img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2Findex%20nested.png\" alt></li>\n</ul>\n<h3 id=\"5-外部排序算法\"><a class=\"anchor\" href=\"#5-外部排序算法\">#</a> 5. 外部排序算法</h3>\n<ul>\n<li><strong>外部合并排序（External）</strong>：用于对数据进行外部排序，适用于内存不足的情况。算法包括两个主要步骤：\n<ol>\n<li><strong>创建有序的分段（sorted runs）</strong>：将数据分块加载到内存，进行内部排序后写回磁盘。</li>\n<li><strong>合并有序分段</strong>：逐次合并多个有序分段，最终生成完整的有序数据 。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"外部合并排序的基本思想\"><a class=\"anchor\" href=\"#外部合并排序的基本思想\">#</a> 外部合并排序的基本思想</h4>\n<p>外部合并排序通过以下两个阶段来完成排序任务：</p>\n<ol>\n<li><strong>划分阶段（Partition Phase 或 Run Generation Phase）</strong>：将大文件分成多个可以放入内存的小块（称为 “有序分段”）。</li>\n<li><strong>合并阶段（Merge Phase）</strong>：将这些小块逐次合并，最终生成一个有序的大文件。</li>\n</ol>\n<h4 id=\"外部合并排序的具体步骤\"><a class=\"anchor\" href=\"#外部合并排序的具体步骤\">#</a> 外部合并排序的具体步骤</h4>\n<h5 id=\"1-划分阶段生成有序分段\"><a class=\"anchor\" href=\"#1-划分阶段生成有序分段\">#</a> 1. 划分阶段（生成有序分段）</h5>\n<ul>\n<li>将整个数据集分为若干小块，每块的大小不超过内存容量。</li>\n<li>将每一块数据加载到内存中，并在内存中完成排序（例如使用快速排序或堆排序等内部排序算法）。</li>\n<li>将排序后的数据块（有序分段）写回磁盘。</li>\n<li>最终，得到多个已经排序好的小文件（有序分段），每个分段的大小不超过内存容量。</li>\n</ul>\n<p><strong>示例</strong>：假设我们有 1000 万条记录，内存只能容纳 100 万条记录。</p>\n<ul>\n<li>将 1000 万条记录分为 10 个小分段，每个分段包含 100 万条记录。</li>\n<li>将每个分段加载到内存中进行排序，然后写回磁盘，生成 10 个有序的分段文件。</li>\n</ul>\n<h5 id=\"2-合并阶段逐层合并有序分段\"><a class=\"anchor\" href=\"#2-合并阶段逐层合并有序分段\">#</a> 2. 合并阶段（逐层合并有序分段）</h5>\n<ul>\n<li>将有序的分段逐层合并，直到最终生成一个完整的有序文件。</li>\n<li>合并时通常使用<strong>多路归并（k-way merge）</strong>，即每次合并多个有序分段（通常是根据内存容量决定 k 的值）。</li>\n<li>每次合并的结果生成一个新的有序文件，重复此过程，直到所有分段合并为一个最终的有序文件。</li>\n</ul>\n<p><strong>示例</strong>：</p>\n<ul>\n<li>继续以上的例子，10 个分段可以一次性加载 5 个到内存（假设内存可以同时容纳 5 个分段进行多路归并）。</li>\n<li>第一次合并，将 10 个分段两两合并成 5 个更大的有序分段。</li>\n<li>再次合并，直到最终得到一个完整的有序文件。</li>\n</ul>\n<h4 id=\"io-成本分析\"><a class=\"anchor\" href=\"#io-成本分析\">#</a> I/O 成本分析</h4>\n<p>外部合并排序的 I/O 成本主要来源于多次读取和写回分段的操作。总的 I/O 成本大致为：</p>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2F%E5%A4%96%E9%83%A8%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png\" alt></p>\n<p>其中：</p>\n<ul>\n<li>N 是数据总量的页面数。</li>\n<li>M 是内存能容纳的页面数。</li>\n<li>k 是内存中可容纳的分段数（即每次可以合并的分段数）。</li>\n</ul>\n<h4 id=\"外部合并排序的优点\"><a class=\"anchor\" href=\"#外部合并排序的优点\">#</a> 外部合并排序的优点</h4>\n<ul>\n<li><strong>高效处理超大数据集</strong>：外部合并排序可以对超过内存大小的数据进行排序，非常适合磁盘操作。</li>\n<li><strong>多路归并减少合并次数</strong>：每次合并尽可能多的分段，可以减少 I/O 操作次数，从而提高排序效率。</li>\n</ul>\n<h4 id=\"外部合并排序的缺点\"><a class=\"anchor\" href=\"#外部合并排序的缺点\">#</a> 外部合并排序的缺点</h4>\n<ul>\n<li><strong>高 I/O 开销</strong>：频繁的磁盘读写会带来较高的 I/O 成本，特别是在磁盘速度较慢的情况下。</li>\n<li><strong>需要足够的磁盘空间</strong>：在合并阶段，算法需要额外的磁盘空间存储中间结果文件。</li>\n</ul>\n<h4 id=\"应用场景\"><a class=\"anchor\" href=\"#应用场景\">#</a> 应用场景</h4>\n<p>外部合并排序广泛应用于需要处理大规模数据的场景，包括：</p>\n<ul>\n<li>数据库的排序操作（如  <code>ORDER BY</code>  子句）。</li>\n<li>大数据处理系统中的排序任务。</li>\n<li>操作系统在内存不足时进行的文件排序。</li>\n</ul>\n<h3 id=\"6-管道和物化-pipelining-and-materialization\"><a class=\"anchor\" href=\"#6-管道和物化-pipelining-and-materialization\">#</a> 6. 管道和物化 （Pipelining and Materialization）</h3>\n<p>aterialization）**：逐步计算每个操作并将结果存储在临时关系中。此方法适用于简单的查询计划，但会增加 I/O 成本。</p>\n<ul>\n<li><strong>管道（Pipelining）</strong>：直接将一个操作的输出作为下一个操作的输入，减少了临时存储的需求，适用于较为复杂的查询 。</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "数据库"
            ]
        },
        {
            "id": "http://example.com/2024/11/03/computer/database/lec11%20Storage%20and%20Indexing/",
            "url": "http://example.com/2024/11/03/computer/database/lec11%20Storage%20and%20Indexing/",
            "title": "lec_11 Storage and Indexing",
            "date_published": "2024-11-03T06:43:43.187Z",
            "content_html": "<h2 id=\"物理存储数据\"><a class=\"anchor\" href=\"#物理存储数据\">#</a> 物理存储数据</h2>\n<h3 id=\"1-存储设备对比\"><a class=\"anchor\" href=\"#1-存储设备对比\">#</a> 1. <strong>存储设备对比</strong></h3>\n<ul>\n<li>比较了硬盘（HDD）和内存（RAM）的特点：\n<ul>\n<li><strong>硬盘</strong>：容量大、价格低、永久存储，但访问速度较慢。</li>\n<li><strong>内存</strong>：速度快、支持随机访问，但存储成本高且数据易失​。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-数据块和缓冲管理\"><a class=\"anchor\" href=\"#2-数据块和缓冲管理\">#</a> 2. <strong>数据块和缓冲管理</strong></h3>\n<ul>\n<li>数据在硬盘上按 “块”（blocks）组织，每个块为固定大小（通常为 4KB 或 8KB），块是数据传输的基本单位。</li>\n<li><strong>缓冲管理器</strong>负责将数据块加载到内存，并在内存满时使用替换算法决定保留哪些数据块。常用的替换算法包括 **LRU（最近最少使用）<strong>和</strong> MRU（最近最多使用）**​。</li>\n</ul>\n<h4 id=\"21-数据块blocks\"><a class=\"anchor\" href=\"#21-数据块blocks\">#</a> 2.1 <strong>数据块（Blocks）</strong></h4>\n<ul>\n<li>数据库中的数据通常存储在磁盘上，并按 “块”（block）为单位进行管理。数据块是操作系统在磁盘和内存之间传输数据的基本单位。</li>\n<li><strong>块大小</strong>一般为 4KB 或 8KB，具体取决于操作系统和硬件配置。块的大小会影响 I/O 操作的效率：较大的块可以减少读取大文件时的 I/O 次数，但可能会增加小文件的空间浪费​。</li>\n<li><strong>块因素（Blocking Factor）</strong>：这是块大小与记录大小的比率，决定了一个数据块中可以容纳多少条记录。如果记录较大，可能需要多个块来存储一条记录，这种情况称为 “记录跨块”（record spanning）。跨块存储会增加 I/O 复杂度，通常需要避免​。</li>\n</ul>\n<h4 id=\"22-缓冲区buffer和缓冲管理器buffer-manager\"><a class=\"anchor\" href=\"#22-缓冲区buffer和缓冲管理器buffer-manager\">#</a> 2.2 <strong>缓冲区（Buffer）和缓冲管理器（Buffer Manager）</strong></h4>\n<ul>\n<li><strong>缓冲区</strong>是数据库系统在内存中保留的一块区域，用于暂存从磁盘加载的块。由于内存的访问速度比磁盘快得多，将数据块缓存在内存中可以显著提升查询速度。</li>\n<li><strong>缓冲管理器</strong>负责管理这些缓冲区块，主要任务包括：\n<ul>\n<li><strong>块的加载和释放</strong>：根据需求从磁盘加载块到内存缓冲区，释放不再使用的块。</li>\n<li><strong>块替换策略</strong>：当内存缓冲区已满且需要加载新块时，选择要被替换的块。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"23-块替换策略\"><a class=\"anchor\" href=\"#23-块替换策略\">#</a> 2.3 <strong>块替换策略</strong></h4>\n<ul>\n<li>数据库系统通常使用以下常见的替换算法来优化内存利用率：\n<ul>\n<li><strong>LRU（Least Recently Used，最近最少使用）</strong>：优先替换最久未使用的块，适用于访问数据呈局部性特征的情况。</li>\n<li><strong>MRU（Most Recently Used，最近最多使用）</strong>：优先替换最近使用的块，适用于某些需要频繁访问相同数据块的情况，如嵌套循环连接操作​。</li>\n</ul>\n</li>\n<li>这些替换策略帮助缓冲管理器在内存中保留最可能被再次访问的块，从而减少频繁的 I/O 操作，提高查询性能。</li>\n</ul>\n<h4 id=\"24-缓冲区示例\"><a class=\"anchor\" href=\"#24-缓冲区示例\">#</a> 2.4 <strong>缓冲区示例</strong></h4>\n<ul>\n<li>通过一个连接操作的示例说明了如何选择替换策略：\n<ul>\n<li>假设执行的是一个嵌套循环连接，内表的块可能需要频繁访问，因此在这种情况下使用 MRU 策略会更有效，因为最近访问的块很快会再次被访问。</li>\n<li>通过合理的缓冲区管理和替换策略，可以显著减少 I/O 操作次数，从而提高查询效率​。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"25-缓冲管理的重要性\"><a class=\"anchor\" href=\"#25-缓冲管理的重要性\">#</a> 2.5 <strong>缓冲管理的重要性</strong></h4>\n<ul>\n<li>由于数据库通常远大于内存容量，无法将所有数据同时存储在内存中，因此需要有效的缓冲管理。</li>\n<li>缓冲管理的目标是通过智能的块加载和替换策略，将最常用的数据保留在内存中，以最小化磁盘访问次数，从而优化数据库系统的整体性能。</li>\n</ul>\n<h3 id=\"3-存储示例和填充因子fill-factor\"><a class=\"anchor\" href=\"#3-存储示例和填充因子fill-factor\">#</a> 3. <strong>存储示例和填充因子（Fill Factor）</strong></h3>\n<ul>\n<li>举例说明了数据表中记录如何分布在数据块中。假设每条记录 200 字节，每页可容纳 19 条记录，因此需要 105,264 个数据页来存储共 2,000,000 条记录​。</li>\n<li>填充因子（Fill Factor）用于决定每个数据页中预留多少空间，以便在新数据插入时无需频繁分裂页面。</li>\n</ul>\n<h4 id=\"31-存储示例\"><a class=\"anchor\" href=\"#31-存储示例\">#</a> 3.1 <strong>存储示例</strong></h4>\n<ul>\n<li>数据库表以固定大小的页面（page）形式存储，每个页面通常为 4KB。页面用于存储表中的多条记录。</li>\n<li>示例假设：\n<ul>\n<li>表  <code>Relation</code>  包含 2,000,000 条记录，每条记录大小为 200 字节。</li>\n<li>每个页面大小为 4KB，其中 250 字节用于页面头部和记录指针数组，其余 3,846 字节用于实际数据存储​。</li>\n</ul>\n</li>\n<li><strong>每页存储的记录数</strong>：\n<ul>\n<li>每条记录为 200 字节，因此每页可以容纳的记录数为： 记录数 =⌊3846 字节 200 字节 / 记录⌋=19 条记录 \\text {记录数} = \\left\\lfloor \\frac {3846 \\text { 字节}}{200 \\text { 字节 / 记录}} \\right\\rfloor = 19 \\text { 条记录} 记录数 =⌊200 字节 / 记录 3846 字节​⌋=19 条记录</li>\n<li>因此，总共需要约 105,264 个页面来存储全部记录​。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"32-填充因子fill-factor\"><a class=\"anchor\" href=\"#32-填充因子fill-factor\">#</a> 3.2 <strong>填充因子（Fill Factor）</strong></h4>\n<ul>\n<li><strong>定义</strong>：填充因子决定了每个页面用于存储数据的空间百分比。设定较低的填充因子会在页面中预留一定的空闲空间，便于后续插入新数据。</li>\n<li><strong>作用</strong>：通过保留空闲空间，填充因子减少了页面分裂的频率，有助于提高索引的维护效率。通常数据库在创建索引或存储页面时可以设置填充因子的值，如 80% 或 75%。</li>\n<li><strong>计算示例</strong>：\n<ul>\n<li>若填充因子设置为 75%，则每页仅填充 3/4 的数据： 19 条记录 ×75%=14 条记录 / 页（取整后）19 \\text {条记录} \\times 75% = 14 \\text { 条记录 / 页（取整后）} 19 条记录 ×75%=14 条记录 / 页（取整后）</li>\n<li>在这种情况下，需要的页面数增加到 142,858 页，以满足较低填充因子下的存储需求，这也会带来额外的存储开销​。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"33-填充因子的影响\"><a class=\"anchor\" href=\"#33-填充因子的影响\">#</a> 3.3 <strong>填充因子的影响</strong></h4>\n<ul>\n<li><strong>性能优化</strong>：较低的填充因子提高了插入新数据的灵活性，减少了频繁页面分裂的开销，适合需要大量插入操作的场景。</li>\n<li><strong>空间开销</strong>：虽然较低的填充因子带来额外的存储开销，但它能显著减少页面分裂的次数，从而提高系统的整体性能。</li>\n<li>示例中，设置填充因子为 75% 带来了 47% 的额外存储开销。这种设计通常用于索引页面，以保证索引更新时的效率​。</li>\n</ul>\n<h3 id=\"4-典型文件组织方式\"><a class=\"anchor\" href=\"#4-典型文件组织方式\">#</a> 4 <strong>典型文件组织方式</strong></h3>\n<ul>\n<li><strong>堆文件（Heap Files）</strong>：无序存储，适用于全表扫描，插入和删除开销较小。</li>\n<li><strong>排序文件（Sorted Files）</strong>：按键值排序，适合二分查找，但插入和更新成本较高。</li>\n<li><strong>索引文件（Index Files）</strong>：利用索引（如 B + 树或哈希索引）来提升数据访问速度​。</li>\n</ul>\n<h4 id=\"41-无序文件heap-files\"><a class=\"anchor\" href=\"#41-无序文件heap-files\">#</a> 4.1 <strong>无序文件（Heap Files）</strong></h4>\n<ul>\n<li><strong>定义</strong>：无序文件将记录以随机顺序存储在可用空间中，不对数据进行任何排序。</li>\n<li><strong>特点</strong>：\n<ul>\n<li><strong>优点</strong>：插入和删除操作快速简单，因为无需重新排列数据。</li>\n<li><strong>缺点</strong>：在没有索引的情况下，查询需要扫描整个表（即线性扫描），查询效率较低。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>：适合需要频繁插入和删除数据的表，特别是需要全表扫描的场景，如日志记录和历史数据存储​。</li>\n</ul>\n<h4 id=\"42-排序文件sorted-files\"><a class=\"anchor\" href=\"#42-排序文件sorted-files\">#</a> 4.2 <strong>排序文件（Sorted Files）</strong></h4>\n<ul>\n<li><strong>定义</strong>：排序文件按特定的搜索键（search key）对记录进行排序存储。</li>\n<li><strong>特点</strong>：\n<ul>\n<li><strong>优点</strong>：对等值查询和范围查询非常高效，支持二分查找，从而减少了 I/O 操作。</li>\n<li><strong>缺点</strong>：插入和删除操作代价较高，因为插入新记录或删除记录后需要保持数据的排序。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>：适合数据更新较少、查询频繁的场景，例如数据仓库或查询量大的报表数据​。</li>\n</ul>\n<h4 id=\"43-索引文件index-files\"><a class=\"anchor\" href=\"#43-索引文件index-files\">#</a> 4.3 <strong>索引文件（Index Files）</strong></h4>\n<ul>\n<li><strong>定义</strong>：索引文件在特定字段上建立数据结构（如 B + 树或哈希表），用于加速数据检索。</li>\n<li><strong>特点</strong>：\n<ul>\n<li><strong>优点</strong>：索引能够显著提高查询效率，尤其适用于等值查询和范围查询（如 B + 树索引）。此外，索引通常存储在独立的页面中，并与数据页分开。</li>\n<li><strong>缺点</strong>：需要额外的存储空间来存放索引页；每次数据插入、删除或更新时，索引页也需要更新，带来额外的 I/O 开销。</li>\n</ul>\n</li>\n<li><strong>典型索引类型</strong>：\n<ul>\n<li><strong>哈希索引</strong>：适合等值查询，不支持范围查询。</li>\n<li><strong>B + 树索引</strong>：既支持等值查询，也支持范围查询，是关系型数据库中常用的索引结构​。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"44-文件组织方式的比较\"><a class=\"anchor\" href=\"#44-文件组织方式的比较\">#</a> 4.4 <strong>文件组织方式的比较</strong></h4>\n<ul>\n<li><strong>无序文件</strong>在插入和删除操作中速度较快，但查询效率较低。</li>\n<li><strong>排序文件</strong>在范围查询和等值查询上较高效，但插入和删除操作较慢。</li>\n<li><strong>索引文件</strong>通过额外的索引结构在查询上具有显著优势，但维护索引需要额外的 I/O 开销和存储空间。</li>\n</ul>\n<h4 id=\"45-适用性总结\"><a class=\"anchor\" href=\"#45-适用性总结\">#</a> 4.5 <strong>适用性总结</strong></h4>\n<ul>\n<li><strong>无序文件</strong>适合高频插入和删除且不要求快速查询的场景。</li>\n<li><strong>排序文件</strong>适合更新较少且需要高效范围查询的场景。</li>\n<li><strong>索引文件</strong>是最常用的方式，通过索引结构显著提升查询效率，尤其适合查询频繁的业务表​。</li>\n</ul>\n<h2 id=\"如何从-dbms-中检索记录\"><a class=\"anchor\" href=\"#如何从-dbms-中检索记录\">#</a> 如何从 DBMS 中检索记录</h2>\n<h3 id=\"1-访问路径access-paths\"><a class=\"anchor\" href=\"#1-访问路径access-paths\">#</a> 1. 访问路径（Access Paths）</h3>\n<ul>\n<li><strong>定义</strong>：访问路径是一种用于检索记录的方法，包括用于检索和存储表中记录的数据结构（如索引）和算法。</li>\n<li><strong>三种访问方法</strong>：\n<ul>\n<li><strong>线性扫描</strong>：适用于无序（Heap）文件，对所有记录逐一检查。</li>\n<li><strong>二分查找</strong>：适用于排序文件，I/O 成本较低，可快速找到目标记录。</li>\n<li><strong>索引扫描</strong>：使用索引可以直接定位记录，效率高​。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-物理数据独立性physical-data-independence\"><a class=\"anchor\" href=\"#2-物理数据独立性physical-data-independence\">#</a> 2. 物理数据独立性（Physical Data Independence）</h3>\n<ul>\n<li><strong>定义</strong>：选择访问路径的方式不会影响 SQL 语句的语义，但可能对执行时间有很大影响。</li>\n<li>物理数据独立性确保了查询语句与底层存储结构的独立性​。</li>\n</ul>\n<h3 id=\"3-无序文件的访问方法\"><a class=\"anchor\" href=\"#3-无序文件的访问方法\">#</a> 3. 无序文件的访问方法</h3>\n<ul>\n<li><strong>特点</strong>：无序文件的记录没有特定的顺序。</li>\n<li><strong>访问方法</strong>：通常通过线性扫描实现，每次检查一个页面中的所有记录。</li>\n<li><strong>性能</strong>：平均情况下需要读取一半页面，最坏情况下需要读取整个文件​。</li>\n</ul>\n<h3 id=\"4-线性扫描的io成本示例\"><a class=\"anchor\" href=\"#4-线性扫描的io成本示例\">#</a> 4. 线性扫描的 I/O 成本示例</h3>\n<ul>\n<li>假设表有 140,351 个页面，用于查询一个唯一的  <code>tuplekey</code> ：</li>\n</ul>\n<h4 id=\"等值查询equality-search\"><a class=\"anchor\" href=\"#等值查询equality-search\">#</a> 等值查询（Equality Search）</h4>\n<ul>\n<li>如果  <code>tuplekey</code>  是<strong>唯一的</strong>，一旦找到匹配记录可以立刻终止。</li>\n<li>平均情况下，需要检查约一半的页面，因为匹配记录可能位于任意位置。I/O 成本大约为： 140,3512≈70,176 次 I/O\\frac {140,351}{2} \\approx 70,176 \\text { 次 I/O} 2140,351​≈70,176 次 I/O</li>\n<li><strong>最坏情况</strong>：如果没有匹配记录或  <code>tuplekey</code>  不是唯一的，则需要扫描所有 140,351 个页面，即需要 140,351 次 I/O 操作。</li>\n</ul>\n<h4 id=\"范围查询range-search\"><a class=\"anchor\" href=\"#范围查询range-search\">#</a> 范围查询（Range Search）</h4>\n<ul>\n<li>例如，执行查询  <code>SELECT * FROM Relation WHERE attribute1 BETWEEN 100 AND 119;</code> 。</li>\n<li>对于范围查询，由于无序文件中记录是随机存放的，因此无法提前结束扫描，需要检查每个页面中的每条记录。</li>\n<li>这类查询通常会导致<strong>全表扫描</strong>，因此 I/O 成本为 140,351 次 I/O​。</li>\n</ul>\n<h3 id=\"5-排序文件的访问方法\"><a class=\"anchor\" href=\"#5-排序文件的访问方法\">#</a> 5. 排序文件的访问方法</h3>\n<ul>\n<li><strong>排序文件</strong>：记录按某属性排序存储，适合频繁的等值和范围查询。</li>\n<li><strong>二分查找</strong>：对于包含 140,351 个页面的表，最坏情况下 I/O 成本为 log⁡2140,351≈18\\log_2 140,351 \\approx 18log2​140,351≈18 次 I/O​。<br>\n&lt;二分查找图 -- 回家再上传&gt;</li>\n</ul>\n<h3 id=\"6-索引indexing\"><a class=\"anchor\" href=\"#6-索引indexing\">#</a> 6. 索引（Indexing）</h3>\n<ul>\n<li><strong>定义</strong>：索引是一种数据结构，用于将搜索键值映射到记录集合。</li>\n<li><strong>常见索引类型</strong>：\n<ul>\n<li><strong>哈希索引</strong>：适合等值查询，但不支持范围查询。</li>\n<li><strong>B + 树索引</strong>：支持等值和范围查询，适合关系型数据库。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：索引需要额外的存储空间，并在表数据更新时带来维护开销，但总体上索引带来的查询性能提升大于这些缺点​。</li>\n</ul>\n<h2 id=\"b树\"><a class=\"anchor\" href=\"#b树\">#</a> B + 树</h2>\n<h3 id=\"1-b树的定义\"><a class=\"anchor\" href=\"#1-b树的定义\">#</a> 1. B + 树的定义</h3>\n<ul>\n<li><strong>B + 树</strong>是一种自平衡的树形结构索引，用于在磁盘上组织和管理数据。</li>\n<li>与 B 树不同，B + 树将所有数据都存储在叶子节点中，而内部节点仅用于存储键值和指针，以引导查询过程。</li>\n<li><strong>叶子节点</strong>按键值顺序连接，形成一个链表，支持高效的范围查询。</li>\n</ul>\n<h3 id=\"2-b树的结构特点\"><a class=\"anchor\" href=\"#2-b树的结构特点\">#</a> 2. B + 树的结构特点</h3>\n<ul>\n<li><strong>内部节点（Internal Nodes）</strong>：存储搜索键和指针，用于引导搜索过程，但不存储实际数据。</li>\n<li><strong>叶子节点（Leaf Nodes）</strong>：存储所有数据条目，且按顺序链接，支持顺序访问。</li>\n<li><strong>树的高度</strong>：B + 树的所有叶子节点在同一层，路径长度一致，使得树是平衡的。因此，在 B + 树中查找任意记录所需的 I/O 次数相同。</li>\n</ul>\n<h3 id=\"3-b树的构建过程\"><a class=\"anchor\" href=\"#3-b树的构建过程\">#</a> 3. B + 树的构建过程</h3>\n<ul>\n<li><strong>索引条目</strong>：在每个记录页面生成一个索引条目，并将这些索引条目组织成 B + 树的内部结构。</li>\n<li><strong>层次结构</strong>：构建 B + 树的多层结构，从叶子层到根节点逐层递归构建。</li>\n<li><strong>填充因子（Fill Factor）</strong>：通常设置在 75% 左右，避免叶子节点过满，提高插入、删除的效率。</li>\n</ul>\n<h3 id=\"4-b树的查找过程\"><a class=\"anchor\" href=\"#4-b树的查找过程\">#</a> 4. B + 树的查找过程</h3>\n<ul>\n<li><strong>等值查询（Equality Search）</strong>：\n<ol>\n<li>从根节点开始，根据键值逐层向下查找，直到找到目标叶子节点。</li>\n<li>在叶子节点中查找目标记录。</li>\n</ol>\n</li>\n<li><strong>范围查询（Range Search）</strong>：\n<ol>\n<li>通过等值查询找到范围的起始位置。</li>\n<li>然后按顺序访问相邻的叶子节点，直到范围结束。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"5-b树的优点\"><a class=\"anchor\" href=\"#5-b树的优点\">#</a> 5. B + 树的优点</h3>\n<ul>\n<li><strong>高效的等值查询和范围查询</strong>：B + 树结构保证了所有叶子节点的有序性，支持快速定位范围的起始位置。</li>\n<li><strong>磁盘 I/O 效率高</strong>：B + 树通过多层结构减少了每次查询所需的 I/O 次数。在大数据集上，B + 树的层数较少，通常只需 3-4 次 I/O 即可找到目标记录。</li>\n<li><strong>支持动态更新</strong>：插入和删除操作可以在 B + 树中高效执行，且不会影响其平衡性。</li>\n</ul>\n<h3 id=\"6-b树的劣势\"><a class=\"anchor\" href=\"#6-b树的劣势\">#</a> 6. B + 树的劣势</h3>\n<ul>\n<li><strong>额外的存储开销</strong>：B + 树需要存储内部节点和叶子节点的指针，会占用额外的存储空间。</li>\n<li><strong>维护成本</strong>：每当数据插入、删除时，B + 树需要保持平衡和顺序，带来一定的维护开销。</li>\n</ul>\n<h3 id=\"7-b树在数据库中的应用\"><a class=\"anchor\" href=\"#7-b树在数据库中的应用\">#</a> 7. B + 树在数据库中的应用</h3>\n<ul>\n<li>B + 树常用于关系型数据库中的主键索引、唯一索引和范围索引。</li>\n<li>它在查询优化中发挥关键作用，特别是在大规模数据集的等值查询和范围查询中，可以显著减少 I/O 操作次数。</li>\n</ul>\n<h3 id=\"8-举例\"><a class=\"anchor\" href=\"#8-举例\">#</a> 8. 举例：</h3>\n<h4 id=\"1-构建逻辑有序数据文件\"><a class=\"anchor\" href=\"#1-构建逻辑有序数据文件\">#</a> 1. 构建逻辑有序数据文件</h4>\n<ul>\n<li>假设表  <code>Relation</code>  包含 140,351 个页面，每个页面中的记录按  <code>tuplekey</code>  逻辑排序。</li>\n<li>页面内的记录按键值排序，但页面在磁盘上的存储位置可能并不连续。这种组织方式称为<strong>逻辑有序文件</strong>​。</li>\n</ul>\n<h4 id=\"2-为每个记录页面创建索引条目\"><a class=\"anchor\" href=\"#2-为每个记录页面创建索引条目\">#</a> 2. 为每个记录页面创建索引条目</h4>\n<ul>\n<li>为数据文件中的每个页面创建一个索引条目，每个条目包含搜索键（ <code>tuplekey</code> ）和一个指向数据页面的指针  <code>rowid</code> 。</li>\n<li>每个索引条目占用 8 字节（4 字节的键和 4 字节的指针），可以在 4KB 页面中存储最多 480 个索引条目​。</li>\n</ul>\n<h4 id=\"3-将索引条目装入页面\"><a class=\"anchor\" href=\"#3-将索引条目装入页面\">#</a> 3. 将索引条目装入页面</h4>\n<ul>\n<li>假设页面的填充因子（即平均占用率）为 75%，则每个索引页面平均包含 360 个索引条目。</li>\n<li>这样，索引层次中将需要 140,351 / 360 ≈ 390 个索引页面​。</li>\n</ul>\n<h4 id=\"4-构建b树索引\"><a class=\"anchor\" href=\"#4-构建b树索引\">#</a> 4. 构建 B + 树索引</h4>\n<ul>\n<li>索引的下一层包含 390 个索引条目，即需要 2 个页面来存储这些条目。</li>\n<li>根层包含 2 个索引条目，因此只需 1 个页面。</li>\n<li>因此，B + 树索引的总页面数为 390 + 2 + 1 = 393 页，相对于数据表的大小仅增加了 0.2% 的存储​。</li>\n</ul>\n<h4 id=\"5-b树索引中的查找过程\"><a class=\"anchor\" href=\"#5-b树索引中的查找过程\">#</a> 5. B + 树索引中的查找过程</h4>\n<ul>\n<li>例如，执行查询  <code>SELECT * FROM Relation WHERE tuplekey=715;</code>  时，可以按以下步骤查找：\n<ol>\n<li>加载根页面到内存（1 次 I/O）。</li>\n<li>找到下一级索引页面的位置并加载（1 次 I/O）。</li>\n<li>重复直到找到叶子节点页面。</li>\n<li>加载包含目标记录的叶子页面，并检查每条记录。</li>\n</ol>\n</li>\n<li>总共约需 4 次 I/O，而无序文件中线性扫描的 I/O 成本可达 70,176 次​。</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "数据库"
            ]
        },
        {
            "id": "http://example.com/2024/11/03/computer/database/final%E5%A4%8D%E4%B9%A002/",
            "url": "http://example.com/2024/11/03/computer/database/final%E5%A4%8D%E4%B9%A002/",
            "title": "final复习02",
            "date_published": "2024-11-03T06:43:40.324Z",
            "content_html": "<h2 id=\"e-r图和r-m图\"><a class=\"anchor\" href=\"#e-r图和r-m图\">#</a> E-R 图和 R-M 图</h2>\n<h2 id=\"e-r图和r-m图-2\"><a class=\"anchor\" href=\"#e-r图和r-m图-2\">#</a> E-R 图和 R-M 图</h2>\n<h3 id=\"思维导图\"><a class=\"anchor\" href=\"#思维导图\">#</a> 思维导图</h3>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2F%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029224733.jpg\" alt></p>\n<h3 id=\"继承关系\"><a class=\"anchor\" href=\"#继承关系\">#</a> 继承关系</h3>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2F%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png\" alt></p>\n<h3 id=\"细节\"><a class=\"anchor\" href=\"#细节\">#</a> 细节</h3>\n<ol>\n<li>各种线段<br>\n粗实线：表示至少有一个<br>\n细实线：表示 0-n<br>\n 粗箭头：表示有且仅有一个</li>\n<li>E-R 图细节<br>\n如果有某个实体依赖于另一个实体，这个实体为弱实体，此实体主键需要画虚线。<br>\n如果某个属性为多值属性，此属性绘画时需要标注为弱属性，两个圈表示；如果某个属性为复合型属性，即包含 (address,postcode,etc..)，此属性绘画时需要画出包含的属性。</li>\n<li>E-R 图转 R-M 图<br>\n在 E-R 图中，如 N-1 的关系，N 的一方需要在 R-M 图中添加外键到 1 的一方的 PK。如果某个关系为 m-n，R-M 图中需要新建一个关系表来表示；如果为三元关系同理也需要，此时新表包含三个 &amp; 两个表的主键，同时也是外键。某个关系包含属性时，此关系也需要重新建表，且包含两个属性的主键。<br>\n多值属性在转 RM 时也需要重新建一张表，但是复合型属性需要删除，同时子属性不删除。</li>\n</ol>\n",
            "tags": [
                "计算机科学",
                "数据库"
            ]
        },
        {
            "id": "http://example.com/2024/10/31/game-engine/unity/unityProject01/unity%20%E5%8A%A8%E6%80%81%E8%A1%80%E6%9D%A1/",
            "url": "http://example.com/2024/10/31/game-engine/unity/unityProject01/unity%20%E5%8A%A8%E6%80%81%E8%A1%80%E6%9D%A1/",
            "title": "unity血条",
            "date_published": "2024-10-30T13:14:05.606Z",
            "content_html": "<h2 id=\"使用slider模拟血条效果\"><a class=\"anchor\" href=\"#使用slider模拟血条效果\">#</a> 使用 slider 模拟血条效果</h2>\n<h3 id=\"1ui中如何创建\"><a class=\"anchor\" href=\"#1ui中如何创建\">#</a> 1.UI 中如何创建</h3>\n<p>右键 UI 中直接创建 Slider<br>\n<img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/unity%2Funity2d%2FhandleSlide.png\" alt></p>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/unity/unity2d/slider_handleSlide.png\" alt><br>\n创建 Slider 后会自动生成这个滚动条，在血条中不需要，可以删除<br>\n<img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/unity/unity2d/slider.png\" alt><br>\n实际上控制填充条的多少就是由 Value 来控制的</p>\n<p>然后在 Background 的 Image 中放入边框 UI 图标，然后在 Fill Area 中的 Fill 的 Image 里放入填充 UI 图</p>\n<h3 id=\"2-脚本控制\"><a class=\"anchor\" href=\"#2-脚本控制\">#</a> 2. 脚本控制</h3>\n<p><figure class=\"highlight c#\"><figcaption><span>UI_HealthBar.cs</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine.UI;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 管理UI血条的类，用于显示实体的生命值和镜像翻转UI</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UI_HealthBar</span> : <span class=\"title\">MonoBehaviour</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 引用实体对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entity entity;</span><br><span class=\"line\">    <span class=\"comment\">// 引用角色属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CharacterStats myStats;</span><br><span class=\"line\">    <span class=\"comment\">// 血条的UI RectTransform</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RectTransform myTransform;</span><br><span class=\"line\">    <span class=\"comment\">// 血条的Slider组件</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Slider slider;</span><br><span class=\"line\">    <span class=\"comment\">// 目标生命值，用于实现平滑的血条过渡</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> targetHealth;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化方法，绑定事件并设置初始值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取血条的 RectTransform 组件</span></span><br><span class=\"line\">        myTransform = GetComponent&lt;RectTransform&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 获取父对象中的实体脚本</span></span><br><span class=\"line\">        entity = GetComponentInParent&lt;Entity&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 获取子对象中的 Slider 组件</span></span><br><span class=\"line\">        slider = GetComponentInChildren&lt;Slider&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 获取父对象中的角色属性脚本</span></span><br><span class=\"line\">        myStats = GetComponentInParent&lt;CharacterStats&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 绑定实体翻转事件，用于镜像翻转血条</span></span><br><span class=\"line\">        entity.onFlipped += FlipUI;</span><br><span class=\"line\">        <span class=\"comment\">// 绑定生命值变化事件，用于更新血条</span></span><br><span class=\"line\">        myStats.onHealthChanged += UpdateHealthUI;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化 Slider 的最大值为角色的最大生命值</span></span><br><span class=\"line\">        slider.maxValue = myStats.GetMaxHealthValue();</span><br><span class=\"line\">        <span class=\"comment\">// 初始化目标生命值为角色当前生命值</span></span><br><span class=\"line\">        targetHealth = myStats.currentHealth;</span><br><span class=\"line\">        <span class=\"comment\">// 设置 Slider 的初始值为目标生命值</span></span><br><span class=\"line\">        slider.<span class=\"keyword\">value</span> = targetHealth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每帧更新，用于平滑血条的过渡动画</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 Mathf.Lerp 实现血条值的平滑变化</span></span><br><span class=\"line\">        slider.<span class=\"keyword\">value</span> = Mathf.Lerp(slider.<span class=\"keyword\">value</span>, targetHealth, Time.deltaTime * <span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新血条的UI（响应生命值变化事件）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">UpdateHealthUI</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新 Slider 的最大值为角色的最大生命值</span></span><br><span class=\"line\">        slider.maxValue = myStats.GetMaxHealthValue();</span><br><span class=\"line\">        <span class=\"comment\">// 将目标生命值更新为角色当前生命值</span></span><br><span class=\"line\">        targetHealth = myStats.currentHealth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 翻转血条的UI（响应实体翻转事件）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">FlipUI</span>()</span> =&gt; myTransform.Rotate(<span class=\"number\">0</span>, <span class=\"number\">180</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当对象被禁用时，解绑事件以避免错误调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">OnDisable</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解绑实体翻转事件</span></span><br><span class=\"line\">        entity.onFlipped -= FlipUI;</span><br><span class=\"line\">        <span class=\"comment\">// 解绑生命值变化事件</span></span><br><span class=\"line\">        myStats.onHealthChanged -= UpdateHealthUI;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "从零开始的恶魔城开发"
            ]
        },
        {
            "id": "http://example.com/2024/10/30/game-engine/unity/unityProject01/unity-2d%20%E5%AE%9E%E7%8E%B0%E8%BD%AC%E5%90%91%E4%B8%8E%E8%B7%B3%E8%B7%83%E9%99%90%E5%88%B6/",
            "url": "http://example.com/2024/10/30/game-engine/unity/unityProject01/unity-2d%20%E5%AE%9E%E7%8E%B0%E8%BD%AC%E5%90%91%E4%B8%8E%E8%B7%B3%E8%B7%83%E9%99%90%E5%88%B6/",
            "title": "unity-2d 实现转向与跳跃限制",
            "date_published": "2024-10-30T12:32:19.000Z",
            "content_html": "<h2 id=\"unity-2d-转向\"><a class=\"anchor\" href=\"#unity-2d-转向\">#</a> unity-2d 转向</h2>\n<p>首先，unity-2d 其实也处于一个 3d 的世界当中，只不过所有的元素都是平面状的，所以，我们可以通过改变方向到 180 度来实现人物转向功能</p>\n<ol>\n<li>创建变量<br>\n <figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> facingDir = <span class=\"number\">1</span>;  <span class=\"comment\">// 面向方向（1为右，-1为左）</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> facingRight = <span class=\"literal\">true</span>;  <span class=\"comment\">// 是否朝右</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">float</span> xinput;  <span class=\"comment\">// 水平方向输入</span></span><br></pre></td></tr></table></figure></li>\n<li>然后，创建反转角色函数<br>\n <figure class=\"highlight c#\"><figcaption><span>ROW</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 角色翻转</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Flip</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    facingDir = <span class=\"number\">-1</span> * facingDir;  <span class=\"comment\">// 反转面向方向</span></span><br><span class=\"line\">    facingRight = !facingRight;  <span class=\"comment\">// 切换朝向</span></span><br><span class=\"line\">    transform.Rotate(<span class=\"number\">0</span>, <span class=\"number\">180</span>, <span class=\"number\">0</span>);  <span class=\"comment\">// 旋转角色，使其面向另一方向</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>控制翻转行为<br>\n <figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 控制翻转行为</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">FlipController</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rb.velocity.x &gt; <span class=\"number\">0</span> &amp;&amp; !facingRight)  <span class=\"comment\">// 如果角色向右移动且当前面朝左</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Flip();  <span class=\"comment\">// 执行翻转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rb.velocity.x &lt; <span class=\"number\">0</span> &amp;&amp; facingRight)  <span class=\"comment\">// 如果角色向左移动且当前面朝右</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Flip();  <span class=\"comment\">// 执行翻转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"unity-2d-限制跳跃次数\"><a class=\"anchor\" href=\"#unity-2d-限制跳跃次数\">#</a> unity-2d 限制跳跃次数</h2>\n<ol>\n<li>\n<p>创建新的变量与标头，使可读性更高<br>\n <figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">Header(<span class=\"string\">&quot;碰撞检测信息&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> groundCheckDistance;  <span class=\"comment\">// 地面检测距离</span></span><br><span class=\"line\">[<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> LayerMask whatIsGround;  <span class=\"comment\">// 表示地面的层级</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> isGrounded;  <span class=\"comment\">// 是否在地面上</span></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>碰撞检测<br>\n <figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 碰撞检测（检测是否在地面上）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">CollisionChecks</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    isGrounded = Physics2D.Raycast(transform.position, Vector2.down, groundCheckDistance, whatIsGround);  <span class=\"comment\">// 投射射线检测地面</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绘制Gizmos，用于显示射线</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">OnDrawGizmos</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Gizmos.DrawLine(transform.position, <span class=\"keyword\">new</span> Vector3(transform.position.x, transform.position.y - groundCheckDistance));  <span class=\"comment\">// 在编辑器中显示检测射线</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>限制 jump 行为<br>\n <figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Jump</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isGrounded)  <span class=\"comment\">// 检查是否在地面上</span></span><br><span class=\"line\">        rb.velocity = <span class=\"keyword\">new</span> Vector2(rb.velocity.x, jumpforce);  <span class=\"comment\">// 添加向上的跳跃力</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 在 c# 中，只有一行的 if 语句是可以直接写的</p>\n</li>\n<li>\n<p>Physics2D.Raycast 函数使用：<br>\n<figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RaycastHit2D hitInfo = Physics2D.Raycast(origin, direction, distance, layerMask);</span><br></pre></td></tr></table></figure></p>\n</li>\n</ol>\n<p>参数详解</p>\n<ol>\n<li><strong>origin (Vector2)</strong> - 射线的起点。\n<ul>\n<li>通常用物体的位置，比如  <code>transform.position</code> 。</li>\n</ul>\n</li>\n<li><strong>direction (Vector2)</strong> - 射线的方向。\n<ul>\n<li>这是一个二维向量，表示射线的投射方向。例如， <code>Vector2.down</code>  表示向下， <code>Vector2.right</code>  表示向右。</li>\n</ul>\n</li>\n<li><strong>distance (float)</strong> - 射线的最大检测距离（可选参数）。\n<ul>\n<li>这个参数设定了射线的长度。如果射线超过这个长度没有检测到任何碰撞物，就会返回一个空的  <code>RaycastHit2D</code> 。</li>\n</ul>\n</li>\n<li><strong>layerMask (int)</strong> - 层掩码 (LayerMask)（可选参数）。\n<ul>\n<li>用来指定射线可以检测的层（Layer）。如果只想检测特定的物体，比如地面或墙壁，可以用  <code>LayerMask</code>  来过滤掉其他不相关的物体。</li>\n<li>例如， <code>LayerMask.GetMask(&quot;Ground&quot;)</code>  可以创建一个只检测 &quot;Ground&quot; 层的掩码。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"代码总览\"><a class=\"anchor\" href=\"#代码总览\">#</a> 代码总览</h2>\n<p><figure class=\"highlight c#\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">player</span> : <span class=\"title\">MonoBehaviour</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Rigidbody2D rb;  <span class=\"comment\">// 2D刚体，用于物理控制</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> Animator animator;  <span class=\"comment\">// 动画控制器</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> moveSpeed;  <span class=\"comment\">// 移动速度</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> jumpforce;  <span class=\"comment\">// 跳跃力度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> facingDir = <span class=\"number\">1</span>;  <span class=\"comment\">// 面向方向（1为右，-1为左）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> facingRight = <span class=\"literal\">true</span>;  <span class=\"comment\">// 是否朝右</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> xinput;  <span class=\"comment\">// 水平方向输入</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;碰撞检测信息&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> groundCheckDistance;  <span class=\"comment\">// 地面检测距离</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> LayerMask whatIsGround;  <span class=\"comment\">// 表示地面的层级</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> isGrounded;  <span class=\"comment\">// 是否在地面上</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Start方法在游戏开始时调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();  <span class=\"comment\">// 获取2D刚体组件</span></span><br><span class=\"line\">        animator = GetComponentInChildren&lt;Animator&gt;();  <span class=\"comment\">// 获取子对象中的动画组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Update方法在每帧调用一次</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Movement();  <span class=\"comment\">// 控制角色移动</span></span><br><span class=\"line\">        CheckInput();  <span class=\"comment\">// 检查玩家输入</span></span><br><span class=\"line\">        CollisionChecks();  <span class=\"comment\">// 碰撞检测（是否在地面上）</span></span><br><span class=\"line\">        FlipController();  <span class=\"comment\">// 控制角色翻转</span></span><br><span class=\"line\">        AnimatorController();  <span class=\"comment\">// 控制动画</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查玩家输入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">CheckInput</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xinput = Input.GetAxisRaw(<span class=\"string\">&quot;Horizontal&quot;</span>);  <span class=\"comment\">// 获取水平输入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Input.GetKeyDown(KeyCode.Space))  <span class=\"comment\">// 检测空格键跳跃</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Jump();  <span class=\"comment\">// 执行跳跃</span></span><br><span class=\"line\">            Debug.Log(<span class=\"string\">&quot;jump&quot;</span>);  <span class=\"comment\">// 输出跳跃信息到控制台</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 控制角色移动</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Movement</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新角色的水平速度</span></span><br><span class=\"line\">        rb.velocity = <span class=\"keyword\">new</span> Vector2(xinput * moveSpeed, rb.velocity.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跳跃方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Jump</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isGrounded)  <span class=\"comment\">// 检查是否在地面上</span></span><br><span class=\"line\">            rb.velocity = <span class=\"keyword\">new</span> Vector2(rb.velocity.x, jumpforce);  <span class=\"comment\">// 添加向上的跳跃力</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 控制动画状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AnimatorController</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">bool</span> moving = rb.velocity.x != <span class=\"number\">0</span>;  <span class=\"comment\">// 判断角色是否在移动</span></span><br><span class=\"line\">        animator.SetBool(<span class=\"string\">&quot;moving&quot;</span>, moving);  <span class=\"comment\">// 设置动画的&quot;moving&quot;参数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 角色翻转</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Flip</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        facingDir = <span class=\"number\">-1</span> * facingDir;  <span class=\"comment\">// 反转面向方向</span></span><br><span class=\"line\">        facingRight = !facingRight;  <span class=\"comment\">// 切换朝向</span></span><br><span class=\"line\">        transform.Rotate(<span class=\"number\">0</span>, <span class=\"number\">180</span>, <span class=\"number\">0</span>);  <span class=\"comment\">// 旋转角色，使其面向另一方向</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 控制翻转行为</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">FlipController</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rb.velocity.x &gt; <span class=\"number\">0</span> &amp;&amp; !facingRight)  <span class=\"comment\">// 如果角色向右移动且当前面朝左</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Flip();  <span class=\"comment\">// 执行翻转</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rb.velocity.x &lt; <span class=\"number\">0</span> &amp;&amp; facingRight)  <span class=\"comment\">// 如果角色向左移动且当前面朝右</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Flip();  <span class=\"comment\">// 执行翻转</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 碰撞检测（检测是否在地面上）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">CollisionChecks</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isGrounded = Physics2D.Raycast(transform.position, Vector2.down, groundCheckDistance, whatIsGround);  <span class=\"comment\">// 投射射线检测地面</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绘制Gizmos，用于显示射线</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">OnDrawGizmos</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Gizmos.DrawLine(transform.position, <span class=\"keyword\">new</span> Vector3(transform.position.x, transform.position.y - groundCheckDistance));  <span class=\"comment\">// 在编辑器中显示检测射线</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "从零开始的恶魔城开发"
            ]
        },
        {
            "id": "http://example.com/2024/10/29/computer/database/final%E5%A4%8D%E4%B9%A001/",
            "url": "http://example.com/2024/10/29/computer/database/final%E5%A4%8D%E4%B9%A001/",
            "title": "final复习01",
            "date_published": "2024-10-28T23:43:19.078Z",
            "content_html": "<h2 id=\"e-r图和r-m图\"><a class=\"anchor\" href=\"#e-r图和r-m图\">#</a> E-R 图和 R-M 图</h2>\n<h2 id=\"e-r图和r-m图-2\"><a class=\"anchor\" href=\"#e-r图和r-m图-2\">#</a> E-R 图和 R-M 图</h2>\n<h3 id=\"思维导图\"><a class=\"anchor\" href=\"#思维导图\">#</a> 思维导图</h3>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2F%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029224733.jpg\" alt></p>\n<h3 id=\"继承关系\"><a class=\"anchor\" href=\"#继承关系\">#</a> 继承关系</h3>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/database%2F%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png\" alt></p>\n<h3 id=\"细节\"><a class=\"anchor\" href=\"#细节\">#</a> 细节</h3>\n<ol>\n<li>各种线段<br>\n粗实线：表示至少有一个<br>\n细实线：表示 0-n<br>\n 粗箭头：表示有且仅有一个</li>\n<li>E-R 图细节<br>\n如果有某个实体依赖于另一个实体，这个实体为弱实体，此实体主键需要画虚线。<br>\n如果某个属性为多值属性，此属性绘画时需要标注为弱属性，两个圈表示；如果某个属性为复合型属性，即包含 (address,postcode,etc..)，此属性绘画时需要画出包含的属性。</li>\n<li>E-R 图转 R-M 图<br>\n在 E-R 图中，如 N-1 的关系，N 的一方需要在 R-M 图中添加外键到 1 的一方的 PK。如果某个关系为 m-n，R-M 图中需要新建一个关系表来表示；如果为三元关系同理也需要，此时新表包含三个 &amp; 两个表的主键，同时也是外键。某个关系包含属性时，此关系也需要重新建表，且包含两个属性的主键。<br>\n多值属性在转 RM 时也需要重新建一张表，但是复合型属性需要删除，同时子属性不删除。</li>\n</ol>\n",
            "tags": [
                "计算机科学",
                "数据库"
            ]
        },
        {
            "id": "http://example.com/2024/10/28/computer/networks/network_lec_7%20Design%20ofNetworks%20and%20DistributedSystems/",
            "url": "http://example.com/2024/10/28/computer/networks/network_lec_7%20Design%20ofNetworks%20and%20DistributedSystems/",
            "title": "lecture_7 Design ofNetworks and DistributedSystems",
            "date_published": "2024-10-28T00:59:00.718Z",
            "content_html": "<h2 id=\"数据平面data-plane\"><a class=\"anchor\" href=\"#数据平面data-plane\">#</a> <span class=\"label danger\">数据平面（Data Plane）</span></h2>\n<h3 id=\"1-数据平面的功能\"><a class=\"anchor\" href=\"#1-数据平面的功能\">#</a> 1. <strong>数据平面的功能</strong>：</h3>\n<p>数据平面在每个路由器上本地执行，负责将进入路由器的分组从输入端口转发到正确的输出端口。核心任务是根据路由表决定每个数据包的转发路径​。</p>\n<h3 id=\"2-转发表forwarding-table\"><a class=\"anchor\" href=\"#2-转发表forwarding-table\">#</a> 2. <strong>转发表（Forwarding Table）</strong>：</h3>\n<pre><code>每个路由器的转发表决定了数据包的转发规则。数据平面根据数据包头中的字段值（如目的IP地址）匹配相应规则，并执行相应的操作，如转发到特定端口或丢弃​。\n</code></pre>\n<h3 id=\"3-openflow和流表\"><a class=\"anchor\" href=\"#3-openflow和流表\">#</a> 3. <strong>OpenFlow 和流表</strong>：</h3>\n<pre><code>在SDN架构中，数据平面使用OpenFlow等协议支持的流表（Flow Table），可以灵活定义转发规则。流表包含匹配字段、操作（例如转发、丢弃、修改）和计数器。控制器根据网络状态动态下发这些规则，以适应网络需求​.\n</code></pre>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2F%E8%BD%AC%E5%8F%91%E8%A1%A8.png\" alt><br>\n<img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2F%E8%BD%AC%E5%8F%91%E8%A1%A8%E7%A4%BA%E4%BE%8B.png\" alt><br>\n如上图我们可以看到</p>\n<ol>\n<li><strong>Destination-based forwarding（基于目标地址的转发）</strong></li>\n</ol>\n<ul>\n<li><strong>匹配条件</strong>：\n<ul>\n<li>目标 IP 地址为  <code>51.6.0.8</code> 。</li>\n<li>其他字段使用通配符  <code>*</code> ，表示任何值。</li>\n</ul>\n</li>\n<li><strong>操作</strong>：\n<ul>\n<li>动作是将符合条件的数据包转发到端口  <code>port6</code> 。</li>\n</ul>\n</li>\n<li><strong>解释</strong>：这个规则的作用是，当数据包的目标地址为  <code>51.6.0.8</code>  时，将该数据包转发到交换机的端口 6。这样可以确保发往该地址的数据包沿着预设路径传输，通常用于路由数据包到特定的目的地。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Firewall（防火墙规则）</strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>规则 1</strong>：</p>\n<ul>\n<li>匹配条件：TCP 的目标端口为  <code>22</code> （通常用于 SSH 连接）。</li>\n<li>其他字段使用通配符  <code>*</code> 。</li>\n<li><strong>操作</strong>：丢弃数据包（drop）。</li>\n<li><strong>解释</strong>：这个规则的目的是阻止所有目标端口为 22 的数据包，起到屏蔽 SSH 流量的作用。这种规则通常用于限制对特定服务的访问，以增强网络的安全性。</li>\n</ul>\n</li>\n<li>\n<p><strong>规则 2</strong>：</p>\n<ul>\n<li>匹配条件：源 IP 地址为  <code>128.119.1.1</code> 。</li>\n<li>其他字段使用通配符  <code>*</code> 。</li>\n<li><strong>操作</strong>：丢弃数据包（drop）。</li>\n<li><strong>解释</strong>：此规则阻止所有来自  <code>128.119.1.1</code>  主机的流量。可能用于封锁特定设备或网络源的访问，防止来自该源的恶意流量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-通用转发generalized-forwarding\"><a class=\"anchor\" href=\"#4-通用转发generalized-forwarding\">#</a> 4. <strong>通用转发（Generalized Forwarding）</strong>：</h3>\n<pre><code>通用转发允许更细粒度的规则定义，例如基于源/目的IP地址、端口号等字段来处理数据包。这一机制使得数据平面可以灵活地执行各种操作，不仅限于简单的IP转发​。\n</code></pre>\n<h2 id=\"控制平面control-plane\"><a class=\"anchor\" href=\"#控制平面control-plane\">#</a> <span class=\"label danger\">控制平面（Control Plane）</span></h2>\n<p>在 SDN（软件定义网络）中，** 控制平面（Control Plane）** 负责网络的逻辑控制和管理决策，是 SDN 架构的核心部分。它与数据平面（Data Plane）分离，使网络管理更加灵活和集中化。以下是控制平面的主要内容：</p>\n<h3 id=\"1-控制平面的功能\"><a class=\"anchor\" href=\"#1-控制平面的功能\">#</a> 1. <strong>控制平面的功能</strong></h3>\n<ul>\n<li><strong>路由决策</strong>：控制平面负责计算最佳路径，将路径信息下发给数据平面。例如，它决定不同数据包通过的路径，以达到最优的流量管理和资源利用。</li>\n<li><strong>策略管理</strong>：控制平面可以根据业务需求或策略规定数据包的处理方式。例如，它可以定义哪些数据包需要优先处理、哪些流量要进行限制。</li>\n<li><strong>集中控制</strong>：在 SDN 中，控制平面通常由一个集中控制器（如 OpenDaylight、ONOS 等）实现。这个集中控制器管理整个网络的规则和策略，为各个交换机和路由器提供统一的控制。</li>\n</ul>\n<h3 id=\"2-控制器与数据平面的交互\"><a class=\"anchor\" href=\"#2-控制器与数据平面的交互\">#</a> 2. <strong>控制器与数据平面的交互</strong></h3>\n<ul>\n<li><strong>OpenFlow 协议</strong>：控制平面通常通过 OpenFlow 协议与数据平面交换机和路由器通信。控制器通过下发流表规则，告知交换机如何处理不同的数据包。</li>\n<li><strong>流表规则的下发与更新</strong>：控制平面根据实时网络状态下发或更新流表规则，控制数据包的转发路径。例如，当检测到拥塞时，控制器可以重新配置流表，将流量分配到其他路径上。</li>\n</ul>\n<h3 id=\"3-网络拓扑的发现和监控\"><a class=\"anchor\" href=\"#3-网络拓扑的发现和监控\">#</a> 3. <strong>网络拓扑的发现和监控</strong></h3>\n<ul>\n<li><strong>拓扑发现</strong>：控制平面可以监控网络中设备的连接关系，自动生成和更新网络拓扑图。这使得控制器可以实时了解网络的结构，并在路径规划时考虑网络设备的物理位置和连接情况。</li>\n<li><strong>性能监控和故障检测</strong>：控制平面可以采集网络中各设备的状态信息（如流量负载、延迟），并根据监控数据检测故障。例如，如果某条路径出现故障，控制平面可以迅速重新规划路径，将流量重新路由到其他可用路径。</li>\n</ul>\n<h3 id=\"4-控制平面的优势\"><a class=\"anchor\" href=\"#4-控制平面的优势\">#</a> 4. <strong>控制平面的优势</strong></h3>\n<ul>\n<li><strong>集中化管理</strong>：控制平面将网络的控制逻辑集中在控制器上，使网络管理和策略应用变得更加统一和简便。</li>\n<li><strong>动态适应性</strong>：控制平面可以根据实时数据和业务需求，动态调整网络配置和流量分配。比如，它可以自动调整流量优先级，以确保关键应用的带宽需求。</li>\n<li><strong>易扩展性</strong>：通过控制平面，网络管理员可以灵活地添加新规则，满足不断变化的网络需求，适应大规模和复杂的网络环境。</li>\n</ul>\n<h3 id=\"5-典型应用场景\"><a class=\"anchor\" href=\"#5-典型应用场景\">#</a> 5. <strong>典型应用场景</strong></h3>\n<ul>\n<li><strong>流量工程</strong>：控制平面可以根据网络负载情况，动态调整数据包的转发路径，平衡流量负载，优化资源使用。</li>\n<li><strong>网络安全</strong>：控制器可以检测异常流量或攻击行为，快速应用安全策略（如阻断恶意流量或隔离受感染设备）。</li>\n<li><strong>服务质量（QoS）管理</strong>：控制平面可以确保高优先级业务（如视频会议）的带宽需求，同时限制低优先级业务，以提供更好的服务质量。</li>\n</ul>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2F%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%A4%BA%E4%BE%8B.png\" alt></p>\n<h3 id=\"示例解读\"><a class=\"anchor\" href=\"#示例解读\">#</a> 示例解读</h3>\n<ol>\n<li>\n<p><strong>链路故障检测</strong>：</p>\n<ul>\n<li>在图中， <code>S1</code>  交换机检测到与  <code>S2</code>  之间的链路发生故障（红色链接）。通过 OpenFlow 协议， <code>S1</code>  发送一个端口状态消息（port status message）给 SDN 控制器，通知链路状态的变化。</li>\n</ul>\n</li>\n<li>\n<p><strong>控制器接收故障消息</strong>：</p>\n<ul>\n<li>SDN 控制器收到来自  <code>S1</code>  的 OpenFlow 消息，并更新链路状态信息。控制器在内存中维护网络拓扑和链路状态，这样它可以根据最新的网络状态做出决策。</li>\n</ul>\n</li>\n<li>\n<p><strong>触发路由算法</strong>：</p>\n<ul>\n<li>在控制器中，Dijkstra’s link-state Routing（Dijkstra 链路状态路由算法）应用程序已经预先注册，以便在链路状态变化时被调用。当控制器更新链路状态后，自动调用该路由算法。</li>\n</ul>\n</li>\n<li>\n<p><strong>重新计算路由</strong>：</p>\n<ul>\n<li>Dijkstra 路由算法访问控制器中的网络图信息和链路状态信息，并计算新的路由。该算法会考虑网络中其他节点和链路的状态，以找到从源到目的地的最优路径。</li>\n</ul>\n</li>\n<li>\n<p><strong>更新流表</strong>：</p>\n<ul>\n<li>新的路由计算完成后，控制器会生成更新后的流表，并通过 OpenFlow 协议下发到各个相关交换机（如  <code>S1</code> 、 <code>S2</code> 、 <code>S3</code>  等）。这些交换机会根据新的流表规则调整数据包的转发路径。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据恢复</strong>：</p>\n<ul>\n<li>一旦流表更新完成，网络中的流量将按照新路径进行传输，确保数据流在故障恢复后的最短时间内继续传输，从而实现网络的动态修复和负载均衡。</li>\n</ul>\n</li>\n</ol>\n<p>关键要点</p>\n<ul>\n<li><strong>OpenFlow 协议</strong>：控制器和交换机之间的通信依赖 OpenFlow 协议。交换机将链路故障等事件上报给控制器，控制器下发新的流表规则。</li>\n<li><strong>链路状态路由</strong>：Dijkstra 算法是一种链路状态路由算法，可以快速计算最优路径。控制器利用该算法在网络故障时重新计算路径，确保网络的高效运行。</li>\n<li><strong>集中控制</strong>：在 SDN 架构中，控制器充当了网络的 “中枢神经”，统一管理和协调网络的各个设备，实现了传统网络难以实现的快速恢复和灵活路由。</li>\n</ul>\n<h2 id=\"transport-services传输服务\"><a class=\"anchor\" href=\"#transport-services传输服务\">#</a> <span class=\"label danger\">Transport Services（传输服务）</span></h2>\n<h3 id=\"1-传输层的主要功能\"><a class=\"anchor\" href=\"#1-传输层的主要功能\">#</a> 1. <strong>传输层的主要功能</strong></h3>\n<ul>\n<li><strong>进程到进程的通信</strong>：传输层提供应用进程之间的通信服务。不同于网络层提供的主机到主机的通信，传输层能够识别主机上具体的应用进程（如通过端口号），从而实现进程间的直接通信。</li>\n<li><strong>多路复用与多路分解</strong>：通过端口号，传输层可以支持多个应用程序在同一主机上同时使用网络通信。这使得来自不同应用的数据可以被正确地分解并发送给合适的进程。</li>\n</ul>\n<h3 id=\"2-传输层的核心服务\"><a class=\"anchor\" href=\"#2-传输层的核心服务\">#</a> 2. <strong>传输层的核心服务</strong></h3>\n<p>传输层提供了两种主要的服务类型：</p>\n<ul>\n<li>\n<p><strong>面向连接的服务（例如 TCP）</strong>：</p>\n<ul>\n<li><strong>可靠数据传输</strong>：TCP 通过确认（ACK）、重传（retransmission）等机制确保数据包在传输中不丢失、不重复、按顺序到达。</li>\n<li><strong>流量控制</strong>：TCP 实现流量控制，以防止发送方发送的数据过多，超出接收方的处理能力。</li>\n<li><strong>拥塞控制</strong>：TCP 还提供拥塞控制功能，监测网络拥塞状态，动态调整发送速率，以避免网络拥堵。</li>\n<li><strong>连接管理</strong>：在数据传输前，TCP 使用三次握手建立连接，并在传输完成后使用四次挥手释放连接，确保端到端的可靠连接。</li>\n</ul>\n</li>\n<li>\n<p><strong>无连接的服务（例如 UDP）</strong>：</p>\n<ul>\n<li><strong>尽最大努力交付</strong>：UDP 不保证数据包的可靠传输，不使用重传机制，数据可能丢失、重复或乱序到达。</li>\n<li><strong>低延迟</strong>：UDP 因为不保证可靠性和顺序性，传输过程简单，因此传输延迟较低，适合对实时性要求较高的应用，如视频流和在线游戏。</li>\n<li><strong>无连接传输</strong>：UDP 不建立连接，数据包可直接发送给目标，减少了连接建立的开销。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-传输服务的典型应用场景\"><a class=\"anchor\" href=\"#3-传输服务的典型应用场景\">#</a> 3. <strong>传输服务的典型应用场景</strong></h3>\n<ul>\n<li><strong>TCP 的应用场景</strong>：适用于对数据完整性和可靠性有较高要求的应用，如网页浏览（HTTP）、电子邮件（SMTP）、文件传输（FTP）等。</li>\n<li><strong>UDP 的应用场景</strong>：适用于实时性更高的应用，如视频会议、在线游戏、DNS 查询等。</li>\n</ul>\n<h3 id=\"4-qos服务质量支持\"><a class=\"anchor\" href=\"#4-qos服务质量支持\">#</a> 4. <strong>QoS（服务质量）支持</strong></h3>\n<ul>\n<li>传输服务还可以在一定程度上支持 QoS 需求，例如，通过设置不同的优先级或带宽控制来满足不同应用的传输要求。</li>\n<li>对于实时应用，UDP 通常优于 TCP，因为它减少了传输开销和延迟，但无法提供可靠性保障。TCP 则通过其可靠性和流量控制特性，适合需要数据完整性的应用。</li>\n</ul>\n<h2 id=\"udp\"><a class=\"anchor\" href=\"#udp\">#</a> <span class=\"label danger\">UDP</span></h2>\n<h3 id=\"1-udp的主要特性\"><a class=\"anchor\" href=\"#1-udp的主要特性\">#</a> 1. <strong>UDP 的主要特性</strong></h3>\n<ul>\n<li><strong>无连接</strong>：UDP 是无连接的传输协议，发送数据前无需建立连接，接收方也无需确认。发送方可以直接将数据报发送到目标端口。</li>\n<li><strong>不可靠传输</strong>：UDP 不保证数据报的可靠性，即数据可能丢失、重复、或乱序到达。</li>\n<li><strong>无重传机制</strong>：UDP 不实现重传机制，丢失的数据不会再次发送，这减少了延迟和开销。</li>\n<li><strong>简单的头部结构</strong>：UDP 的数据包头部很简单，仅包含源端口、目的端口、数据长度和校验和等少量信息，使得它的开销小、处理快。</li>\n</ul>\n<h3 id=\"2-udp头部结构\"><a class=\"anchor\" href=\"#2-udp头部结构\">#</a> 2. <strong>UDP 头部结构</strong></h3>\n<ul>\n<li><strong>源端口（Source Port）</strong>：可选项，表示数据包的发送端口，方便接收端识别数据的来源。</li>\n<li><strong>目的端口（Destination Port）</strong>：必选项，表示数据包的接收端口，接收方根据此端口号将数据包分发到相应的应用进程。</li>\n<li><strong>长度（Length）</strong>：UDP 报文的总长度，包括头部和数据部分。</li>\n<li><strong>校验和（Checksum）</strong>：用于检验数据的完整性，但不提供纠错功能。</li>\n</ul>\n<h3 id=\"3-udp的多路复用和多路分解\"><a class=\"anchor\" href=\"#3-udp的多路复用和多路分解\">#</a> 3. <strong>UDP 的多路复用和多路分解</strong></h3>\n<ul>\n<li><strong>多路复用（Multiplexing）</strong>：多个应用程序在同一主机上可以使用不同的 UDP 端口号向网络发送数据。每个数据包通过一个特定的 UDP 端口发送，确保发送端的数据流可以正确地传输到接收方。</li>\n<li><strong>多路分解（Demultiplexing）</strong>：接收方的传输层通过数据包的目的端口号，将收到的数据包分配给相应的应用进程。</li>\n<li><strong>基于端口的分解</strong>：UDP 的多路分解仅依赖于目的端口号，而不考虑源 IP 或源端口。这意味着不同的源可以通过相同的目的端口号将数据发送给同一个接收进程。</li>\n</ul>\n<h3 id=\"4-udp的典型应用场景\"><a class=\"anchor\" href=\"#4-udp的典型应用场景\">#</a> 4. <strong>UDP 的典型应用场景</strong></h3>\n<ul>\n<li><strong>实时应用</strong>：如视频会议、IP 电话、在线游戏等应用。它们对延迟敏感且要求数据尽快到达，丢包不会严重影响体验，因此更适合使用 UDP。</li>\n<li><strong>广播和多播</strong>：UDP 支持广播和多播，可以将数据同时发送给多个接收方，适合用于局域网中的发现服务（如 DHCP、UPnP 等）。</li>\n<li><strong>简化的传输需求</strong>：如 DNS 查询、SNMP 等应用，只需发送小数据量且无需重传。丢包对这些应用影响较小，因此它们更适合使用 UDP。</li>\n</ul>\n<h3 id=\"5-udp的优缺点\"><a class=\"anchor\" href=\"#5-udp的优缺点\">#</a> 5. <strong>UDP 的优缺点</strong></h3>\n<ul>\n<li><strong>优点</strong>：\n<ul>\n<li><strong>低延迟</strong>：无连接、无重传的特性使得 UDP 传输延迟低，适合实时应用。</li>\n<li><strong>简单高效</strong>：头部结构简单，数据处理开销小。</li>\n<li><strong>支持广播 / 多播</strong>：便于在局域网中进行资源发现。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：\n<ul>\n<li><strong>不可靠</strong>：无重传和确认机制，数据可能丢失或乱序。</li>\n<li><strong>无流量控制和拥塞控制</strong>：可能导致网络拥堵或过载。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-udp和tcp的对比\"><a class=\"anchor\" href=\"#6-udp和tcp的对比\">#</a> 6. <strong>UDP 和 TCP 的对比</strong></h3>\n<ul>\n<li><strong>可靠性</strong>：TCP 提供可靠传输和重传机制，而 UDP 不保证数据的传输可靠性。</li>\n<li><strong>延迟</strong>：UDP 延迟更低，因为它无需建立连接和等待确认。</li>\n<li><strong>数据顺序</strong>：TCP 保证数据按序到达，UDP 则不保证顺序。</li>\n<li><strong>适用场景</strong>：TCP 适用于需要可靠性、数据完整性的应用，如文件传输、网页浏览；UDP 适用于对实时性要求高、允许丢包的应用，如视频流和 DNS 查询。</li>\n</ul>\n<h2 id=\"tcp\"><a class=\"anchor\" href=\"#tcp\">#</a> <span class=\"label danger\">TCP</span></h2>\n<p>在传输层协议中，**TCP（Transmission Control Protocol，传输控制协议）** 是一种面向连接、可靠的传输协议。与 UDP 相比，TCP 提供了数据的可靠传输、流量控制和拥塞控制，是大多数对数据完整性要求较高的应用的首选协议。以下是 TCP 部分的核心内容：</p>\n<h3 id=\"1-tcp的主要特性\"><a class=\"anchor\" href=\"#1-tcp的主要特性\">#</a> 1. <strong>TCP 的主要特性</strong></h3>\n<ul>\n<li><strong>面向连接</strong>：TCP 是面向连接的协议，数据传输前需要建立连接。TCP 通过三次握手建立连接，并通过四次挥手断开连接。</li>\n<li><strong>可靠传输</strong>：TCP 通过确认（ACK）、重传机制确保数据不丢失、不重复、按顺序到达接收方。</li>\n<li><strong>有序传输</strong>：TCP 对数据包进行编号（序列号），接收方根据序列号将数据包按正确的顺序排列，从而保证数据的有序性。</li>\n<li><strong>全双工通信</strong>：TCP 支持全双工通信，允许通信双方在同一时间内发送和接收数据。</li>\n<li><strong>流量控制</strong>：TCP 使用滑动窗口机制进行流量控制，确保发送方的发送速率不会超出接收方的接收能力。</li>\n<li><strong>拥塞控制</strong>：TCP 具有拥塞控制机制，通过动态调整发送速率来防止网络拥塞。</li>\n</ul>\n<h3 id=\"2-tcp连接的建立和断开\"><a class=\"anchor\" href=\"#2-tcp连接的建立和断开\">#</a> 2. <strong>TCP 连接的建立和断开</strong></h3>\n<ul>\n<li><strong>三次握手（Three-Way Handshake）</strong>：\n<ul>\n<li>连接建立时，TCP 使用三次握手协议。</li>\n<li>第一步：客户端向服务器发送 SYN（同步）请求。</li>\n<li>第二步：服务器收到 SYN 后，返回一个 SYN-ACK（同步确认）。</li>\n<li>第三步：客户端收到 SYN-ACK 后，再发送一个 ACK，连接正式建立。</li>\n</ul>\n</li>\n<li><strong>四次挥手（Four-Way Teardown）</strong>：\n<ul>\n<li>连接断开时，TCP 使用四次挥手协议。</li>\n<li>第一步：客户端向服务器发送 FIN（终止）请求。</li>\n<li>第二步：服务器收到 FIN 后，返回一个 ACK，表示收到。</li>\n<li>第三步：服务器在处理完数据后，发送 FIN 请求。</li>\n<li>第四步：客户端返回 ACK，连接正式断开。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-tcp的可靠性机制\"><a class=\"anchor\" href=\"#3-tcp的可靠性机制\">#</a> 3. <strong>TCP 的可靠性机制</strong></h3>\n<ul>\n<li><strong>序列号（Sequence Number）</strong>：TCP 为每个字节分配一个序列号，以确保数据按顺序到达。</li>\n<li><strong>确认应答（ACK）</strong>：接收方在接收到数据后，向发送方发送确认信息（ACK），告知发送方数据已成功接收。</li>\n<li><strong>重传机制</strong>：如果发送方在超时时间内未收到 ACK，则会重传数据。TCP 根据网络状态调整超时时间，确保数据可靠传输。</li>\n<li><strong>窗口机制</strong>：TCP 通过窗口机制一次可以发送多个字节的数据，窗口大小取决于接收方的接收能力和网络状况。</li>\n</ul>\n<h3 id=\"4-tcp的流量控制\"><a class=\"anchor\" href=\"#4-tcp的流量控制\">#</a> 4. <strong>TCP 的流量控制</strong></h3>\n<ul>\n<li><strong>滑动窗口（Sliding Window）</strong>：TCP 使用滑动窗口机制进行流量控制，窗口大小代表了发送方在未接收到 ACK 前可以发送的最大数据量。</li>\n<li><strong>窗口调整</strong>：接收方通过通告窗口（Advertised Window）来控制发送方的发送速率。接收方在 ACK 中通告自己的接收窗口大小，发送方根据该窗口调整发送数据的量。</li>\n<li><strong>目的</strong>：流量控制确保发送方不会淹没接收方的缓冲区，避免接收方因接收速度不足而丢失数据。</li>\n</ul>\n<h3 id=\"5-tcp的拥塞控制\"><a class=\"anchor\" href=\"#5-tcp的拥塞控制\">#</a> 5. <strong>TCP 的拥塞控制</strong></h3>\n<ul>\n<li><strong>拥塞窗口（Congestion Window，cwnd）</strong>：TCP 维护一个拥塞窗口，该窗口根据网络拥塞情况动态变化。</li>\n<li><strong>慢启动（Slow Start）</strong>：在连接开始时，TCP 使用慢启动算法，逐步增加拥塞窗口，探测可用带宽。</li>\n<li><strong>拥塞避免（Congestion Avoidance）</strong>：当拥塞窗口达到阈值后，进入拥塞避免阶段，窗口以线性速度增长。</li>\n<li><strong>快速重传和快速恢复</strong>：\n<ul>\n<li><strong>快速重传</strong>：当发送方收到三个重复的 ACK 时，认为该数据段丢失，立即重传而不等待超时。</li>\n<li><strong>快速恢复</strong>：在快速重传后，TCP 直接进入拥塞避免阶段，避免回到慢启动。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-tcp的典型应用场景\"><a class=\"anchor\" href=\"#6-tcp的典型应用场景\">#</a> 6. <strong>TCP 的典型应用场景</strong></h3>\n<ul>\n<li><strong>文件传输</strong>（如 FTP）：文件传输要求数据的完整性和顺序性，TCP 的可靠性和流量控制确保数据无丢失和按序到达。</li>\n<li><strong>网页浏览</strong>（如 HTTP/HTTPS）：网页浏览要求数据可靠传输，以确保页面内容完整。TCP 的可靠性和流量控制能够确保用户得到完整的网页内容。</li>\n<li><strong>电子邮件</strong>（如 SMTP）：电子邮件传输需要数据的完整性和正确性，因此 TCP 的可靠传输特性非常适合。</li>\n</ul>\n<h3 id=\"7-tcp的优缺点\"><a class=\"anchor\" href=\"#7-tcp的优缺点\">#</a> 7. <strong>TCP 的优缺点</strong></h3>\n<ul>\n<li><strong>优点</strong>：\n<ul>\n<li><strong>可靠传输</strong>：保证数据按顺序到达且不会丢失。</li>\n<li><strong>流量和拥塞控制</strong>：适应不同的网络状况，防止网络拥堵。</li>\n<li><strong>有序性</strong>：数据按顺序到达，适用于大多数需要数据完整性的应用。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：\n<ul>\n<li><strong>开销较高</strong>：TCP 头部较复杂，且维护连接状态会增加开销。</li>\n<li><strong>延迟较高</strong>：TCP 的三次握手和确认机制增加了延迟，不适合对实时性要求较高的应用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-tcp和udp的对比\"><a class=\"anchor\" href=\"#8-tcp和udp的对比\">#</a> 8. <strong>TCP 和 UDP 的对比</strong></h3>\n<ul>\n<li><strong>可靠性</strong>：TCP 提供可靠传输，UDP 不保证可靠性。</li>\n<li><strong>延迟</strong>：UDP 延迟更低，而 TCP 由于需要建立连接和确认机制，延迟较高。</li>\n<li><strong>适用场景</strong>：TCP 适用于需要可靠传输的应用，如文件传输和网页浏览；UDP 适用于对实时性要求高的应用，如视频流和 DNS 查询。</li>\n</ul>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>TCP 提供了一套复杂而强大的机制，确保数据的可靠传输。通过连接管理、确认机制、流量控制和拥塞控制，TCP 在需要数据完整性的场景下发挥了关键作用。TCP 的可靠性使其成为大多数网络应用（如 HTTP、FTP 和 SMTP）的首选协议。</p>\n<h2 id=\"rdt\"><a class=\"anchor\" href=\"#rdt\">#</a> RDT</h2>\n<h4 id=\"rdt20的关键要点\"><a class=\"anchor\" href=\"#rdt20的关键要点\">#</a> rdt2.0 的关键要点</h4>\n<ol>\n<li>\n<p><strong>比特错误检测</strong>：</p>\n<ul>\n<li>数据在传输过程中可能会发生比特翻转（bit-flip），导致数据出错。</li>\n<li>rdt2.0 使用校验和（checksum）来检测数据包中的比特错误。</li>\n</ul>\n</li>\n<li>\n<p><strong>确认和否认机制</strong>：</p>\n<ul>\n<li><strong>ACK（Acknowledgements）</strong>：当接收方确认数据包没有错误时，会发送 ACK（确认）消息给发送方，告知数据包正确接收。</li>\n<li><strong>NAK（Negative Acknowledgements）</strong>：当接收方检测到数据包出错时，会发送 NAK（否认）消息给发送方，告知该数据包有错误。</li>\n</ul>\n</li>\n<li>\n<p><strong>重传机制</strong>：</p>\n<ul>\n<li>当发送方收到 NAK 时，会重传数据包，以确保数据正确到达接收方。</li>\n</ul>\n</li>\n<li>\n<p><strong>新增机制</strong>：</p>\n<ul>\n<li><strong>错误检测</strong>：通过校验和实现比特错误检测。</li>\n<li><strong>接收方反馈</strong>：接收方通过控制消息（ACK 和 NAK）向发送方反馈接收状态，使发送方能够知道数据包是否需要重传。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"rdt20的工作流程\"><a class=\"anchor\" href=\"#rdt20的工作流程\">#</a> rdt2.0 的工作流程</h4>\n<ul>\n<li>发送方发送数据包，数据包中包含校验和。</li>\n<li>接收方收到数据包后，检查校验和。\n<ul>\n<li>如果校验和匹配，说明数据包无错误，接收方发送 ACK 给发送方。</li>\n<li>如果校验和不匹配，说明数据包有错误，接收方发送 NAK，要求发送方重传。</li>\n</ul>\n</li>\n<li>发送方根据接收到的是 ACK 还是 NAK 来决定是否重传数据。</li>\n</ul>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2Frdt.png\" alt></p>\n<h4 id=\"示例发送方状态机解析\"><a class=\"anchor\" href=\"#示例发送方状态机解析\">#</a> 示例：发送方状态机解析</h4>\n<ol>\n<li>\n<p><strong>等待上层调用（Wait for call from above）</strong>：</p>\n<ul>\n<li>初始状态，发送方等待上层应用调用  <code>rdt_send(data)</code> 。</li>\n<li>一旦有数据传入，发送方创建数据包（包括数据和校验和）  <code>sndpkt = make_pkt(data, checksum)</code> ，并通过  <code>udt_send(sndpkt)</code>  将数据包发送到信道。</li>\n<li>发送完数据后，发送方进入等待 ACK 或 NAK 的状态。</li>\n</ul>\n</li>\n<li>\n<p><strong>等待 ACK 或 NAK（Wait for ACK or NAK）</strong>：</p>\n<ul>\n<li>发送方在此状态下等待接收方的反馈。</li>\n<li>如果接收到的是 NAK（ <code>isNAK(rcvpkt)</code> ），表示数据包出错，发送方会重传数据包  <code>udt_send(sndpkt)</code> 。</li>\n<li>如果接收到的是 ACK（ <code>isACK(rcvpkt)</code> ），表示数据包已正确接收，发送方回到等待上层调用的初始状态。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"接收方状态机解析\"><a class=\"anchor\" href=\"#接收方状态机解析\">#</a> 接收方状态机解析</h4>\n<ol>\n<li>\n<p><strong>等待数据包（Wait for call from below）</strong>：</p>\n<ul>\n<li>初始状态，接收方等待数据包的到来。</li>\n<li>当接收到一个数据包  <code>rdt_rcv(rcvpkt)</code>  后，接收方会检查数据包是否损坏。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据包损坏或无误</strong>：</p>\n<ul>\n<li><strong>如果数据包损坏（ <code>corrupt(rcvpkt)</code> ）</strong>：接收方发送 NAK（ <code>udt_send(NAK)</code> ）通知发送方重传。</li>\n<li><strong>如果数据包无误（ <code>notcorrupt(rcvpkt)</code> ）</strong>：接收方提取数据  <code>extract(rcvpkt, data)</code> ，并将其交付给上层  <code>deliver_data(data)</code> ，然后发送 ACK（ <code>udt_send(ACK)</code> ）通知发送方数据已正确接收。</li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2Frdt2%E7%BC%BA%E9%99%B7.png\" alt></p>\n<h3 id=\"rdt20的缺陷\"><a class=\"anchor\" href=\"#rdt20的缺陷\">#</a> rdt2.0 的缺陷</h3>\n<ul>\n<li>\n<p><strong>问题描述</strong>：</p>\n<ul>\n<li>如果 ACK 或 NAK 消息在传输过程中被损坏，发送方就无法知道接收方是否正确接收了数据包。</li>\n<li>发送方在这种情况下无法确定是否需要重传数据包，因为重传可能会导致接收方收到重复的数据包。</li>\n</ul>\n</li>\n<li>\n<p><strong>不能直接重传的原因</strong>：</p>\n<ul>\n<li>如果发送方简单地重传数据包，可能会导致接收方接收到重复的数据，从而影响数据的正确性。</li>\n<li>由于发送方无法确定接收方的实际状态，因此简单的重传会导致数据包的冗余和不确定性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"处理重复数据包的方法\"><a class=\"anchor\" href=\"#处理重复数据包的方法\">#</a> 处理重复数据包的方法</h3>\n<p>为了解决 ACK/NAK 损坏的问题，以及可能导致的重复数据包，rdt2.0 需要进行以下改进：</p>\n<ol>\n<li>\n<p><strong>添加序列号（Sequence Number）</strong>：</p>\n<ul>\n<li>每个数据包附加一个序列号，以区分数据包的唯一性。</li>\n<li>序列号帮助接收方识别出重复的数据包，从而避免重复交付。</li>\n</ul>\n</li>\n<li>\n<p><strong>丢弃重复的数据包</strong>：</p>\n<ul>\n<li>如果接收方检测到数据包的序列号与上一个接收的数据包相同，则丢弃该数据包，不再传递给上层应用。</li>\n<li>这样可以确保即使发送方因 ACK/NAK 损坏而重传数据，接收方也不会重复处理相同的数据。</li>\n</ul>\n</li>\n<li>\n<p><strong>超时重传</strong>：</p>\n<ul>\n<li>为了防止无限等待，发送方可以使用超时机制。在未收到 ACK/NAK 的情况下，发送方等待一段时间后自动重传数据包。</li>\n<li>超时机制确保数据包能够最终被成功接收，避免了无休止的等待。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"停止等待机制stop-and-wait\"><a class=\"anchor\" href=\"#停止等待机制stop-and-wait\">#</a> <strong>“停止等待” 机制（Stop and Wait）</strong></h3>\n<ul>\n<li>在这种机制下，发送方每次仅发送一个数据包，然后等待接收方的 ACK 或 NAK 响应。</li>\n<li>只有在接收到 ACK 后，发送方才会继续发送下一个数据包。如果未收到 ACK（例如 ACK 损坏或丢失），发送方则会重传当前数据包。</li>\n<li>停止等待机制简化了协议的实现，但可能会导致传输效率下降，特别是在网络延迟较大时。</li>\n</ul>\n<h3 id=\"后续版本\"><a class=\"anchor\" href=\"#后续版本\">#</a> 后续版本</h3>\n<h3 id=\"1-rdt21解决acknak损坏问题\"><a class=\"anchor\" href=\"#1-rdt21解决acknak损坏问题\">#</a> 1. <strong>rdt2.1：解决 ACK/NAK 损坏问题</strong></h3>\n<ul>\n<li>\n<p><strong>问题</strong>：在 rdt2.0 中，如果 ACK 或 NAK 发生损坏，发送方无法判断接收方的状态，从而导致数据包的潜在重复或丢失。</p>\n</li>\n<li>\n<p><strong>改进</strong>：</p>\n<ul>\n<li><strong>序列号</strong>：引入序列号来标记数据包的唯一性。每个数据包使用 0 或 1 的序列号，以便接收方可以检测到重复的数据包。</li>\n<li><strong>冗余 ACK</strong>：如果 ACK 或 NAK 损坏，发送方会根据超时机制重发数据包。接收方在接收相同序列号的数据包时会丢弃重复的数据包，但仍会发送冗余 ACK。</li>\n<li><strong>状态机调整</strong>：发送方和接收方都需要跟踪序列号，发送方根据接收的 ACK 或 NAK 来判断是否需要重传。</li>\n</ul>\n</li>\n<li>\n<p><strong>工作流程</strong>：</p>\n<ol>\n<li>发送方发送带序列号的包，并等待 ACK 或 NAK。</li>\n<li>接收方收到包后，根据校验和检测是否有错误。若无错误，发送 ACK，若有错误，发送 NAK。</li>\n<li>若 ACK/NAK 损坏，发送方超时后会重发数据包。接收方通过序列号来丢弃重复包。</li>\n</ol>\n</li>\n<li>\n<p><strong>优势</strong>：rdt2.1 通过序列号和 ACK 重传解决了 ACK/NAK 损坏的问题。</p>\n</li>\n</ul>\n<h3 id=\"2-rdt22仅使用ack无nak\"><a class=\"anchor\" href=\"#2-rdt22仅使用ack无nak\">#</a> 2. <strong>rdt2.2：仅使用 ACK，无 NAK</strong></h3>\n<ul>\n<li><strong>问题</strong>：rdt2.1 依赖 ACK 和 NAK 双重反馈，但在实际网络中，使用 NAK 可能会引入额外的复杂性。</li>\n<li><strong>改进</strong>：\n<ul>\n<li><strong>纯 ACK 机制</strong>：取消了 NAK，接收方只使用 ACK 来响应。</li>\n<li><strong>冗余 ACK 机制</strong>：如果接收方检测到数据包有错误（如校验和失败），则不发送 NAK，而是重复发送上一条 ACK。发送方在接收冗余 ACK 后，将重传数据包。</li>\n</ul>\n</li>\n<li><strong>工作流程</strong>：\n<ol>\n<li>发送方发送带序列号的包，并等待 ACK。</li>\n<li>接收方若检测到包无错误，则发送 ACK。如果检测到包有错误，发送上一个包的 ACK（即冗余 ACK）。</li>\n<li>发送方在接收到冗余 ACK 时，将当前包重发。</li>\n</ol>\n</li>\n<li><strong>优势</strong>：rdt2.2 避免了 NAK 的使用，简化了接收方逻辑。该版本仅依赖 ACK，进一步提高了效率。</li>\n</ul>\n<h3 id=\"3-rdt30处理信道丢包问题\"><a class=\"anchor\" href=\"#3-rdt30处理信道丢包问题\">#</a> 3. <strong>rdt3.0：处理信道丢包问题</strong></h3>\n<ul>\n<li><strong>问题</strong>：rdt2.x 版本解决了比特错误问题，但假设信道不会丢包。然而，在实际网络中，数据包可能会丢失，因此 rdt2.x 无法保证在丢包信道上的可靠性。</li>\n<li><strong>改进</strong>：\n<ul>\n<li><strong>超时重传机制</strong>：rdt3.0 在发送方引入了超时重传机制。发送方在发送数据包后，启动一个定时器。如果在超时时间内未收到 ACK，则自动重传数据包。</li>\n<li><strong>序列号</strong>：继续使用序列号来检测重复包，确保接收方不会交付重复数据。</li>\n</ul>\n</li>\n<li><strong>工作流程</strong>：\n<ol>\n<li>发送方发送带序列号的包，并等待 ACK，同时启动定时器。</li>\n<li>接收方收到包后，若无错误，则发送 ACK 并交付数据；若有错误，发送冗余 ACK。</li>\n<li>若发送方在超时时间内未收到 ACK，自动重传数据包。</li>\n<li>接收方通过序列号丢弃重复包，保证数据无重复交付。</li>\n</ol>\n</li>\n<li><strong>优势</strong>：rdt3.0 通过超时重传机制解决了丢包问题，能够在信道丢包和比特错误情况下实现可靠传输。</li>\n</ul>\n<h3 id=\"总结-2\"><a class=\"anchor\" href=\"#总结-2\">#</a> 总结</h3>\n<ul>\n<li><strong>rdt2.1</strong>：在 rdt2.0 的基础上引入序列号，用 ACK 和 NAK 解决确认消息损坏的问题。</li>\n<li><strong>rdt2.2</strong>：去除 NAK，仅使用 ACK 机制，通过冗余 ACK 实现重传，简化了协议。</li>\n<li><strong>rdt3.0</strong>：引入超时重传机制，解决了信道丢包的问题，实现了在丢包和比特错误信道上的可靠数据传输。</li>\n</ul>\n<p>rdt3.0 是这几个版本中最可靠的协议，适用于丢包和比特错误的复杂信道环境。</p>\n",
            "tags": [
                "计算机科学",
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2024/10/25/game-engine/unity/unityCompetition/%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A0%81%E4%BA%91/",
            "url": "http://example.com/2024/10/25/game-engine/unity/unityCompetition/%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A0%81%E4%BA%91/",
            "title": "创建并添加代码到gitee",
            "date_published": "2024-10-25T00:35:46.379Z",
            "content_html": "<h3 id=\"1-创建-github-仓库\"><a class=\"anchor\" href=\"#1-创建-github-仓库\">#</a> 1. 创建 GitHub 仓库</h3>\n<ol>\n<li>登录到 [Gitee](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20v\">工作台 - Gitee.com</span>)。</li>\n<li>点击右上角的 <strong>&quot;+&quot;</strong>，选择 <strong>&quot;New repository&quot;</strong>。</li>\n<li>输入仓库名称和其他信息，然后点击 <strong>&quot;Create repository&quot;</strong>。</li>\n<li>复制仓库的 HTTPS 或 SSH 链接（例如， <code>https://github.com/username/repository.git</code> ）。</li>\n</ol>\n<h3 id=\"2-初始化本地仓库\"><a class=\"anchor\" href=\"#2-初始化本地仓库\">#</a> 2. 初始化本地仓库</h3>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/unity%2F%E5%85%8B%E9%9A%86.png\" alt=\"图片描述\"></p>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/unity%2Fgit%E5%B9%B3%E5%8F%B0.png\" alt=\"图片描述\"></p>\n<p>在本地项目文件夹中打开终端或命令行，执行以下命令：</p>\n<p><figure class=\"highlight bash\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化 Git 仓库 </span></span><br><span class=\"line\">git init  </span><br><span class=\"line\"><span class=\"comment\"># 将远程仓库链接到本地仓库 </span></span><br><span class=\"line\">git remote add origin (仓库地址)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-添加文件并提交\"><a class=\"anchor\" href=\"#3-添加文件并提交\">#</a> 3. 添加文件并提交</h3>\n<ol>\n<li><strong>将更改添加到暂存区</strong>：<br>\n<figure class=\"highlight bash\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><code>.</code>  表示添加所有文件，或指定特定文件来添加，比如  <code>git add filename</code> 。</p>\n<ol start=\"2\">\n<li><strong>提交更改</strong>：<br>\n<figure class=\"highlight bash\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;Initial commit&quot;</span></span><br></pre></td></tr></table></figure><br>\n <code>-m</code>  后面跟的是提交信息，简要描述更改内容。</li>\n</ol>\n<h3 id=\"4-推送代码到-github\"><a class=\"anchor\" href=\"#4-推送代码到-github\">#</a> 4. 推送代码到 GitHub</h3>\n<p>将本地代码推送到 GitHub 仓库的  <code>main</code>  分支：<br>\n<figure class=\"highlight bash\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure><br>\n<strong> 注意</strong>：首次推送时需要指定  <code>-u</code>  选项，以后可以直接使用  <code>git push</code> 。</p>\n<h3 id=\"5-验证提交\"><a class=\"anchor\" href=\"#5-验证提交\">#</a> 5. 验证提交</h3>\n<p>在 Gitee 仓库页面刷新，您应该可以看到已提交的代码。</p>\n<h3 id=\"6-拉取代码\"><a class=\"anchor\" href=\"#6-拉取代码\">#</a> 6. 拉取代码</h3>\n<p><figure class=\"highlight bash\"><figcaption><span>row</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> (仓库地址)</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "游戏引擎",
                "unity",
                "unity创想赛"
            ]
        },
        {
            "id": "http://example.com/2024/10/23/computer/networks/assignment2%20%E9%A2%98%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/",
            "url": "http://example.com/2024/10/23/computer/networks/assignment2%20%E9%A2%98%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/",
            "title": "assignment2",
            "date_published": "2024-10-22T22:48:25.919Z",
            "content_html": "<h2 id=\"1sdn\"><a class=\"anchor\" href=\"#1sdn\">#</a> 1.SDN</h2>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2Fass2%2FSnipaste_2024-10-23_09-51-25.png\" alt=\"图片描述\"></p>\n<ol>\n<li>RIP（Routing Information Protocol）：</li>\n</ol>\n<ul>\n<li>\n<p><strong>基本原理</strong>：RIP 使用一种称为 <strong>距离向量（Distance Vector）</strong> 的路由算法。它通过跳数（hop count）来衡量到达目标网络的距离，跳数即从一个路由器到目标网络需要经过的路由器数量。</p>\n</li>\n<li>\n<p><strong>特点</strong>：</p>\n<ul>\n<li><strong>跳数限制</strong>：RIP 的最大跳数为 15，跳数达到 16 被视为不可到达。这意味着 RIP 适用于较小的网络。</li>\n<li><strong>更新频率</strong>：RIP 每 30 秒向其邻居广播路由表更新信息，这样做会增加网络负载，尤其是在大型网络中。</li>\n<li><strong>收敛速度慢</strong>：因为 RIP 需要依靠定期更新，所以在网络拓扑发生变化时，其收敛速度较慢。</li>\n<li><strong>版本</strong>：RIP 有两个版本，RIP v1（不支持子网掩码）和 RIP v2（支持子网掩码，增加了安全和效率特性）​​。</li>\n</ul>\n</li>\n<li>\n<p><strong>适用场景</strong>：由于 RIP 的跳数限制和较慢的收敛时间，它通常适用于小型或中型网络。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>OSPF（Open Shortest Path First）：</li>\n</ol>\n<ul>\n<li>\n<p><strong>基本原理</strong>：OSPF 是一种<strong>链路状态（Link State）</strong> 路由协议，它通过一种称为<strong> Dijkstra 算法</strong>的链路状态算法来计算最短路径。OSPF 可以基于多种因素（如带宽、延迟、链路成本）计算最佳路径，而不仅仅依赖于跳数。</p>\n</li>\n<li>\n<p><strong>特点</strong>：</p>\n<ul>\n<li><strong>无跳数限制</strong>：OSPF 没有跳数限制，适用于大型复杂的网络。</li>\n<li><strong>区域划分</strong>：OSPF 将大型网络划分为多个区域（Area），这样有助于降低网络复杂性，减少路由表规模，提高路由效率。</li>\n<li><strong>快速收敛</strong>：OSPF 具有快速的收敛特性。当网络拓扑发生变化时，OSPF 能够迅速检测到变化，并重新计算最佳路径。</li>\n<li><strong>成本计算</strong>：OSPF 使用基于带宽的成本来计算最佳路径，网络管理员可以配置链路的成本值来优化路由选择​​。</li>\n<li><strong>多播更新</strong>：与 RIP 的广播不同，OSPF 使用多播（multicast）来传播链路状态信息，降低了不必要的网络流量。</li>\n</ul>\n</li>\n<li>\n<p><strong>适用场景</strong>：OSPF 适用于中型到大型网络，特别是在需要复杂路由选择和快速收敛的情况下。</p>\n</li>\n</ul>\n<p>而<strong> SDN</strong>，也就是<strong>软件定义网络</strong>（Software-Defined Networking），是一种让网络更 “智能” 和 “灵活” 的新技术。通俗地说，它打破了传统网络的限制，使得我们能够像编写软件一样，灵活地控制网络中的设备。<br>\n通俗解释：</p>\n<ol>\n<li>\n<p><strong>传统网络是怎么工作的？</strong></p>\n<ul>\n<li>在传统网络中，路由器和交换机这样的设备自己做决策，决定数据从哪里进、到哪里出。每个设备都有自己的 “大脑”（控制系统），它们通过自己内部的规则来决定如何转发数据。</li>\n<li>这种方式的缺点是：每台设备只能知道自己周围的一些情况，无法掌控整个网络。因此，管理网络变得很复杂，如果要改变某个地方的流量，可能需要逐一配置很多设备。</li>\n</ul>\n</li>\n<li>\n<p><strong>SDN 是怎么做的？</strong></p>\n<ul>\n<li>SDN 通过<strong>把网络设备的 “大脑” 集中起来</strong>，统一用一个 “中央控制器” 来控制所有网络设备。这就像有一个总指挥官，能看到整个网络的全貌，并能迅速决定数据的最佳传输路径。</li>\n<li><strong>数据设备变成 “执行者”</strong>：路由器和交换机不再自己做决定，而是听从控制器的指令，负责把数据按照命令发送到正确的地方。</li>\n</ul>\n</li>\n<li>\n<p><strong>为什么 SDN 更好？</strong></p>\n<ul>\n<li><strong>灵活控制</strong>：就像编写程序一样，管理员可以通过软件定义网络流量，自动化配置，而不需要手动去调整每个设备的设置。</li>\n<li><strong>全局视角</strong>：控制器能看到整个网络的流量情况，能够根据实时情况动态调整，比如：在某个地方流量很大时，可以自动分流到其他路径。</li>\n<li><strong>自动化管理</strong>：可以编写规则，自动化处理网络中的问题，比如检测到网络拥塞时，可以自动调整路由来缓解压力。</li>\n</ul>\n</li>\n</ol>\n<div class=\"note danger no-icon\">\n<p>传统路由协议都是通过一定的算法和 cost 来决定走向，所以在这道题无法实现负载均衡，传统方式很难通过路由判断并走向设定好的路线，不是通过实时的负载和流量来判断的。</p>\n</div>\n<hr>\n<h2 id=\"2tcp\"><a class=\"anchor\" href=\"#2tcp\">#</a> 2.TCP</h2>\n<p><img data-src=\"https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks/ass2/Snipaste_2024-10-23_09-51-55.png\" alt=\"图片描述\"></p>\n<p><strong>TCP Reno</strong> 是一种 <strong>TCP（传输控制协议）</strong> 拥塞控制算法，是经典 <strong>TCP Tahoe</strong> 算法的改进版本。TCP Reno 主要优化了拥塞检测和恢复过程，特别是在数据丢包后的表现。它通过在检测到丢包时引入 <strong>快速恢复（Fast Recovery）</strong> 和 <strong>快速重传（Fast Retransmit）</strong> 机制，使得丢包后的恢复效率更高。</p>\n<h3 id=\"tcp-reno的主要特性\"><a class=\"anchor\" href=\"#tcp-reno的主要特性\">#</a> TCP Reno 的主要特性：</h3>\n<ol>\n<li>\n<p><strong>慢启动（Slow Start）</strong>：</p>\n<ul>\n<li>当连接开始或检测到网络超时时，<strong>拥塞窗口（cwnd）</strong> 从较小值（通常是 1 个 MSS，即最大报文段）开始，随着每次接收到 ACK 后，cwnd 以指数增长的方式逐渐增大，直到达到一个阈值（<strong>ssthresh</strong>，慢启动阈值）​​。</li>\n</ul>\n</li>\n<li>\n<p><strong>拥塞避免（Congestion Avoidance）</strong>：</p>\n<ul>\n<li>当 cwnd 增长到超过 ssthresh 时，TCP 进入拥塞避免阶段，cwnd 不再指数增长，而是线性增长，每个 RTT（往返时间）增加 1 个 MSS。这一机制能够更平缓地增加发送速率，减少网络拥塞的风险​。</li>\n</ul>\n</li>\n<li>\n<p><strong>快速重传（Fast Retransmit）</strong>：</p>\n<ul>\n<li>当发送方接收到<strong> 3 个重复的 ACK</strong> 时，TCP Reno 假设网络发生了丢包，而不是等到超时来判断丢包。这时，TCP Reno 会立即重传该丢失的数据段，而不等待超时，从而提高丢包后的响应速度​。</li>\n</ul>\n</li>\n<li>\n<p><strong>快速恢复（Fast Recovery）</strong>：</p>\n<ul>\n<li>在 TCP Tahoe 中，丢包后会将<strong> cwnd</strong> 立即减小到 1MSS，然后重新进入慢启动阶段。但 TCP Reno 在检测到 3 个重复的 ACK 后，会将 cwnd 减半（进入快速恢复），然后进入线性增长的拥塞避免阶段，而不是回到慢启动。这一优化使得 TCP Reno 在处理丢包时更加高效，不会像 Tahoe 一样大幅降低传输速度​​。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"tcp-reno的工作流程\"><a class=\"anchor\" href=\"#tcp-reno的工作流程\">#</a> TCP Reno 的工作流程：</h3>\n<ol>\n<li><strong>初始阶段</strong>：从慢启动开始，cwnd 呈指数增长，直到达到 ssthresh。</li>\n<li><strong>拥塞避免</strong>：一旦 cwnd 达到 ssthresh，cwnd 以线性速度增长。</li>\n<li><strong>丢包检测</strong>：当接收到 3 个重复 ACK 时，TCP Reno 立即触发<strong>快速重传</strong>。</li>\n<li>Congestion 发生后 (lost packet)<br>\n1）timeout\n<ul>\n<li>cwnd=1,ssthresh 变为当前 cwnd 的一半，并从 slow start 开始<br>\n 2) dup</li>\n<li>cwnd 变为 lost packet 时的一半，并从 addtive increase 即拥塞避免开始</li>\n</ul>\n</li>\n<li><strong>快速恢复</strong>：cwnd 减半，进入快速恢复阶段，避免完全进入慢启动。</li>\n</ol>\n<h3 id=\"与tcp-tahoe的区别\"><a class=\"anchor\" href=\"#与tcp-tahoe的区别\">#</a> 与 TCP Tahoe 的区别：</h3>\n<ul>\n<li><strong>TCP Tahoe</strong> 在丢包时会将 cwnd 直接减小到 1，并重新进入慢启动阶段。</li>\n<li><strong>TCP Reno</strong> 则引入了<strong>快速恢复</strong>机制，丢包时不再完全进入慢启动，而是减半 cwnd 并进入线性增长的拥塞避免阶段，这显著减少了网络中的恢复时间​​。</li>\n</ul>\n<p>TCP Reno 由于其更加高效的丢包恢复机制，成为 TCP 协议中较为常用的拥塞控制算法之一，尤其适用于高延迟、大带宽的网络环境。</p>\n<h3 id=\"p2p\"><a class=\"anchor\" href=\"#p2p\">#</a> P2P</h3>\n<p>file distribution: 把文件发给 N 个主机</p>\n",
            "tags": [
                "计算机科学",
                "计算机网络"
            ]
        }
    ]
}
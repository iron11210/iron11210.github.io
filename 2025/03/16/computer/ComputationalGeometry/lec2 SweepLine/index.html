<!-- build time:Thu Jun 12 2025 10:25:08 GMT+1000 (澳大利亚东部标准时间) --><!DOCTYPE html><script async src="https://www.googletagmanager.com/gtag/js?id=G-DPVE7Y0QX9"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-DPVE7Y0QX9")</script><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="杂项笔记" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="杂项笔记" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="杂项笔记" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/2025/03/16/computer/ComputationalGeometry/lec2%20SweepLine/"><title>lec2 SweepLine - 计算几何 - 计算机科学 | IRON = 杂项笔记</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">lec2 SweepLine</h1><div class="meta"><span class="item" title="创建时间：2025-03-16 11:26:24"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-03-16T11:26:24+08:00">2025-03-16</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">IRON</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://dlink.host/wx2.sinaimg.cn/large/006Tzddnly8htqg0x2lhcg3074074e7q.gif"></li><li class="item" data-background-image="https://dlink.host/wx4.sinaimg.cn/large/006Tzddnly8htqg1pgsrij30sg0sgtdo.jpg"></li><li class="item" data-background-image="https://dlink.host/wx3.sinaimg.cn/large/006Tzddnly8htqg1arfzvj30sg0sg0x7.jpg"></li><li class="item" data-background-image="https://dlink.host/wx4.sinaimg.cn/large/006Tzddnly8htpyghxhuvg30b40b41jo.gif"></li><li class="item" data-background-image="https://dlink.host/wx4.sinaimg.cn/large/006Tzddnly8htqg1pgsrij30sg0sgtdo.jpg"></li><li class="item" data-background-image="https://dlink.host/wx2.sinaimg.cn/large/006Tzddnly8htqg1keshmj30sg0sgjvu.jpg"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer/ComputationalGeometry/" itemprop="item" rel="index" title="分类于 计算几何"><span itemprop="name">计算几何</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2025/03/16/computer/ComputationalGeometry/lec2%20SweepLine/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="IRON"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="杂项笔记"></span><div class="body md" itemprop="articleBody"><h2 id="一-多边形的三角剖分polygon-triangulation"><a class="anchor" href="#一-多边形的三角剖分polygon-triangulation">#</a> 一、多边形的三角剖分（Polygon Triangulation）</h2><h3 id="1-算法1"><a class="anchor" href="#1-算法1">#</a> 1. 算法 1</h3><p></p><figure class="highlight c++"><figcaption><span>row</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 多边形 P 尚未被完全三角剖分:</span><br><span class="line">    找到一条有效对角线 (x,y)</span><br><span class="line">    输出对角线 (x,y)</span><br></pre></td></tr></table></figure><p></p><h4 id="算法复杂度分析"><a class="anchor" href="#算法复杂度分析">#</a> 📌算法复杂度分析：</h4><p>算法复杂度从以下三个方面分析：</p><ul><li><strong>对角线数量（Number of potential diagonals）</strong>：<ul><li>一个多边形有 n 个顶点，每对顶点都有可能构成对角线，所以潜在对角线最多为 O (n2) O (n^2) O (n2)。</li></ul></li><li><strong>检查一条潜在的对角线是否合法（Testing one potential diagonal）</strong>：<ul><li>对于一条潜在对角线，要检查它是否在多边形内、不与其他边交叉等情况，复杂度为 O (n) O (n) O (n)。</li></ul></li><li><strong>整体复杂度（Time complexity）</strong>：<ol><li>测试一条对角线的有效性: O (n)</li><li>潜在对角线数量: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>需要迭代的次数：每次成功找到一条有效对角线，可以把多边形顶点数量减少一个，总共需要 O (n) 次迭代。<br>因此，总体复杂度为：</li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>×</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>×</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n) \times O(n^2) \times O(n) = O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p></li></ul><h3 id="2-算法2耳切法"><a class="anchor" href="#2-算法2耳切法">#</a> 2. 算法 2 (耳切法)</h3><p></p><figure class="highlight c++"><figcaption><span>row</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当多边形顶点数 n &gt; <span class="number">3</span> 时，循环执行：</span><br><span class="line">    定位一个有效的耳朵尖点 v2</span><br><span class="line">    输出耳朵对角线 (v1, v3)</span><br><span class="line">    从多边形中删除 v2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>简单来说，就是：</p><ul><li>每次在多边形上找到一个合适的 “耳朵”。</li><li>输出构成该耳朵的对角线。</li><li>移除该耳朵尖点（v2），形成一个新的更小的多边形。</li><li>重复以上步骤，直到多边形完全被三角化。</li></ul><h4 id="算法复杂度分析-2"><a class="anchor" href="#算法复杂度分析-2">#</a> 📌 算法复杂度分析：</h4><ul><li><p><strong>while 循环的迭代次数</strong>：<br>每次删除一个顶点，总共需要删除 (n - 3) 个顶点，因此迭代次数是 O (n) O (n) O (n)。</p></li><li><p><strong>每次迭代时寻找有效耳朵的复杂度</strong>：<br>最坏情况下，每次要遍历所有顶点，并检查耳朵是否合法，复杂度为 O (n2) O (n^2) O (n2)。</p></li><li><p><strong>每次输出对角线和删除顶点的复杂度</strong>：<br>输出对角线和删除顶点都是常数时间，即 O (1) O (1) O (1)。</p></li></ul><p>因此总体复杂度为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mo>×</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((n - 3) \times O(n^2) = O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><h3 id="3算法3改进的耳切法"><a class="anchor" href="#3算法3改进的耳切法">#</a> 3. 算法 3（改进的耳切法）</h3><p></p><figure class="highlight c++"><figcaption><span>row</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一步：预处理所有的有效耳朵，构成耳朵集合 S（复杂度 <span class="built_in">O</span>(n²)）</span><br><span class="line"></span><br><span class="line">第二步：重复以下步骤直到多边形完全三角化 (n &gt; <span class="number">3</span>):</span><br><span class="line">    - 在集合 S 中快速找到一个有效的耳朵 v2（复杂度 <span class="built_in">O</span>(<span class="number">1</span>)）</span><br><span class="line">    - 输出耳朵对角线 (v1,v3)（复杂度 <span class="built_in">O</span>(<span class="number">1</span>)）</span><br><span class="line">    - 删除耳朵尖点 v2（复杂度 <span class="built_in">O</span>(<span class="number">1</span>)）</span><br><span class="line">    - 更新集合 S：删除和新增受影响的耳朵（复杂度 <span class="built_in">O</span>(n)）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h4 id="算法复杂度分析-3"><a class="anchor" href="#算法复杂度分析-3">#</a> 📌 算法复杂度分析：</h4><ol><li><p><strong>预处理阶段</strong>：</p><ul><li>计算并存储所有有效的耳朵，最多需要检查所有顶点的组合，复杂度为</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p></li><li><p><strong>循环阶段（总共需循环 n-3 次）</strong>：</p><ul><li><strong>查找有效耳朵</strong>：利用预先维护的耳朵集合，快速得到一个耳朵，复杂度为 O (1)。</li><li><strong>输出对角线、删除耳朵尖点</strong>：直接删除顶点，复杂度为 O (1)。</li><li><strong>更新耳朵集合</strong>：删除旧耳朵、检查和添加新的耳朵，最坏情况下需要遍历一些顶点，复杂度为 O (n)。</li></ul></li></ol><p>循环阶段总复杂度为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mo>×</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n - 3) \times O(n) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>最终，总复杂度为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mspace width="1em"><mo stretchy="false">(</mo><mtext>预处理阶段为</mtext><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>循环阶段也是</mtext><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mspace></mrow><annotation encoding="application/x-tex">O(n^2) \quad (\text{预处理阶段为} O(n^2), \text{循环阶段也是} O(n^2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em"></span><span class="mopen">(</span><span class="mord text"><span class="mord cjk_fallback">预处理阶段为</span></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord text"><span class="mord cjk_fallback">循环阶段也是</span></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><h3 id="4-算法4"><a class="anchor" href="#4-算法4">#</a> 4. 算法 4</h3><p>算法 4 分为两个主要步骤：</p><ol><li><strong>将多边形 P 划分为若干个 y - 单调多边形（y-monotone pieces）</strong></li><li><strong>对每个 y - 单调多边形进行三角剖分</strong><br>#TODO: 添加 y-monotone pieces 图片</li></ol><h4 id="为什么单调多边形更容易剖分"><a class="anchor" href="#为什么单调多边形更容易剖分">#</a> 为什么单调多边形更容易剖分</h4><p>📍 什么是 y 单调多边形？</p><ul><li>一个多边形被称为 y 单调多边形，意味着对于任意一条与 y 轴垂直的水平线，其与多边形相交的部分总是单连通的，也就是说只有一段连续的区间。<br>换句话说，从下到上看，一个 y 单调多边形总是可以划分成左链（左侧一系列连续顶点）和右链（右侧一系列连续顶点）两条明显的边链。</li></ul><p>📌 为什么 y 单调多边形容易进行三角剖分？</p><ol><li><strong>明确的上下结构</strong>：<ul><li>由于 y 单调多边形天然具备上下层次结构，我们可以从最低点向最高点逐一扫描，始终能清楚地知道当前顶点与前面哪些顶点连线可以构成有效的三角形。</li></ul></li><li><strong>容易的顶点排序</strong>：<ul><li>对 y 单调多边形顶点进行 y 坐标排序即可轻松获得扫描次序，这种排序仅需 O (n)。</li></ul></li><li><strong>更易维护数据结构</strong>：<ul><li>在扫描的过程中，使用一个栈结构即可轻松维护潜在的 “对角线连接点”，因此每个顶点只需常数或接近常数次处理操作，总复杂度为 O (n)。</li></ul></li></ol><h2 id="二-扫线算法sweep-line-algorithm"><a class="anchor" href="#二-扫线算法sweep-line-algorithm">#</a> 二、扫线算法（Sweep Line Algorithm）</h2><h3 id="1-用扫线算法解决区间深度问题"><a class="anchor" href="#1-用扫线算法解决区间深度问题">#</a> 1. 用扫线算法解决区间深度问题</h3><p>#TODO 添加区间深度示意图</p><h4 id="算法步骤详解"><a class="anchor" href="#算法步骤详解">#</a> 🚩 算法步骤详解：</h4><p>第一步：</p><ul><li><strong>将所有区间的端点从左到右排序（总共 2n 个端点）</strong><br>复杂度为 O (nlog⁡n) 因为需要排序。</li></ul><p>第二步：初始化</p><ul><li><code>currentDepth</code> ：当前扫描位置的区间重叠数，初始值为 0。</li><li><code>maxDepth</code> ：扫描过程中的最大深度，初始值为 0。</li></ul><p>第三步：扫描所有端点<br>从左向右依次扫描所有端点（共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> 个端点），每个点分别是区间的左端点或右端点：</p><ul><li>当扫描线经过一个区间<strong>左端点</strong>时：<ul><li>表明扫描进入一个新的区间，因此 <code>currentDepth++</code> 。</li><li>如果 <code>currentDepth</code> 超过了 <code>maxDepth</code> ，更新 <code>maxDepth</code> 。</li></ul></li><li>当扫描到一个右端点时：<ul><li>表明离开了某个区间，因此 <code>currentDepth--</code> 。<br>循环的总复杂度为 O (n) O (n) O (n)，因为只需遍历一遍所有端点（共 2n2n2n 个）。</li></ul></li></ul><hr><h4 id="总体复杂度分析"><a class="anchor" href="#总体复杂度分析">#</a> 📌 总体复杂度分析：</h4><ul><li>排序步骤：$$O (n \log n)$$</li><li>循环计算：遍历所有端点，共有 2n 个端点，因此为 O (n)。</li></ul><p>最终算法复杂度为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n) + O(n) = O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><h3 id="2线段相交问题segment-intersection"><a class="anchor" href="#2线段相交问题segment-intersection">#</a> 2. 线段相交问题（Segment Intersection）</h3><h4 id="什么是segment-intersection问题"><a class="anchor" href="#什么是segment-intersection问题">#</a> 🌟 什么是 Segment Intersection 问题？</h4><p>给你平面上 n 条线段，要求：</p><ul><li>判断这些线段中<strong>是否存在两条相交</strong>（Intersection Detection）。</li><li>或者报告出<strong>所有相交线段对</strong>（Intersection Reporting）。</li></ul><p>最直接的做法（暴力算法）需要检查每对线段组合，复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><hr><h4 id="扫描线sweep-line方法介绍"><a class="anchor" href="#扫描线sweep-line方法介绍">#</a> 🚩 扫描线（Sweep Line）方法介绍：</h4><p>为了高效地解决上述问题，通常使用<strong>扫描线技术</strong>：</p><ul><li>从左到右移动一条垂直的虚拟 “扫描线”。</li><li>当扫描线移动时，我们记录并维护与它相交的线段（线段状态）。</li><li>在扫描线移动过程中，只需要考虑那些可能相邻的线段是否相交，显著减少检查次数。</li></ul><hr><h4 id="扫描线算法具体步骤"><a class="anchor" href="#扫描线算法具体步骤">#</a> 🎯 扫描线算法具体步骤：</h4><p>步骤 1：初始化状态</p><ul><li>将线段的所有端点按照 x 坐标从左到右排序，作为事件点（Event points）。</li></ul><p>步骤 2：维护两个关键数据结构：</p><ul><li><strong>事件队列（Event Queue）</strong>：<ul><li>存储所有事件（如线段起点、终点），按照 x 坐标排序。</li></ul></li><li><strong>扫描线状态（Sweep line status）</strong>：<ul><li>维护当前与扫描线相交的所有线段。</li><li>使用二叉搜索树（BST）来实现高效插入和删除，复杂度为 O (log⁡n)</li></ul></li></ul><hr><h4 id="️-算法步骤和复杂度分析detection"><a class="anchor" href="#️-算法步骤和复杂度分析detection">#</a> ⚙️ 算法步骤和复杂度分析（Detection）：</h4><ul><li>每当遇到一个事件（端点）：<ul><li>如果是线段的起点，就加入 BST，并检查它与相邻线段是否相交。</li><li>如果是线段终点，就从 BST 删除，并检查新的邻居线段是否相交。</li></ul></li></ul><p>因为每次插入、删除都要做常数次的邻居相交检测，而插入和删除的操作都是 O (log⁡n)，所以整体复杂度为：</p><ul><li>Intersection Detection: $$O(n \log n)$$</li><li>Intersection Reporting: $$O (n \log n + h \log n)$$，其中 h 为相交线段对数。</li></ul><hr><h4 id="️-为什么比暴力方法更高效"><a class="anchor" href="#️-为什么比暴力方法更高效">#</a> 🖼️ 为什么比暴力方法更高效？</h4><ul><li><strong>暴力算法</strong>：每对线段检查一次相交情况，复杂度为 O (n^2)</li><li>扫描线算法：利用状态维护和邻居线段关系，快速定位可能相交的线段，大大提高效率至 O (n log n)（对于检测），以及 O (nlog⁡n+hlog⁡n) 对于报告，其中 h 为相交线段对数）。</li></ul><h4 id="算法实现"><a class="anchor" href="#算法实现">#</a> 算法实现</h4><p>🚩 算法（线段相交检测）核心步骤：</p><p>使用扫描线法来判断一组线段是否存在相交：</p><ol><li><p><strong>数据结构（T）：</strong></p><ul><li>扫描线从左向右移动，使用平衡二叉搜索树（Balanced Binary Search Tree，简称 BST）来维护扫描线当前所相交线段的顺序。</li></ul></li><li><p><strong>删除线段时</strong>：</p><ul><li>当扫描线从左到右经过线段的右端点（结束端点），需要将该线段从树中删除。</li><li>此时，被删除线段原本相邻的两条线段在删除后会变成新的相邻线段，因此只需检查这两个线段是否相交。</li></ul></li><li><p><strong>插入线段时</strong>：</p><ul><li>当扫描线遇到新的线段（左端点）时，要插入树中。</li><li>插入线段时，新线段与树中原有的两个线段变为相邻关系。只需检查新线段与这两个线段是否相交即可。</li></ul></li><li><p><strong>发现相交时</strong>：</p><ul><li>如果发现任何相交，立即停止，可以报告存在相交情况。</li></ul></li></ol><hr><p>📌 时间复杂度分析：</p><p>扫描线算法中事件总数最多为 2n（每条线段有两个端点），处理每个事件包括：</p><ul><li>在树 T 中插入或删除一条线段需要 O (log⁡n) 时间。</li><li>每次插入或删除操作都会检查最多两个邻居线段，因此每次操作的复杂度也是 O (log⁡n)</li></ul><p>因此，总体复杂度：</p><ul><li>每个端点处理一次，总共 2n 个端点。</li><li>每次处理复杂度为 O (log⁡n)</li><li>整体复杂度：O (nlog⁡n)</li></ul><h2 id="三-平面扫描解决三角剖分问题"><a class="anchor" href="#三-平面扫描解决三角剖分问题">#</a> 三、平面扫描解决三角剖分问题</h2><h4 id="第一步划分成y单调多边形"><a class="anchor" href="#第一步划分成y单调多边形">#</a> 🚩 <strong>第一步：划分成 y 单调多边形</strong></h4><p>先将复杂的多边形划分为更易处理的 y 单调多边形：</p><ul><li><strong>定义</strong>：<ul><li>一个 y 单调多边形（y-monotone polygon）是指<strong>任意一条水平线（垂直于 y 轴）与该多边形相交的部分始终是单连通的</strong>（连续的）。</li></ul></li></ul><h5 id="划分方法plane-sweep方法"><a class="anchor" href="#划分方法plane-sweep方法">#</a> 划分方法（Plane Sweep 方法）：</h5><ul><li>从上向下（或从下向上）移动扫描线，按 y 坐标顺序扫描多边形的所有顶点。</li><li>在扫描过程中识别不同的顶点类型：<ul><li><strong>起始顶点（start vertex）</strong></li><li><strong>终止顶点（end vertex）</strong></li><li><strong>分裂顶点（split vertex）</strong></li><li><strong>合并顶点（merge vertex）</strong></li></ul></li><li>当遇到导致 y 单调性被破坏的 “分裂顶点” 和 “合并顶点” 时，<strong>增加适当的对角线</strong>，从而将多边形划分成一系列的 y 单调多边形。</li><li>扫描线的状态用平衡二叉搜索树维护，以确保高效地找到每个顶点的邻接关系，复杂度为 <strong>O(n log n)</strong>。</li></ul><hr><h4 id="第二步y单调多边形的三角剖分过程具体步骤"><a class="anchor" href="#第二步y单调多边形的三角剖分过程具体步骤">#</a> 🚩 <strong>第二步：y 单调多边形的三角剖分过程（具体步骤）</strong></h4><ol><li>对 y 单调多边形的所有顶点按照 y 坐标从下往上排序。</li><li>依次遍历排序后的顶点序列，利用一个栈：<ul><li>如果新顶点与栈顶顶点属于不同链，则连接栈中所有顶点（除最后一个）形成新三角形，然后更新栈。</li><li>如果新顶点和栈顶元素位于同一链上，则弹出栈顶元素，并依次检查和弹出能够和当前顶点构成有效对角线的顶点，加入新的对角线。</li></ul></li><li>重复直到所有顶点处理完成，即完成三角剖分。</li></ol></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-06-03 08:26:45" itemprop="dateModified" datetime="2025-06-03T08:26:45+08:00">2025-06-03</time> </span><span id="2025/03/16/computer/ComputationalGeometry/lec2 SweepLine/" class="item leancloud_visitors" data-flag-title="lec2 SweepLine" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="IRON 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="IRON 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="IRON 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>IRON <i class="ic i-at"><em>@</em></i>杂项笔记</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2025/03/16/computer/ComputationalGeometry/lec2%20SweepLine/" title="lec2 SweepLine">http://example.com/2025/03/16/computer/ComputationalGeometry/lec2 SweepLine/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2025/03/16/computer/ComputationalGeometry/lec1%20%E8%89%BA%E6%9C%AF%E7%94%BB%E5%BB%8A%E9%97%AE%E9%A2%98(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%89%88/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;dlink.host&#x2F;wx4.sinaimg.cn&#x2F;large&#x2F;006Tzddnly8htqg1pgsrij30sg0sgtdo.jpg" title="lec1 介绍(个人总结版)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 随机算法</span><h3>lec1 介绍(个人总结版)</h3></a></div><div class="item right"><a href="/2025/03/27/computer/ComputationalGeometry/lec4%20Linear%20Programming/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;dlink.host&#x2F;wx2.sinaimg.cn&#x2F;large&#x2F;006Tzddnly8htqg0x2lhcg3074074e7q.gif" title="lec4 Linear Programming"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 计算几何</span><h3>lec4 Linear Programming</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86polygon-triangulation"><span class="toc-number">1.</span> <span class="toc-text">一、多边形的三角剖分（Polygon Triangulation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%951"><span class="toc-number">1.1.</span> <span class="toc-text">1. 算法 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">📌算法复杂度分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%952%E8%80%B3%E5%88%87%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">2. 算法 2 (耳切法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">📌 算法复杂度分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%AE%97%E6%B3%953%E6%94%B9%E8%BF%9B%E7%9A%84%E8%80%B3%E5%88%87%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">3. 算法 3（改进的耳切法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">1.3.1.</span> <span class="toc-text">📌 算法复杂度分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%954"><span class="toc-number">1.4.</span> <span class="toc-text">4. 算法 4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E8%B0%83%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%9B%B4%E5%AE%B9%E6%98%93%E5%89%96%E5%88%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">为什么单调多边形更容易剖分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%89%AB%E7%BA%BF%E7%AE%97%E6%B3%95sweep-line-algorithm"><span class="toc-number">2.</span> <span class="toc-text">二、扫线算法（Sweep Line Algorithm）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%89%AB%E7%BA%BF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">1. 用扫线算法解决区间深度问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.1.1.</span> <span class="toc-text">🚩 算法步骤详解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">📌 总体复杂度分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98segment-intersection"><span class="toc-number">2.2.</span> <span class="toc-text">2. 线段相交问题（Segment Intersection）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFsegment-intersection%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">🌟 什么是 Segment Intersection 问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%BA%BFsweep-line%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.2.</span> <span class="toc-text">🚩 扫描线（Sweep Line）方法介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.2.3.</span> <span class="toc-text">🎯 扫描线算法具体步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%B8%8F-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4%E5%92%8C%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90detection"><span class="toc-number">2.2.4.</span> <span class="toc-text">⚙️ 算法步骤和复杂度分析（Detection）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%B8%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E6%9A%B4%E5%8A%9B%E6%96%B9%E6%B3%95%E6%9B%B4%E9%AB%98%E6%95%88"><span class="toc-number">2.2.5.</span> <span class="toc-text">🖼️ 为什么比暴力方法更高效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.6.</span> <span class="toc-text">算法实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%B9%B3%E9%9D%A2%E6%89%AB%E6%8F%8F%E8%A7%A3%E5%86%B3%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">三、平面扫描解决三角剖分问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%88%92%E5%88%86%E6%88%90y%E5%8D%95%E8%B0%83%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="toc-number">3.0.1.</span> <span class="toc-text">🚩 第一步：划分成 y 单调多边形</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95plane-sweep%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">划分方法（Plane Sweep 方法）：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5y%E5%8D%95%E8%B0%83%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E8%BF%87%E7%A8%8B%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.0.2.</span> <span class="toc-text">🚩 第二步：y 单调多边形的三角剖分过程（具体步骤）</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2025/03/16/computer/ComputationalGeometry/lec2%20SweepLine/" rel="bookmark" title="lec2 SweepLine">lec2 SweepLine</a></li><li><a href="/2025/03/27/computer/ComputationalGeometry/lec4%20Linear%20Programming/" rel="bookmark" title="lec4 Linear Programming">lec4 Linear Programming</a></li><li><a href="/2025/05/06/computer/ComputationalGeometry/lec7%20Voronoi%20Diagram/" rel="bookmark" title="lec7 Voronoi Diagram">lec7 Voronoi Diagram</a></li><li><a href="/2025/05/24/computer/ComputationalGeometry/lec8%20Arrangements%20and%20Duality/" rel="bookmark" title="lec8 Arrangements and Duality">lec8 Arrangements and Duality</a></li><li><a href="/2025/05/24/computer/ComputationalGeometry/lec7%20Voronoi%20Diagram%20-%20%E5%89%AF%E6%9C%AC%20(2)/" rel="bookmark" title="lec7 Voronoi Diagram">lec7 Voronoi Diagram</a></li><li><a href="/2025/05/24/computer/ComputationalGeometry/lec9%20Planar%20Point%20Location/" rel="bookmark" title="lec9 Planar Point Location">lec9 Planar Point Location</a></li><li><a href="/2025/05/25/computer/ComputationalGeometry/lec10%20%E5%87%A0%E4%BD%95%E9%80%BC%E8%BF%91%E7%AE%97%E6%B3%95(Geometric%20approximation%20algorithms)/" rel="bookmark" title="lec10 几何逼近算法 (Geometric approximation algorithms)">lec10 几何逼近算法 (Geometric approximation algorithms)</a></li><li><a href="/2025/05/25/computer/ComputationalGeometry/lec11%20Similarity%20and%20Simplification/" rel="bookmark" title="lec11 Similarity and Simplification">lec11 Similarity and Simplification</a></li><li><a href="/2025/05/27/computer/ComputationalGeometry/lec9%20Planar%20Point%20Location%20%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%B7%AF%E7%89%88/" rel="bookmark" title="lec9 Planar Point Location">lec9 Planar Point Location</a></li><li><a href="/2025/05/27/computer/ComputationalGeometry/lec9%20%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90%E9%83%A8%E5%88%86/" rel="bookmark" title="lec11">lec11</a></li><li><a href="/2025/05/27/computer/ComputationalGeometry/%E4%B8%80%E4%BA%9B%E6%B2%A1%E5%81%9A%E7%9A%84%E9%A2%98/" rel="bookmark" title="lec11">lec11</a></li><li><a href="/2025/05/27/computer/ComputationalGeometry/lec10%20%E5%87%A0%E4%BD%95%E9%80%BC%E8%BF%91%E7%AE%97%E6%B3%95(Geometric%20approximation%20algorithms)%20%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%89%88/" rel="bookmark" title="lec10 几何逼近算法 (Geometric approximation algorithms) 个人总结版">lec10 几何逼近算法 (Geometric approximation algorithms) 个人总结版</a></li><li><a href="/2025/05/27/computer/ComputationalGeometry/%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9A%84%E7%9F%A5%E8%AF%86/" rel="bookmark" title="一些基础的知识">一些基础的知识</a></li><li><a href="/2025/05/27/computer/ComputationalGeometry/lec11%20Similarity%20and%20Simplification%EF%BC%88%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%89%88%EF%BC%89/" rel="bookmark" title="lec11 Similarity and Simplification(个人总结版)">lec11 Similarity and Simplification(个人总结版)</a></li><li><a href="/2025/06/03/computer/ComputationalGeometry/lec3%20Convex%20hulls%20and%20the%20sweepline%20technique/" rel="bookmark" title="lec3 Convex hulls and the sweepline technique">lec3 Convex hulls and the sweepline technique</a></li><li><a href="/2025/06/07/computer/ComputationalGeometry/lec4%20Linear%20Programmin(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%89%88)/" rel="bookmark" title="lec4 Linear Programming(个人总结版)">lec4 Linear Programming(个人总结版)</a></li><li><a href="/2025/06/12/computer/ComputationalGeometry/lec5%20Range%20Searching%201/" rel="bookmark" title="lec5 Range Searching 1">lec5 Range Searching 1</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="IRON" data-src="/images/avatar.jpg"><p class="name" itemprop="name">IRON</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">125</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">20</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTU1MDgyNDI1Nw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;550824257"><i class="ic i-cloud-music"></i></span> <a href="/zhouy6577@gmail.com" title="zhouy6577@gmail.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>主页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2025/03/16/computer/ComputationalGeometry/lec1%20%E8%89%BA%E6%9C%AF%E7%94%BB%E5%BB%8A%E9%97%AE%E9%A2%98(%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%89%88/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2025/03/27/computer/ComputationalGeometry/lec4%20Linear%20Programming/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/2024/03/01/computer/front/JavaScript/1%E3%80%81JavaScript%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%A4%A9/" title="JavaScript01">JavaScript01</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/prattle/" title="分类于 杂谈">杂谈</a></div><span><a href="/2024/03/01/computer/front/prattle/1.vue%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6/" title="vue全局事件">vue全局事件</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/node/" title="分类于 node">node</a></div><span><a href="/2024/10/01/computer/front/node/hello-world%20-%20%E5%89%AF%E6%9C%AC/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于 游戏引擎">游戏引擎</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/" title="分类于 unity">unity</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/unityBasics/" title="分类于 unity基础">unity基础</a></div><span><a href="/2024/11/10/game-engine/unity/unityBasics/%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F/" title="摄像机跟随">摄像机跟随</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/networks/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/2024/09/19/computer/networks/network_lec_6/" title="lecture_6Network Layer 3">lecture_6Network Layer 3</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/2024/10/01/computer/front/JavaScript/js%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/" title="js代理机制">js代理机制</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/2024/03/01/computer/front/JavaScript/4%E3%80%81JavaScript%E5%9F%BA%E7%A1%80%E7%AC%AC%E5%9B%9B%E5%A4%A9/" title="JavaScript04">JavaScript04</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/ComputationalGeometry/" title="分类于 计算几何">计算几何</a></div><span><a href="/2025/05/27/computer/ComputationalGeometry/lec9%20%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90%E9%83%A8%E5%88%86/" title="lec11">lec11</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/09/17/temeplete/temeplete1/" title="wwwww">wwwww</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/prattle/" title="分类于 杂谈">杂谈</a></div><span><a href="/2024/03/01/computer/front/prattle/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">IRON @ IRON</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/03/16/computer/ComputationalGeometry/lec2 SweepLine/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->
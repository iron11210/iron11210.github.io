<!-- build time:Wed Mar 05 2025 20:33:17 GMT+1100 (澳大利亚东部夏令时间) --><!DOCTYPE html><script async src="https://www.googletagmanager.com/gtag/js?id=G-DPVE7Y0QX9"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-DPVE7Y0QX9")</script><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="杂项笔记" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="杂项笔记" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="杂项笔记" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/2024/11/03/computer/database/lec11%20Storage%20and%20Indexing/"><title>lec_11 Storage and Indexing - 数据库 - 计算机科学 | IRON = 杂项笔记</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">lec_11 Storage and Indexing</h1><div class="meta"><span class="item" title="创建时间：2024-11-03 14:43:43"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-11-03T14:43:43+08:00">2024-11-03</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">IRON</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://dlink.host/wx2.sinaimg.cn/large/006Tzddnly8htqg1keshmj30sg0sgjvu.jpg"></li><li class="item" data-background-image="https://dlink.host/wx1.sinaimg.cn/large/006Tzddnly8htqg0l4jv0j30sg0sgjuv.jpg"></li><li class="item" data-background-image="https://dlink.host/wx2.sinaimg.cn/large/006Tzddnly8htqg0x2lhcg3074074e7q.gif"></li><li class="item" data-background-image="https://dlink.host/wx3.sinaimg.cn/large/006Tzddnly8htqg1arfzvj30sg0sg0x7.jpg"></li><li class="item" data-background-image="https://dlink.host/wx4.sinaimg.cn/large/006Tzddnly8htpyghxhuvg30b40b41jo.gif"></li><li class="item" data-background-image="https://dlink.host/wx4.sinaimg.cn/large/006Tzddnly8htqg1pgsrij30sg0sgtdo.jpg"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer/database/" itemprop="item" rel="index" title="分类于 数据库"><span itemprop="name">数据库</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/computer/database/lec11%20Storage%20and%20Indexing/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="IRON"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="杂项笔记"></span><div class="body md" itemprop="articleBody"><h2 id="物理存储数据"><a class="anchor" href="#物理存储数据">#</a> 物理存储数据</h2><h3 id="1-存储设备对比"><a class="anchor" href="#1-存储设备对比">#</a> 1. <strong>存储设备对比</strong></h3><ul><li>比较了硬盘（HDD）和内存（RAM）的特点：<ul><li><strong>硬盘</strong>：容量大、价格低、永久存储，但访问速度较慢。</li><li><strong>内存</strong>：速度快、支持随机访问，但存储成本高且数据易失​。</li></ul></li></ul><h3 id="2-数据块和缓冲管理"><a class="anchor" href="#2-数据块和缓冲管理">#</a> 2. <strong>数据块和缓冲管理</strong></h3><ul><li>数据在硬盘上按 “块”（blocks）组织，每个块为固定大小（通常为 4KB 或 8KB），块是数据传输的基本单位。</li><li><strong>缓冲管理器</strong>负责将数据块加载到内存，并在内存满时使用替换算法决定保留哪些数据块。常用的替换算法包括 **LRU（最近最少使用）<strong>和</strong> MRU（最近最多使用）**​。</li></ul><h4 id="21-数据块blocks"><a class="anchor" href="#21-数据块blocks">#</a> 2.1 <strong>数据块（Blocks）</strong></h4><ul><li>数据库中的数据通常存储在磁盘上，并按 “块”（block）为单位进行管理。数据块是操作系统在磁盘和内存之间传输数据的基本单位。</li><li><strong>块大小</strong>一般为 4KB 或 8KB，具体取决于操作系统和硬件配置。块的大小会影响 I/O 操作的效率：较大的块可以减少读取大文件时的 I/O 次数，但可能会增加小文件的空间浪费​。</li><li><strong>块因素（Blocking Factor）</strong>：这是块大小与记录大小的比率，决定了一个数据块中可以容纳多少条记录。如果记录较大，可能需要多个块来存储一条记录，这种情况称为 “记录跨块”（record spanning）。跨块存储会增加 I/O 复杂度，通常需要避免​。</li></ul><h4 id="22-缓冲区buffer和缓冲管理器buffer-manager"><a class="anchor" href="#22-缓冲区buffer和缓冲管理器buffer-manager">#</a> 2.2 <strong>缓冲区（Buffer）和缓冲管理器（Buffer Manager）</strong></h4><ul><li><strong>缓冲区</strong>是数据库系统在内存中保留的一块区域，用于暂存从磁盘加载的块。由于内存的访问速度比磁盘快得多，将数据块缓存在内存中可以显著提升查询速度。</li><li><strong>缓冲管理器</strong>负责管理这些缓冲区块，主要任务包括：<ul><li><strong>块的加载和释放</strong>：根据需求从磁盘加载块到内存缓冲区，释放不再使用的块。</li><li><strong>块替换策略</strong>：当内存缓冲区已满且需要加载新块时，选择要被替换的块。</li></ul></li></ul><h4 id="23-块替换策略"><a class="anchor" href="#23-块替换策略">#</a> 2.3 <strong>块替换策略</strong></h4><ul><li>数据库系统通常使用以下常见的替换算法来优化内存利用率：<ul><li><strong>LRU（Least Recently Used，最近最少使用）</strong>：优先替换最久未使用的块，适用于访问数据呈局部性特征的情况。</li><li><strong>MRU（Most Recently Used，最近最多使用）</strong>：优先替换最近使用的块，适用于某些需要频繁访问相同数据块的情况，如嵌套循环连接操作​。</li></ul></li><li>这些替换策略帮助缓冲管理器在内存中保留最可能被再次访问的块，从而减少频繁的 I/O 操作，提高查询性能。</li></ul><h4 id="24-缓冲区示例"><a class="anchor" href="#24-缓冲区示例">#</a> 2.4 <strong>缓冲区示例</strong></h4><ul><li>通过一个连接操作的示例说明了如何选择替换策略：<ul><li>假设执行的是一个嵌套循环连接，内表的块可能需要频繁访问，因此在这种情况下使用 MRU 策略会更有效，因为最近访问的块很快会再次被访问。</li><li>通过合理的缓冲区管理和替换策略，可以显著减少 I/O 操作次数，从而提高查询效率​。</li></ul></li></ul><h4 id="25-缓冲管理的重要性"><a class="anchor" href="#25-缓冲管理的重要性">#</a> 2.5 <strong>缓冲管理的重要性</strong></h4><ul><li>由于数据库通常远大于内存容量，无法将所有数据同时存储在内存中，因此需要有效的缓冲管理。</li><li>缓冲管理的目标是通过智能的块加载和替换策略，将最常用的数据保留在内存中，以最小化磁盘访问次数，从而优化数据库系统的整体性能。</li></ul><h3 id="3-存储示例和填充因子fill-factor"><a class="anchor" href="#3-存储示例和填充因子fill-factor">#</a> 3. <strong>存储示例和填充因子（Fill Factor）</strong></h3><ul><li>举例说明了数据表中记录如何分布在数据块中。假设每条记录 200 字节，每页可容纳 19 条记录，因此需要 105,264 个数据页来存储共 2,000,000 条记录​。</li><li>填充因子（Fill Factor）用于决定每个数据页中预留多少空间，以便在新数据插入时无需频繁分裂页面。</li></ul><h4 id="31-存储示例"><a class="anchor" href="#31-存储示例">#</a> 3.1 <strong>存储示例</strong></h4><ul><li>数据库表以固定大小的页面（page）形式存储，每个页面通常为 4KB。页面用于存储表中的多条记录。</li><li>示例假设：<ul><li>表 <code>Relation</code> 包含 2,000,000 条记录，每条记录大小为 200 字节。</li><li>每个页面大小为 4KB，其中 250 字节用于页面头部和记录指针数组，其余 3,846 字节用于实际数据存储​。</li></ul></li><li><strong>每页存储的记录数</strong>：<ul><li>每条记录为 200 字节，因此每页可以容纳的记录数为： 记录数 =⌊3846 字节 200 字节 / 记录⌋=19 条记录 \text {记录数} = \left\lfloor \frac {3846 \text { 字节}}{200 \text { 字节 / 记录}} \right\rfloor = 19 \text { 条记录} 记录数 =⌊200 字节 / 记录 3846 字节​⌋=19 条记录</li><li>因此，总共需要约 105,264 个页面来存储全部记录​。</li></ul></li></ul><h4 id="32-填充因子fill-factor"><a class="anchor" href="#32-填充因子fill-factor">#</a> 3.2 <strong>填充因子（Fill Factor）</strong></h4><ul><li><strong>定义</strong>：填充因子决定了每个页面用于存储数据的空间百分比。设定较低的填充因子会在页面中预留一定的空闲空间，便于后续插入新数据。</li><li><strong>作用</strong>：通过保留空闲空间，填充因子减少了页面分裂的频率，有助于提高索引的维护效率。通常数据库在创建索引或存储页面时可以设置填充因子的值，如 80% 或 75%。</li><li><strong>计算示例</strong>：<ul><li>若填充因子设置为 75%，则每页仅填充 3/4 的数据： 19 条记录 ×75%=14 条记录 / 页（取整后）19 \text {条记录} \times 75% = 14 \text { 条记录 / 页（取整后）} 19 条记录 ×75%=14 条记录 / 页（取整后）</li><li>在这种情况下，需要的页面数增加到 142,858 页，以满足较低填充因子下的存储需求，这也会带来额外的存储开销​。</li></ul></li></ul><h4 id="33-填充因子的影响"><a class="anchor" href="#33-填充因子的影响">#</a> 3.3 <strong>填充因子的影响</strong></h4><ul><li><strong>性能优化</strong>：较低的填充因子提高了插入新数据的灵活性，减少了频繁页面分裂的开销，适合需要大量插入操作的场景。</li><li><strong>空间开销</strong>：虽然较低的填充因子带来额外的存储开销，但它能显著减少页面分裂的次数，从而提高系统的整体性能。</li><li>示例中，设置填充因子为 75% 带来了 47% 的额外存储开销。这种设计通常用于索引页面，以保证索引更新时的效率​。</li></ul><h3 id="4-典型文件组织方式"><a class="anchor" href="#4-典型文件组织方式">#</a> 4 <strong>典型文件组织方式</strong></h3><ul><li><strong>堆文件（Heap Files）</strong>：无序存储，适用于全表扫描，插入和删除开销较小。</li><li><strong>排序文件（Sorted Files）</strong>：按键值排序，适合二分查找，但插入和更新成本较高。</li><li><strong>索引文件（Index Files）</strong>：利用索引（如 B + 树或哈希索引）来提升数据访问速度​。</li></ul><h4 id="41-无序文件heap-files"><a class="anchor" href="#41-无序文件heap-files">#</a> 4.1 <strong>无序文件（Heap Files）</strong></h4><ul><li><strong>定义</strong>：无序文件将记录以随机顺序存储在可用空间中，不对数据进行任何排序。</li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：插入和删除操作快速简单，因为无需重新排列数据。</li><li><strong>缺点</strong>：在没有索引的情况下，查询需要扫描整个表（即线性扫描），查询效率较低。</li></ul></li><li><strong>适用场景</strong>：适合需要频繁插入和删除数据的表，特别是需要全表扫描的场景，如日志记录和历史数据存储​。</li></ul><h4 id="42-排序文件sorted-files"><a class="anchor" href="#42-排序文件sorted-files">#</a> 4.2 <strong>排序文件（Sorted Files）</strong></h4><ul><li><strong>定义</strong>：排序文件按特定的搜索键（search key）对记录进行排序存储。</li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：对等值查询和范围查询非常高效，支持二分查找，从而减少了 I/O 操作。</li><li><strong>缺点</strong>：插入和删除操作代价较高，因为插入新记录或删除记录后需要保持数据的排序。</li></ul></li><li><strong>适用场景</strong>：适合数据更新较少、查询频繁的场景，例如数据仓库或查询量大的报表数据​。</li></ul><h4 id="43-索引文件index-files"><a class="anchor" href="#43-索引文件index-files">#</a> 4.3 <strong>索引文件（Index Files）</strong></h4><ul><li><strong>定义</strong>：索引文件在特定字段上建立数据结构（如 B + 树或哈希表），用于加速数据检索。</li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：索引能够显著提高查询效率，尤其适用于等值查询和范围查询（如 B + 树索引）。此外，索引通常存储在独立的页面中，并与数据页分开。</li><li><strong>缺点</strong>：需要额外的存储空间来存放索引页；每次数据插入、删除或更新时，索引页也需要更新，带来额外的 I/O 开销。</li></ul></li><li><strong>典型索引类型</strong>：<ul><li><strong>哈希索引</strong>：适合等值查询，不支持范围查询。</li><li><strong>B + 树索引</strong>：既支持等值查询，也支持范围查询，是关系型数据库中常用的索引结构​。</li></ul></li></ul><h4 id="44-文件组织方式的比较"><a class="anchor" href="#44-文件组织方式的比较">#</a> 4.4 <strong>文件组织方式的比较</strong></h4><ul><li><strong>无序文件</strong>在插入和删除操作中速度较快，但查询效率较低。</li><li><strong>排序文件</strong>在范围查询和等值查询上较高效，但插入和删除操作较慢。</li><li><strong>索引文件</strong>通过额外的索引结构在查询上具有显著优势，但维护索引需要额外的 I/O 开销和存储空间。</li></ul><h4 id="45-适用性总结"><a class="anchor" href="#45-适用性总结">#</a> 4.5 <strong>适用性总结</strong></h4><ul><li><strong>无序文件</strong>适合高频插入和删除且不要求快速查询的场景。</li><li><strong>排序文件</strong>适合更新较少且需要高效范围查询的场景。</li><li><strong>索引文件</strong>是最常用的方式，通过索引结构显著提升查询效率，尤其适合查询频繁的业务表​。</li></ul><h2 id="如何从-dbms-中检索记录"><a class="anchor" href="#如何从-dbms-中检索记录">#</a> 如何从 DBMS 中检索记录</h2><h3 id="1-访问路径access-paths"><a class="anchor" href="#1-访问路径access-paths">#</a> 1. 访问路径（Access Paths）</h3><ul><li><strong>定义</strong>：访问路径是一种用于检索记录的方法，包括用于检索和存储表中记录的数据结构（如索引）和算法。</li><li><strong>三种访问方法</strong>：<ul><li><strong>线性扫描</strong>：适用于无序（Heap）文件，对所有记录逐一检查。</li><li><strong>二分查找</strong>：适用于排序文件，I/O 成本较低，可快速找到目标记录。</li><li><strong>索引扫描</strong>：使用索引可以直接定位记录，效率高​。</li></ul></li></ul><h3 id="2-物理数据独立性physical-data-independence"><a class="anchor" href="#2-物理数据独立性physical-data-independence">#</a> 2. 物理数据独立性（Physical Data Independence）</h3><ul><li><strong>定义</strong>：选择访问路径的方式不会影响 SQL 语句的语义，但可能对执行时间有很大影响。</li><li>物理数据独立性确保了查询语句与底层存储结构的独立性​。</li></ul><h3 id="3-无序文件的访问方法"><a class="anchor" href="#3-无序文件的访问方法">#</a> 3. 无序文件的访问方法</h3><ul><li><strong>特点</strong>：无序文件的记录没有特定的顺序。</li><li><strong>访问方法</strong>：通常通过线性扫描实现，每次检查一个页面中的所有记录。</li><li><strong>性能</strong>：平均情况下需要读取一半页面，最坏情况下需要读取整个文件​。</li></ul><h3 id="4-线性扫描的io成本示例"><a class="anchor" href="#4-线性扫描的io成本示例">#</a> 4. 线性扫描的 I/O 成本示例</h3><ul><li>假设表有 140,351 个页面，用于查询一个唯一的 <code>tuplekey</code> ：</li></ul><h4 id="等值查询equality-search"><a class="anchor" href="#等值查询equality-search">#</a> 等值查询（Equality Search）</h4><ul><li>如果 <code>tuplekey</code> 是<strong>唯一的</strong>，一旦找到匹配记录可以立刻终止。</li><li>平均情况下，需要检查约一半的页面，因为匹配记录可能位于任意位置。I/O 成本大约为： 140,3512≈70,176 次 I/O\frac {140,351}{2} \approx 70,176 \text { 次 I/O} 2140,351​≈70,176 次 I/O</li><li><strong>最坏情况</strong>：如果没有匹配记录或 <code>tuplekey</code> 不是唯一的，则需要扫描所有 140,351 个页面，即需要 140,351 次 I/O 操作。</li></ul><h4 id="范围查询range-search"><a class="anchor" href="#范围查询range-search">#</a> 范围查询（Range Search）</h4><ul><li>例如，执行查询 <code>SELECT * FROM Relation WHERE attribute1 BETWEEN 100 AND 119;</code> 。</li><li>对于范围查询，由于无序文件中记录是随机存放的，因此无法提前结束扫描，需要检查每个页面中的每条记录。</li><li>这类查询通常会导致<strong>全表扫描</strong>，因此 I/O 成本为 140,351 次 I/O​。</li></ul><h3 id="5-排序文件的访问方法"><a class="anchor" href="#5-排序文件的访问方法">#</a> 5. 排序文件的访问方法</h3><ul><li><strong>排序文件</strong>：记录按某属性排序存储，适合频繁的等值和范围查询。</li><li><strong>二分查找</strong>：对于包含 140,351 个页面的表，最坏情况下 I/O 成本为 log⁡2140,351≈18\log_2 140,351 \approx 18log2​140,351≈18 次 I/O​。<br>&lt;二分查找图 -- 回家再上传&gt;</li></ul><h3 id="6-索引indexing"><a class="anchor" href="#6-索引indexing">#</a> 6. 索引（Indexing）</h3><ul><li><strong>定义</strong>：索引是一种数据结构，用于将搜索键值映射到记录集合。</li><li><strong>常见索引类型</strong>：<ul><li><strong>哈希索引</strong>：适合等值查询，但不支持范围查询。</li><li><strong>B + 树索引</strong>：支持等值和范围查询，适合关系型数据库。</li></ul></li><li><strong>缺点</strong>：索引需要额外的存储空间，并在表数据更新时带来维护开销，但总体上索引带来的查询性能提升大于这些缺点​。</li></ul><h2 id="b树"><a class="anchor" href="#b树">#</a> B + 树</h2><h3 id="1-b树的定义"><a class="anchor" href="#1-b树的定义">#</a> 1. B + 树的定义</h3><ul><li><strong>B + 树</strong>是一种自平衡的树形结构索引，用于在磁盘上组织和管理数据。</li><li>与 B 树不同，B + 树将所有数据都存储在叶子节点中，而内部节点仅用于存储键值和指针，以引导查询过程。</li><li><strong>叶子节点</strong>按键值顺序连接，形成一个链表，支持高效的范围查询。</li></ul><h3 id="2-b树的结构特点"><a class="anchor" href="#2-b树的结构特点">#</a> 2. B + 树的结构特点</h3><ul><li><strong>内部节点（Internal Nodes）</strong>：存储搜索键和指针，用于引导搜索过程，但不存储实际数据。</li><li><strong>叶子节点（Leaf Nodes）</strong>：存储所有数据条目，且按顺序链接，支持顺序访问。</li><li><strong>树的高度</strong>：B + 树的所有叶子节点在同一层，路径长度一致，使得树是平衡的。因此，在 B + 树中查找任意记录所需的 I/O 次数相同。</li></ul><h3 id="3-b树的构建过程"><a class="anchor" href="#3-b树的构建过程">#</a> 3. B + 树的构建过程</h3><ul><li><strong>索引条目</strong>：在每个记录页面生成一个索引条目，并将这些索引条目组织成 B + 树的内部结构。</li><li><strong>层次结构</strong>：构建 B + 树的多层结构，从叶子层到根节点逐层递归构建。</li><li><strong>填充因子（Fill Factor）</strong>：通常设置在 75% 左右，避免叶子节点过满，提高插入、删除的效率。</li></ul><h3 id="4-b树的查找过程"><a class="anchor" href="#4-b树的查找过程">#</a> 4. B + 树的查找过程</h3><ul><li><strong>等值查询（Equality Search）</strong>：<ol><li>从根节点开始，根据键值逐层向下查找，直到找到目标叶子节点。</li><li>在叶子节点中查找目标记录。</li></ol></li><li><strong>范围查询（Range Search）</strong>：<ol><li>通过等值查询找到范围的起始位置。</li><li>然后按顺序访问相邻的叶子节点，直到范围结束。</li></ol></li></ul><h3 id="5-b树的优点"><a class="anchor" href="#5-b树的优点">#</a> 5. B + 树的优点</h3><ul><li><strong>高效的等值查询和范围查询</strong>：B + 树结构保证了所有叶子节点的有序性，支持快速定位范围的起始位置。</li><li><strong>磁盘 I/O 效率高</strong>：B + 树通过多层结构减少了每次查询所需的 I/O 次数。在大数据集上，B + 树的层数较少，通常只需 3-4 次 I/O 即可找到目标记录。</li><li><strong>支持动态更新</strong>：插入和删除操作可以在 B + 树中高效执行，且不会影响其平衡性。</li></ul><h3 id="6-b树的劣势"><a class="anchor" href="#6-b树的劣势">#</a> 6. B + 树的劣势</h3><ul><li><strong>额外的存储开销</strong>：B + 树需要存储内部节点和叶子节点的指针，会占用额外的存储空间。</li><li><strong>维护成本</strong>：每当数据插入、删除时，B + 树需要保持平衡和顺序，带来一定的维护开销。</li></ul><h3 id="7-b树在数据库中的应用"><a class="anchor" href="#7-b树在数据库中的应用">#</a> 7. B + 树在数据库中的应用</h3><ul><li>B + 树常用于关系型数据库中的主键索引、唯一索引和范围索引。</li><li>它在查询优化中发挥关键作用，特别是在大规模数据集的等值查询和范围查询中，可以显著减少 I/O 操作次数。</li></ul><h3 id="8-举例"><a class="anchor" href="#8-举例">#</a> 8. 举例：</h3><h4 id="1-构建逻辑有序数据文件"><a class="anchor" href="#1-构建逻辑有序数据文件">#</a> 1. 构建逻辑有序数据文件</h4><ul><li>假设表 <code>Relation</code> 包含 140,351 个页面，每个页面中的记录按 <code>tuplekey</code> 逻辑排序。</li><li>页面内的记录按键值排序，但页面在磁盘上的存储位置可能并不连续。这种组织方式称为<strong>逻辑有序文件</strong>​。</li></ul><h4 id="2-为每个记录页面创建索引条目"><a class="anchor" href="#2-为每个记录页面创建索引条目">#</a> 2. 为每个记录页面创建索引条目</h4><ul><li>为数据文件中的每个页面创建一个索引条目，每个条目包含搜索键（ <code>tuplekey</code> ）和一个指向数据页面的指针 <code>rowid</code> 。</li><li>每个索引条目占用 8 字节（4 字节的键和 4 字节的指针），可以在 4KB 页面中存储最多 480 个索引条目​。</li></ul><h4 id="3-将索引条目装入页面"><a class="anchor" href="#3-将索引条目装入页面">#</a> 3. 将索引条目装入页面</h4><ul><li>假设页面的填充因子（即平均占用率）为 75%，则每个索引页面平均包含 360 个索引条目。</li><li>这样，索引层次中将需要 140,351 / 360 ≈ 390 个索引页面​。</li></ul><h4 id="4-构建b树索引"><a class="anchor" href="#4-构建b树索引">#</a> 4. 构建 B + 树索引</h4><ul><li>索引的下一层包含 390 个索引条目，即需要 2 个页面来存储这些条目。</li><li>根层包含 2 个索引条目，因此只需 1 个页面。</li><li>因此，B + 树索引的总页面数为 390 + 2 + 1 = 393 页，相对于数据表的大小仅增加了 0.2% 的存储​。</li></ul><h4 id="5-b树索引中的查找过程"><a class="anchor" href="#5-b树索引中的查找过程">#</a> 5. B + 树索引中的查找过程</h4><ul><li>例如，执行查询 <code>SELECT * FROM Relation WHERE tuplekey=715;</code> 时，可以按以下步骤查找：<ol><li>加载根页面到内存（1 次 I/O）。</li><li>找到下一级索引页面的位置并加载（1 次 I/O）。</li><li>重复直到找到叶子节点页面。</li><li>加载包含目标记录的叶子页面，并检查每条记录。</li></ol></li><li>总共约需 4 次 I/O，而无序文件中线性扫描的 I/O 成本可达 70,176 次​。</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-11-04 10:03:26" itemprop="dateModified" datetime="2024-11-04T10:03:26+08:00">2024-11-04</time> </span><span id="2024/11/03/computer/database/lec11 Storage and Indexing/" class="item leancloud_visitors" data-flag-title="lec_11 Storage and Indexing" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="IRON 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="IRON 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="IRON 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>IRON <i class="ic i-at"><em>@</em></i>杂项笔记</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2024/11/03/computer/database/lec11%20Storage%20and%20Indexing/" title="lec_11 Storage and Indexing">http://example.com/2024/11/03/computer/database/lec11 Storage and Indexing/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/11/03/computer/database/final%E5%A4%8D%E4%B9%A002/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;dlink.host&#x2F;wx1.sinaimg.cn&#x2F;large&#x2F;006Tzddnly8htqg0l4jv0j30sg0sgjuv.jpg" title="final复习02"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 数据库</span><h3>final复习02</h3></a></div><div class="item right"><a href="/2024/11/04/computer/database/lec12%20Query%20Processing%20and%20Evaluation/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;dlink.host&#x2F;wx4.sinaimg.cn&#x2F;large&#x2F;006Tzddnly8htqg1pgsrij30sg0sgtdo.jpg" title="lec_12 Query Processing and Evaluation"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 数据库</span><h3>lec_12 Query Processing and Evaluation</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">1.</span> <span class="toc-text">物理存储数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.</span> <span class="toc-text">1. 存储设备对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%9D%97%E5%92%8C%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">2. 数据块和缓冲管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E6%95%B0%E6%8D%AE%E5%9D%97blocks"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 数据块（Blocks）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E7%BC%93%E5%86%B2%E5%8C%BAbuffer%E5%92%8C%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86%E5%99%A8buffer-manager"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 缓冲区（Buffer）和缓冲管理器（Buffer Manager）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E5%9D%97%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 块替换策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 缓冲区示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 缓冲管理的重要性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B%E5%92%8C%E5%A1%AB%E5%85%85%E5%9B%A0%E5%AD%90fill-factor"><span class="toc-number">1.3.</span> <span class="toc-text">3. 存储示例和填充因子（Fill Factor）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 存储示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E5%A1%AB%E5%85%85%E5%9B%A0%E5%AD%90fill-factor"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 填充因子（Fill Factor）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-%E5%A1%AB%E5%85%85%E5%9B%A0%E5%AD%90%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 填充因子的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B8%E5%9E%8B%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4 典型文件组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41-%E6%97%A0%E5%BA%8F%E6%96%87%E4%BB%B6heap-files"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 无序文件（Heap Files）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-%E6%8E%92%E5%BA%8F%E6%96%87%E4%BB%B6sorted-files"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 排序文件（Sorted Files）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6index-files"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 索引文件（Index Files）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44-%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 文件组织方式的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45-%E9%80%82%E7%94%A8%E6%80%A7%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 适用性总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E-dbms-%E4%B8%AD%E6%A3%80%E7%B4%A2%E8%AE%B0%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">如何从 DBMS 中检索记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84access-paths"><span class="toc-number">2.1.</span> <span class="toc-text">1. 访问路径（Access Paths）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%A9%E7%90%86%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7physical-data-independence"><span class="toc-number">2.2.</span> <span class="toc-text">2. 物理数据独立性（Physical Data Independence）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%A0%E5%BA%8F%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">3. 无序文件的访问方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F%E7%9A%84io%E6%88%90%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">4. 线性扫描的 I&#x2F;O 成本示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2equality-search"><span class="toc-number">2.4.1.</span> <span class="toc-text">等值查询（Equality Search）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2range-search"><span class="toc-number">2.4.2.</span> <span class="toc-text">范围查询（Range Search）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8E%92%E5%BA%8F%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">5. 排序文件的访问方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B4%A2%E5%BC%95indexing"><span class="toc-number">2.6.</span> <span class="toc-text">6. 索引（Indexing）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">B + 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-b%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. B + 树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-b%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">2. B + 树的结构特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-b%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3. B + 树的构建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-b%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">4. B + 树的查找过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-b%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.5.</span> <span class="toc-text">5. B + 树的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-b%E6%A0%91%E7%9A%84%E5%8A%A3%E5%8A%BF"><span class="toc-number">3.6.</span> <span class="toc-text">6. B + 树的劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-b%E6%A0%91%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.7.</span> <span class="toc-text">7. B + 树在数据库中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.8.</span> <span class="toc-text">8. 举例：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%84%E5%BB%BA%E9%80%BB%E8%BE%91%E6%9C%89%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.8.1.</span> <span class="toc-text">1. 构建逻辑有序数据文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E6%AF%8F%E4%B8%AA%E8%AE%B0%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%9D%A1%E7%9B%AE"><span class="toc-number">3.8.2.</span> <span class="toc-text">2. 为每个记录页面创建索引条目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%86%E7%B4%A2%E5%BC%95%E6%9D%A1%E7%9B%AE%E8%A3%85%E5%85%A5%E9%A1%B5%E9%9D%A2"><span class="toc-number">3.8.3.</span> <span class="toc-text">3. 将索引条目装入页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%84%E5%BB%BAb%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">3.8.4.</span> <span class="toc-text">4. 构建 B + 树索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-b%E6%A0%91%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="toc-number">3.8.5.</span> <span class="toc-text">5. B + 树索引中的查找过程</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/09/16/computer/database/learn-test/" rel="bookmark" title="introduction">introduction</a></li><li><a href="/2024/09/16/computer/database/lec_5%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%A6%E6%9D%9F/" rel="bookmark" title="lec_5 数据库约束">lec_5 数据库约束</a></li><li><a href="/2024/09/16/computer/database/lec_4%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E4%B8%8Esql/" rel="bookmark" title="lec_4 关系代数与sql">lec_4 关系代数与sql</a></li><li><a href="/2024/09/29/computer/database/lec_6%20Advanced%20SQL/" rel="bookmark" title="lec_6 Advanced SQL">lec_6 Advanced SQL</a></li><li><a href="/2024/09/30/computer/database/lec7%20python%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="bookmark" title="lec_7 Python连接数据库">lec_7 Python连接数据库</a></li><li><a href="/2024/10/03/computer/database/lec8%20Schema%20Refinement%20and%20Normalisation/" rel="bookmark" title="lec_8 Schema Refinement and Normalisation">lec_8 Schema Refinement and Normalisation</a></li><li><a href="/2024/10/29/computer/database/final%E5%A4%8D%E4%B9%A001/" rel="bookmark" title="final复习01">final复习01</a></li><li><a href="/2024/11/03/computer/database/final%E5%A4%8D%E4%B9%A002/" rel="bookmark" title="final复习02">final复习02</a></li><li class="active"><a href="/2024/11/03/computer/database/lec11%20Storage%20and%20Indexing/" rel="bookmark" title="lec_11 Storage and Indexing">lec_11 Storage and Indexing</a></li><li><a href="/2024/11/04/computer/database/lec12%20Query%20Processing%20and%20Evaluation/" rel="bookmark" title="lec_12 Query Processing and Evaluation">lec_12 Query Processing and Evaluation</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="IRON" data-src="/images/avatar.jpg"><p class="name" itemprop="name">IRON</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">91</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTU1MDgyNDI1Nw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;550824257"><i class="ic i-cloud-music"></i></span> <a href="/zhouy6577@gmail.com" title="zhouy6577@gmail.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>主页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/11/03/computer/database/final%E5%A4%8D%E4%B9%A002/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/11/04/computer/database/lec12%20Query%20Processing%20and%20Evaluation/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于 游戏引擎">游戏引擎</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/" title="分类于 unity">unity</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/unityProject01/" title="分类于 从零开始的恶魔城开发">从零开始的恶魔城开发</a></div><span><a href="/2025/01/23/game-engine/unity/unityProject01/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%20-%20%E5%89%AF%E6%9C%AC%20(3)/" title="背包系统优化">背包系统优化</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/database/" title="分类于 数据库">数据库</a></div><span><a href="/2024/10/03/computer/database/lec8%20Schema%20Refinement%20and%20Normalisation/" title="lec_8 Schema Refinement and Normalisation">lec_8 Schema Refinement and Normalisation</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/2024/03/01/computer/front/JavaScript/2%E3%80%81JavaScript%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E5%A4%A9/" title="JavaScript02">JavaScript02</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于 游戏引擎">游戏引擎</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/" title="分类于 unity">unity</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/unityBasics/" title="分类于 unity基础">unity基础</a></div><span><a href="/2025/01/03/game-engine/unity/unityBasics/%E5%B0%8F%E6%B1%BD%E8%BD%A6%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93(1)/" title="小汽车项目总结(1)">小汽车项目总结(1)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/2024/10/01/computer/front/JavaScript/js%E4%B8%ADgetBoundingClientRect()%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/" title="js中getBoundingClientRect()的使用解析">js中getBoundingClientRect()的使用解析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/prattle/" title="分类于 杂谈">杂谈</a></div><span><a href="/2024/03/01/computer/front/prattle/SpreadJS%E7%9A%84%E4%BD%BF%E7%94%A8/" title="SpreadJS的使用">SpreadJS的使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于 游戏引擎">游戏引擎</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/" title="分类于 unity">unity</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/unityBasics/" title="分类于 unity基础">unity基础</a></div><span><a href="/2024/08/03/game-engine/unity/unityBasics/unity%E4%B8%AD%E6%93%8D%E4%BD%9C%E6%8E%A7%E5%88%B6/" title="unity中操作控制">unity中操作控制</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/prattle/" title="分类于 杂谈">杂谈</a></div><span><a href="/2024/03/01/computer/front/prattle/Echarts%E5%9D%90%E6%A0%87%E7%9B%B8%E5%85%B3%E5%80%BC/" title="echarts相关参数">echarts相关参数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于 游戏引擎">游戏引擎</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/" title="分类于 unity">unity</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/unityProject01/" title="分类于 从零开始的恶魔城开发">从零开始的恶魔城开发</a></div><span><a href="/2025/01/23/game-engine/unity/unityProject01/%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/" title="存档系统">存档系统</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/database/" title="分类于 数据库">数据库</a></div><span><a href="/2024/09/29/computer/database/lec_6%20Advanced%20SQL/" title="lec_6 Advanced SQL">lec_6 Advanced SQL</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">IRON @ IRON</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/11/03/computer/database/lec11 Storage and Indexing/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->
<!-- build time:Sun Jan 26 2025 11:45:50 GMT+0800 (中国标准时间) --><!DOCTYPE html><script async src="https://www.googletagmanager.com/gtag/js?id=G-DPVE7Y0QX9"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-DPVE7Y0QX9")</script><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="杂项笔记" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="杂项笔记" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="杂项笔记" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/2024/10/28/computer/networks/network_lec_7%20Design%20ofNetworks%20and%20DistributedSystems/"><title>lecture_7 Design ofNetworks and DistributedSystems - 计算机网络 - 计算机科学 | IRON = 杂项笔记</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">lecture_7 Design ofNetworks and DistributedSystems</h1><div class="meta"><span class="item" title="创建时间：2024-10-28 08:59:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-10-28T08:59:00+08:00">2024-10-28</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">IRON</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://dlink.host/wx2.sinaimg.cn/large/006Tzddnly8htqg1keshmj30sg0sgjvu.jpg"></li><li class="item" data-background-image="https://dlink.host/wx1.sinaimg.cn/large/006Tzddnly8htqg0l4jv0j30sg0sgjuv.jpg"></li><li class="item" data-background-image="https://dlink.host/wx4.sinaimg.cn/large/006Tzddnly8htqg1pgsrij30sg0sgtdo.jpg"></li><li class="item" data-background-image="https://dlink.host/wx4.sinaimg.cn/large/006Tzddnly8htpyghxhuvg30b40b41jo.gif"></li><li class="item" data-background-image="https://dlink.host/wx3.sinaimg.cn/large/006Tzddnly8htqg1arfzvj30sg0sg0x7.jpg"></li><li class="item" data-background-image="https://dlink.host/wx4.sinaimg.cn/large/006Tzddnly8htqg1pgsrij30sg0sgtdo.jpg"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer/networks/" itemprop="item" rel="index" title="分类于 计算机网络"><span itemprop="name">计算机网络</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/10/28/computer/networks/network_lec_7%20Design%20ofNetworks%20and%20DistributedSystems/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="IRON"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="杂项笔记"></span><div class="body md" itemprop="articleBody"><h2 id="数据平面data-plane"><a class="anchor" href="#数据平面data-plane">#</a> <span class="label danger">数据平面（Data Plane）</span></h2><h3 id="1-数据平面的功能"><a class="anchor" href="#1-数据平面的功能">#</a> 1. <strong>数据平面的功能</strong>：</h3><p>数据平面在每个路由器上本地执行，负责将进入路由器的分组从输入端口转发到正确的输出端口。核心任务是根据路由表决定每个数据包的转发路径​。</p><h3 id="2-转发表forwarding-table"><a class="anchor" href="#2-转发表forwarding-table">#</a> 2. <strong>转发表（Forwarding Table）</strong>：</h3><pre><code>每个路由器的转发表决定了数据包的转发规则。数据平面根据数据包头中的字段值（如目的IP地址）匹配相应规则，并执行相应的操作，如转发到特定端口或丢弃​。
</code></pre><h3 id="3-openflow和流表"><a class="anchor" href="#3-openflow和流表">#</a> 3. <strong>OpenFlow 和流表</strong>：</h3><pre><code>在SDN架构中，数据平面使用OpenFlow等协议支持的流表（Flow Table），可以灵活定义转发规则。流表包含匹配字段、操作（例如转发、丢弃、修改）和计数器。控制器根据网络状态动态下发这些规则，以适应网络需求​.
</code></pre><p><img data-src="https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2F%E8%BD%AC%E5%8F%91%E8%A1%A8.png" alt><br><img data-src="https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2F%E8%BD%AC%E5%8F%91%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt><br>如上图我们可以看到</p><ol><li><strong>Destination-based forwarding（基于目标地址的转发）</strong></li></ol><ul><li><strong>匹配条件</strong>：<ul><li>目标 IP 地址为 <code>51.6.0.8</code> 。</li><li>其他字段使用通配符 <code>*</code> ，表示任何值。</li></ul></li><li><strong>操作</strong>：<ul><li>动作是将符合条件的数据包转发到端口 <code>port6</code> 。</li></ul></li><li><strong>解释</strong>：这个规则的作用是，当数据包的目标地址为 <code>51.6.0.8</code> 时，将该数据包转发到交换机的端口 6。这样可以确保发往该地址的数据包沿着预设路径传输，通常用于路由数据包到特定的目的地。</li></ul><ol start="2"><li><strong>Firewall（防火墙规则）</strong></li></ol><ul><li><p><strong>规则 1</strong>：</p><ul><li>匹配条件：TCP 的目标端口为 <code>22</code> （通常用于 SSH 连接）。</li><li>其他字段使用通配符 <code>*</code> 。</li><li><strong>操作</strong>：丢弃数据包（drop）。</li><li><strong>解释</strong>：这个规则的目的是阻止所有目标端口为 22 的数据包，起到屏蔽 SSH 流量的作用。这种规则通常用于限制对特定服务的访问，以增强网络的安全性。</li></ul></li><li><p><strong>规则 2</strong>：</p><ul><li>匹配条件：源 IP 地址为 <code>128.119.1.1</code> 。</li><li>其他字段使用通配符 <code>*</code> 。</li><li><strong>操作</strong>：丢弃数据包（drop）。</li><li><strong>解释</strong>：此规则阻止所有来自 <code>128.119.1.1</code> 主机的流量。可能用于封锁特定设备或网络源的访问，防止来自该源的恶意流量。</li></ul></li></ul><h3 id="4-通用转发generalized-forwarding"><a class="anchor" href="#4-通用转发generalized-forwarding">#</a> 4. <strong>通用转发（Generalized Forwarding）</strong>：</h3><pre><code>通用转发允许更细粒度的规则定义，例如基于源/目的IP地址、端口号等字段来处理数据包。这一机制使得数据平面可以灵活地执行各种操作，不仅限于简单的IP转发​。
</code></pre><h2 id="控制平面control-plane"><a class="anchor" href="#控制平面control-plane">#</a> <span class="label danger">控制平面（Control Plane）</span></h2><p>在 SDN（软件定义网络）中，** 控制平面（Control Plane）** 负责网络的逻辑控制和管理决策，是 SDN 架构的核心部分。它与数据平面（Data Plane）分离，使网络管理更加灵活和集中化。以下是控制平面的主要内容：</p><h3 id="1-控制平面的功能"><a class="anchor" href="#1-控制平面的功能">#</a> 1. <strong>控制平面的功能</strong></h3><ul><li><strong>路由决策</strong>：控制平面负责计算最佳路径，将路径信息下发给数据平面。例如，它决定不同数据包通过的路径，以达到最优的流量管理和资源利用。</li><li><strong>策略管理</strong>：控制平面可以根据业务需求或策略规定数据包的处理方式。例如，它可以定义哪些数据包需要优先处理、哪些流量要进行限制。</li><li><strong>集中控制</strong>：在 SDN 中，控制平面通常由一个集中控制器（如 OpenDaylight、ONOS 等）实现。这个集中控制器管理整个网络的规则和策略，为各个交换机和路由器提供统一的控制。</li></ul><h3 id="2-控制器与数据平面的交互"><a class="anchor" href="#2-控制器与数据平面的交互">#</a> 2. <strong>控制器与数据平面的交互</strong></h3><ul><li><strong>OpenFlow 协议</strong>：控制平面通常通过 OpenFlow 协议与数据平面交换机和路由器通信。控制器通过下发流表规则，告知交换机如何处理不同的数据包。</li><li><strong>流表规则的下发与更新</strong>：控制平面根据实时网络状态下发或更新流表规则，控制数据包的转发路径。例如，当检测到拥塞时，控制器可以重新配置流表，将流量分配到其他路径上。</li></ul><h3 id="3-网络拓扑的发现和监控"><a class="anchor" href="#3-网络拓扑的发现和监控">#</a> 3. <strong>网络拓扑的发现和监控</strong></h3><ul><li><strong>拓扑发现</strong>：控制平面可以监控网络中设备的连接关系，自动生成和更新网络拓扑图。这使得控制器可以实时了解网络的结构，并在路径规划时考虑网络设备的物理位置和连接情况。</li><li><strong>性能监控和故障检测</strong>：控制平面可以采集网络中各设备的状态信息（如流量负载、延迟），并根据监控数据检测故障。例如，如果某条路径出现故障，控制平面可以迅速重新规划路径，将流量重新路由到其他可用路径。</li></ul><h3 id="4-控制平面的优势"><a class="anchor" href="#4-控制平面的优势">#</a> 4. <strong>控制平面的优势</strong></h3><ul><li><strong>集中化管理</strong>：控制平面将网络的控制逻辑集中在控制器上，使网络管理和策略应用变得更加统一和简便。</li><li><strong>动态适应性</strong>：控制平面可以根据实时数据和业务需求，动态调整网络配置和流量分配。比如，它可以自动调整流量优先级，以确保关键应用的带宽需求。</li><li><strong>易扩展性</strong>：通过控制平面，网络管理员可以灵活地添加新规则，满足不断变化的网络需求，适应大规模和复杂的网络环境。</li></ul><h3 id="5-典型应用场景"><a class="anchor" href="#5-典型应用场景">#</a> 5. <strong>典型应用场景</strong></h3><ul><li><strong>流量工程</strong>：控制平面可以根据网络负载情况，动态调整数据包的转发路径，平衡流量负载，优化资源使用。</li><li><strong>网络安全</strong>：控制器可以检测异常流量或攻击行为，快速应用安全策略（如阻断恶意流量或隔离受感染设备）。</li><li><strong>服务质量（QoS）管理</strong>：控制平面可以确保高优先级业务（如视频会议）的带宽需求，同时限制低优先级业务，以提供更好的服务质量。</li></ul><p><img data-src="https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2F%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%A4%BA%E4%BE%8B.png" alt></p><h3 id="示例解读"><a class="anchor" href="#示例解读">#</a> 示例解读</h3><ol><li><p><strong>链路故障检测</strong>：</p><ul><li>在图中， <code>S1</code> 交换机检测到与 <code>S2</code> 之间的链路发生故障（红色链接）。通过 OpenFlow 协议， <code>S1</code> 发送一个端口状态消息（port status message）给 SDN 控制器，通知链路状态的变化。</li></ul></li><li><p><strong>控制器接收故障消息</strong>：</p><ul><li>SDN 控制器收到来自 <code>S1</code> 的 OpenFlow 消息，并更新链路状态信息。控制器在内存中维护网络拓扑和链路状态，这样它可以根据最新的网络状态做出决策。</li></ul></li><li><p><strong>触发路由算法</strong>：</p><ul><li>在控制器中，Dijkstra’s link-state Routing（Dijkstra 链路状态路由算法）应用程序已经预先注册，以便在链路状态变化时被调用。当控制器更新链路状态后，自动调用该路由算法。</li></ul></li><li><p><strong>重新计算路由</strong>：</p><ul><li>Dijkstra 路由算法访问控制器中的网络图信息和链路状态信息，并计算新的路由。该算法会考虑网络中其他节点和链路的状态，以找到从源到目的地的最优路径。</li></ul></li><li><p><strong>更新流表</strong>：</p><ul><li>新的路由计算完成后，控制器会生成更新后的流表，并通过 OpenFlow 协议下发到各个相关交换机（如 <code>S1</code> 、 <code>S2</code> 、 <code>S3</code> 等）。这些交换机会根据新的流表规则调整数据包的转发路径。</li></ul></li><li><p><strong>数据恢复</strong>：</p><ul><li>一旦流表更新完成，网络中的流量将按照新路径进行传输，确保数据流在故障恢复后的最短时间内继续传输，从而实现网络的动态修复和负载均衡。</li></ul></li></ol><p>关键要点</p><ul><li><strong>OpenFlow 协议</strong>：控制器和交换机之间的通信依赖 OpenFlow 协议。交换机将链路故障等事件上报给控制器，控制器下发新的流表规则。</li><li><strong>链路状态路由</strong>：Dijkstra 算法是一种链路状态路由算法，可以快速计算最优路径。控制器利用该算法在网络故障时重新计算路径，确保网络的高效运行。</li><li><strong>集中控制</strong>：在 SDN 架构中，控制器充当了网络的 “中枢神经”，统一管理和协调网络的各个设备，实现了传统网络难以实现的快速恢复和灵活路由。</li></ul><h2 id="transport-services传输服务"><a class="anchor" href="#transport-services传输服务">#</a> <span class="label danger">Transport Services（传输服务）</span></h2><h3 id="1-传输层的主要功能"><a class="anchor" href="#1-传输层的主要功能">#</a> 1. <strong>传输层的主要功能</strong></h3><ul><li><strong>进程到进程的通信</strong>：传输层提供应用进程之间的通信服务。不同于网络层提供的主机到主机的通信，传输层能够识别主机上具体的应用进程（如通过端口号），从而实现进程间的直接通信。</li><li><strong>多路复用与多路分解</strong>：通过端口号，传输层可以支持多个应用程序在同一主机上同时使用网络通信。这使得来自不同应用的数据可以被正确地分解并发送给合适的进程。</li></ul><h3 id="2-传输层的核心服务"><a class="anchor" href="#2-传输层的核心服务">#</a> 2. <strong>传输层的核心服务</strong></h3><p>传输层提供了两种主要的服务类型：</p><ul><li><p><strong>面向连接的服务（例如 TCP）</strong>：</p><ul><li><strong>可靠数据传输</strong>：TCP 通过确认（ACK）、重传（retransmission）等机制确保数据包在传输中不丢失、不重复、按顺序到达。</li><li><strong>流量控制</strong>：TCP 实现流量控制，以防止发送方发送的数据过多，超出接收方的处理能力。</li><li><strong>拥塞控制</strong>：TCP 还提供拥塞控制功能，监测网络拥塞状态，动态调整发送速率，以避免网络拥堵。</li><li><strong>连接管理</strong>：在数据传输前，TCP 使用三次握手建立连接，并在传输完成后使用四次挥手释放连接，确保端到端的可靠连接。</li></ul></li><li><p><strong>无连接的服务（例如 UDP）</strong>：</p><ul><li><strong>尽最大努力交付</strong>：UDP 不保证数据包的可靠传输，不使用重传机制，数据可能丢失、重复或乱序到达。</li><li><strong>低延迟</strong>：UDP 因为不保证可靠性和顺序性，传输过程简单，因此传输延迟较低，适合对实时性要求较高的应用，如视频流和在线游戏。</li><li><strong>无连接传输</strong>：UDP 不建立连接，数据包可直接发送给目标，减少了连接建立的开销。</li></ul></li></ul><h3 id="3-传输服务的典型应用场景"><a class="anchor" href="#3-传输服务的典型应用场景">#</a> 3. <strong>传输服务的典型应用场景</strong></h3><ul><li><strong>TCP 的应用场景</strong>：适用于对数据完整性和可靠性有较高要求的应用，如网页浏览（HTTP）、电子邮件（SMTP）、文件传输（FTP）等。</li><li><strong>UDP 的应用场景</strong>：适用于实时性更高的应用，如视频会议、在线游戏、DNS 查询等。</li></ul><h3 id="4-qos服务质量支持"><a class="anchor" href="#4-qos服务质量支持">#</a> 4. <strong>QoS（服务质量）支持</strong></h3><ul><li>传输服务还可以在一定程度上支持 QoS 需求，例如，通过设置不同的优先级或带宽控制来满足不同应用的传输要求。</li><li>对于实时应用，UDP 通常优于 TCP，因为它减少了传输开销和延迟，但无法提供可靠性保障。TCP 则通过其可靠性和流量控制特性，适合需要数据完整性的应用。</li></ul><h2 id="udp"><a class="anchor" href="#udp">#</a> <span class="label danger">UDP</span></h2><h3 id="1-udp的主要特性"><a class="anchor" href="#1-udp的主要特性">#</a> 1. <strong>UDP 的主要特性</strong></h3><ul><li><strong>无连接</strong>：UDP 是无连接的传输协议，发送数据前无需建立连接，接收方也无需确认。发送方可以直接将数据报发送到目标端口。</li><li><strong>不可靠传输</strong>：UDP 不保证数据报的可靠性，即数据可能丢失、重复、或乱序到达。</li><li><strong>无重传机制</strong>：UDP 不实现重传机制，丢失的数据不会再次发送，这减少了延迟和开销。</li><li><strong>简单的头部结构</strong>：UDP 的数据包头部很简单，仅包含源端口、目的端口、数据长度和校验和等少量信息，使得它的开销小、处理快。</li></ul><h3 id="2-udp头部结构"><a class="anchor" href="#2-udp头部结构">#</a> 2. <strong>UDP 头部结构</strong></h3><ul><li><strong>源端口（Source Port）</strong>：可选项，表示数据包的发送端口，方便接收端识别数据的来源。</li><li><strong>目的端口（Destination Port）</strong>：必选项，表示数据包的接收端口，接收方根据此端口号将数据包分发到相应的应用进程。</li><li><strong>长度（Length）</strong>：UDP 报文的总长度，包括头部和数据部分。</li><li><strong>校验和（Checksum）</strong>：用于检验数据的完整性，但不提供纠错功能。</li></ul><h3 id="3-udp的多路复用和多路分解"><a class="anchor" href="#3-udp的多路复用和多路分解">#</a> 3. <strong>UDP 的多路复用和多路分解</strong></h3><ul><li><strong>多路复用（Multiplexing）</strong>：多个应用程序在同一主机上可以使用不同的 UDP 端口号向网络发送数据。每个数据包通过一个特定的 UDP 端口发送，确保发送端的数据流可以正确地传输到接收方。</li><li><strong>多路分解（Demultiplexing）</strong>：接收方的传输层通过数据包的目的端口号，将收到的数据包分配给相应的应用进程。</li><li><strong>基于端口的分解</strong>：UDP 的多路分解仅依赖于目的端口号，而不考虑源 IP 或源端口。这意味着不同的源可以通过相同的目的端口号将数据发送给同一个接收进程。</li></ul><h3 id="4-udp的典型应用场景"><a class="anchor" href="#4-udp的典型应用场景">#</a> 4. <strong>UDP 的典型应用场景</strong></h3><ul><li><strong>实时应用</strong>：如视频会议、IP 电话、在线游戏等应用。它们对延迟敏感且要求数据尽快到达，丢包不会严重影响体验，因此更适合使用 UDP。</li><li><strong>广播和多播</strong>：UDP 支持广播和多播，可以将数据同时发送给多个接收方，适合用于局域网中的发现服务（如 DHCP、UPnP 等）。</li><li><strong>简化的传输需求</strong>：如 DNS 查询、SNMP 等应用，只需发送小数据量且无需重传。丢包对这些应用影响较小，因此它们更适合使用 UDP。</li></ul><h3 id="5-udp的优缺点"><a class="anchor" href="#5-udp的优缺点">#</a> 5. <strong>UDP 的优缺点</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>低延迟</strong>：无连接、无重传的特性使得 UDP 传输延迟低，适合实时应用。</li><li><strong>简单高效</strong>：头部结构简单，数据处理开销小。</li><li><strong>支持广播 / 多播</strong>：便于在局域网中进行资源发现。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>不可靠</strong>：无重传和确认机制，数据可能丢失或乱序。</li><li><strong>无流量控制和拥塞控制</strong>：可能导致网络拥堵或过载。</li></ul></li></ul><h3 id="6-udp和tcp的对比"><a class="anchor" href="#6-udp和tcp的对比">#</a> 6. <strong>UDP 和 TCP 的对比</strong></h3><ul><li><strong>可靠性</strong>：TCP 提供可靠传输和重传机制，而 UDP 不保证数据的传输可靠性。</li><li><strong>延迟</strong>：UDP 延迟更低，因为它无需建立连接和等待确认。</li><li><strong>数据顺序</strong>：TCP 保证数据按序到达，UDP 则不保证顺序。</li><li><strong>适用场景</strong>：TCP 适用于需要可靠性、数据完整性的应用，如文件传输、网页浏览；UDP 适用于对实时性要求高、允许丢包的应用，如视频流和 DNS 查询。</li></ul><h2 id="tcp"><a class="anchor" href="#tcp">#</a> <span class="label danger">TCP</span></h2><p>在传输层协议中，**TCP（Transmission Control Protocol，传输控制协议）** 是一种面向连接、可靠的传输协议。与 UDP 相比，TCP 提供了数据的可靠传输、流量控制和拥塞控制，是大多数对数据完整性要求较高的应用的首选协议。以下是 TCP 部分的核心内容：</p><h3 id="1-tcp的主要特性"><a class="anchor" href="#1-tcp的主要特性">#</a> 1. <strong>TCP 的主要特性</strong></h3><ul><li><strong>面向连接</strong>：TCP 是面向连接的协议，数据传输前需要建立连接。TCP 通过三次握手建立连接，并通过四次挥手断开连接。</li><li><strong>可靠传输</strong>：TCP 通过确认（ACK）、重传机制确保数据不丢失、不重复、按顺序到达接收方。</li><li><strong>有序传输</strong>：TCP 对数据包进行编号（序列号），接收方根据序列号将数据包按正确的顺序排列，从而保证数据的有序性。</li><li><strong>全双工通信</strong>：TCP 支持全双工通信，允许通信双方在同一时间内发送和接收数据。</li><li><strong>流量控制</strong>：TCP 使用滑动窗口机制进行流量控制，确保发送方的发送速率不会超出接收方的接收能力。</li><li><strong>拥塞控制</strong>：TCP 具有拥塞控制机制，通过动态调整发送速率来防止网络拥塞。</li></ul><h3 id="2-tcp连接的建立和断开"><a class="anchor" href="#2-tcp连接的建立和断开">#</a> 2. <strong>TCP 连接的建立和断开</strong></h3><ul><li><strong>三次握手（Three-Way Handshake）</strong>：<ul><li>连接建立时，TCP 使用三次握手协议。</li><li>第一步：客户端向服务器发送 SYN（同步）请求。</li><li>第二步：服务器收到 SYN 后，返回一个 SYN-ACK（同步确认）。</li><li>第三步：客户端收到 SYN-ACK 后，再发送一个 ACK，连接正式建立。</li></ul></li><li><strong>四次挥手（Four-Way Teardown）</strong>：<ul><li>连接断开时，TCP 使用四次挥手协议。</li><li>第一步：客户端向服务器发送 FIN（终止）请求。</li><li>第二步：服务器收到 FIN 后，返回一个 ACK，表示收到。</li><li>第三步：服务器在处理完数据后，发送 FIN 请求。</li><li>第四步：客户端返回 ACK，连接正式断开。</li></ul></li></ul><h3 id="3-tcp的可靠性机制"><a class="anchor" href="#3-tcp的可靠性机制">#</a> 3. <strong>TCP 的可靠性机制</strong></h3><ul><li><strong>序列号（Sequence Number）</strong>：TCP 为每个字节分配一个序列号，以确保数据按顺序到达。</li><li><strong>确认应答（ACK）</strong>：接收方在接收到数据后，向发送方发送确认信息（ACK），告知发送方数据已成功接收。</li><li><strong>重传机制</strong>：如果发送方在超时时间内未收到 ACK，则会重传数据。TCP 根据网络状态调整超时时间，确保数据可靠传输。</li><li><strong>窗口机制</strong>：TCP 通过窗口机制一次可以发送多个字节的数据，窗口大小取决于接收方的接收能力和网络状况。</li></ul><h3 id="4-tcp的流量控制"><a class="anchor" href="#4-tcp的流量控制">#</a> 4. <strong>TCP 的流量控制</strong></h3><ul><li><strong>滑动窗口（Sliding Window）</strong>：TCP 使用滑动窗口机制进行流量控制，窗口大小代表了发送方在未接收到 ACK 前可以发送的最大数据量。</li><li><strong>窗口调整</strong>：接收方通过通告窗口（Advertised Window）来控制发送方的发送速率。接收方在 ACK 中通告自己的接收窗口大小，发送方根据该窗口调整发送数据的量。</li><li><strong>目的</strong>：流量控制确保发送方不会淹没接收方的缓冲区，避免接收方因接收速度不足而丢失数据。</li></ul><h3 id="5-tcp的拥塞控制"><a class="anchor" href="#5-tcp的拥塞控制">#</a> 5. <strong>TCP 的拥塞控制</strong></h3><ul><li><strong>拥塞窗口（Congestion Window，cwnd）</strong>：TCP 维护一个拥塞窗口，该窗口根据网络拥塞情况动态变化。</li><li><strong>慢启动（Slow Start）</strong>：在连接开始时，TCP 使用慢启动算法，逐步增加拥塞窗口，探测可用带宽。</li><li><strong>拥塞避免（Congestion Avoidance）</strong>：当拥塞窗口达到阈值后，进入拥塞避免阶段，窗口以线性速度增长。</li><li><strong>快速重传和快速恢复</strong>：<ul><li><strong>快速重传</strong>：当发送方收到三个重复的 ACK 时，认为该数据段丢失，立即重传而不等待超时。</li><li><strong>快速恢复</strong>：在快速重传后，TCP 直接进入拥塞避免阶段，避免回到慢启动。</li></ul></li></ul><h3 id="6-tcp的典型应用场景"><a class="anchor" href="#6-tcp的典型应用场景">#</a> 6. <strong>TCP 的典型应用场景</strong></h3><ul><li><strong>文件传输</strong>（如 FTP）：文件传输要求数据的完整性和顺序性，TCP 的可靠性和流量控制确保数据无丢失和按序到达。</li><li><strong>网页浏览</strong>（如 HTTP/HTTPS）：网页浏览要求数据可靠传输，以确保页面内容完整。TCP 的可靠性和流量控制能够确保用户得到完整的网页内容。</li><li><strong>电子邮件</strong>（如 SMTP）：电子邮件传输需要数据的完整性和正确性，因此 TCP 的可靠传输特性非常适合。</li></ul><h3 id="7-tcp的优缺点"><a class="anchor" href="#7-tcp的优缺点">#</a> 7. <strong>TCP 的优缺点</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>可靠传输</strong>：保证数据按顺序到达且不会丢失。</li><li><strong>流量和拥塞控制</strong>：适应不同的网络状况，防止网络拥堵。</li><li><strong>有序性</strong>：数据按顺序到达，适用于大多数需要数据完整性的应用。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>开销较高</strong>：TCP 头部较复杂，且维护连接状态会增加开销。</li><li><strong>延迟较高</strong>：TCP 的三次握手和确认机制增加了延迟，不适合对实时性要求较高的应用。</li></ul></li></ul><h3 id="8-tcp和udp的对比"><a class="anchor" href="#8-tcp和udp的对比">#</a> 8. <strong>TCP 和 UDP 的对比</strong></h3><ul><li><strong>可靠性</strong>：TCP 提供可靠传输，UDP 不保证可靠性。</li><li><strong>延迟</strong>：UDP 延迟更低，而 TCP 由于需要建立连接和确认机制，延迟较高。</li><li><strong>适用场景</strong>：TCP 适用于需要可靠传输的应用，如文件传输和网页浏览；UDP 适用于对实时性要求高的应用，如视频流和 DNS 查询。</li></ul><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>TCP 提供了一套复杂而强大的机制，确保数据的可靠传输。通过连接管理、确认机制、流量控制和拥塞控制，TCP 在需要数据完整性的场景下发挥了关键作用。TCP 的可靠性使其成为大多数网络应用（如 HTTP、FTP 和 SMTP）的首选协议。</p><h2 id="rdt"><a class="anchor" href="#rdt">#</a> RDT</h2><h4 id="rdt20的关键要点"><a class="anchor" href="#rdt20的关键要点">#</a> rdt2.0 的关键要点</h4><ol><li><p><strong>比特错误检测</strong>：</p><ul><li>数据在传输过程中可能会发生比特翻转（bit-flip），导致数据出错。</li><li>rdt2.0 使用校验和（checksum）来检测数据包中的比特错误。</li></ul></li><li><p><strong>确认和否认机制</strong>：</p><ul><li><strong>ACK（Acknowledgements）</strong>：当接收方确认数据包没有错误时，会发送 ACK（确认）消息给发送方，告知数据包正确接收。</li><li><strong>NAK（Negative Acknowledgements）</strong>：当接收方检测到数据包出错时，会发送 NAK（否认）消息给发送方，告知该数据包有错误。</li></ul></li><li><p><strong>重传机制</strong>：</p><ul><li>当发送方收到 NAK 时，会重传数据包，以确保数据正确到达接收方。</li></ul></li><li><p><strong>新增机制</strong>：</p><ul><li><strong>错误检测</strong>：通过校验和实现比特错误检测。</li><li><strong>接收方反馈</strong>：接收方通过控制消息（ACK 和 NAK）向发送方反馈接收状态，使发送方能够知道数据包是否需要重传。</li></ul></li></ol><h4 id="rdt20的工作流程"><a class="anchor" href="#rdt20的工作流程">#</a> rdt2.0 的工作流程</h4><ul><li>发送方发送数据包，数据包中包含校验和。</li><li>接收方收到数据包后，检查校验和。<ul><li>如果校验和匹配，说明数据包无错误，接收方发送 ACK 给发送方。</li><li>如果校验和不匹配，说明数据包有错误，接收方发送 NAK，要求发送方重传。</li></ul></li><li>发送方根据接收到的是 ACK 还是 NAK 来决定是否重传数据。</li></ul><p><img data-src="https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2Frdt.png" alt></p><h4 id="示例发送方状态机解析"><a class="anchor" href="#示例发送方状态机解析">#</a> 示例：发送方状态机解析</h4><ol><li><p><strong>等待上层调用（Wait for call from above）</strong>：</p><ul><li>初始状态，发送方等待上层应用调用 <code>rdt_send(data)</code> 。</li><li>一旦有数据传入，发送方创建数据包（包括数据和校验和） <code>sndpkt = make_pkt(data, checksum)</code> ，并通过 <code>udt_send(sndpkt)</code> 将数据包发送到信道。</li><li>发送完数据后，发送方进入等待 ACK 或 NAK 的状态。</li></ul></li><li><p><strong>等待 ACK 或 NAK（Wait for ACK or NAK）</strong>：</p><ul><li>发送方在此状态下等待接收方的反馈。</li><li>如果接收到的是 NAK（ <code>isNAK(rcvpkt)</code> ），表示数据包出错，发送方会重传数据包 <code>udt_send(sndpkt)</code> 。</li><li>如果接收到的是 ACK（ <code>isACK(rcvpkt)</code> ），表示数据包已正确接收，发送方回到等待上层调用的初始状态。</li></ul></li></ol><h4 id="接收方状态机解析"><a class="anchor" href="#接收方状态机解析">#</a> 接收方状态机解析</h4><ol><li><p><strong>等待数据包（Wait for call from below）</strong>：</p><ul><li>初始状态，接收方等待数据包的到来。</li><li>当接收到一个数据包 <code>rdt_rcv(rcvpkt)</code> 后，接收方会检查数据包是否损坏。</li></ul></li><li><p><strong>数据包损坏或无误</strong>：</p><ul><li><strong>如果数据包损坏（ <code>corrupt(rcvpkt)</code> ）</strong>：接收方发送 NAK（ <code>udt_send(NAK)</code> ）通知发送方重传。</li><li><strong>如果数据包无误（ <code>notcorrupt(rcvpkt)</code> ）</strong>：接收方提取数据 <code>extract(rcvpkt, data)</code> ，并将其交付给上层 <code>deliver_data(data)</code> ，然后发送 ACK（ <code>udt_send(ACK)</code> ）通知发送方数据已正确接收。</li></ul></li></ol><p><img data-src="https://blog-1321157486.cos.ap-nanjing.myqcloud.com/networks%2Frdt2%E7%BC%BA%E9%99%B7.png" alt></p><h3 id="rdt20的缺陷"><a class="anchor" href="#rdt20的缺陷">#</a> rdt2.0 的缺陷</h3><ul><li><p><strong>问题描述</strong>：</p><ul><li>如果 ACK 或 NAK 消息在传输过程中被损坏，发送方就无法知道接收方是否正确接收了数据包。</li><li>发送方在这种情况下无法确定是否需要重传数据包，因为重传可能会导致接收方收到重复的数据包。</li></ul></li><li><p><strong>不能直接重传的原因</strong>：</p><ul><li>如果发送方简单地重传数据包，可能会导致接收方接收到重复的数据，从而影响数据的正确性。</li><li>由于发送方无法确定接收方的实际状态，因此简单的重传会导致数据包的冗余和不确定性。</li></ul></li></ul><h3 id="处理重复数据包的方法"><a class="anchor" href="#处理重复数据包的方法">#</a> 处理重复数据包的方法</h3><p>为了解决 ACK/NAK 损坏的问题，以及可能导致的重复数据包，rdt2.0 需要进行以下改进：</p><ol><li><p><strong>添加序列号（Sequence Number）</strong>：</p><ul><li>每个数据包附加一个序列号，以区分数据包的唯一性。</li><li>序列号帮助接收方识别出重复的数据包，从而避免重复交付。</li></ul></li><li><p><strong>丢弃重复的数据包</strong>：</p><ul><li>如果接收方检测到数据包的序列号与上一个接收的数据包相同，则丢弃该数据包，不再传递给上层应用。</li><li>这样可以确保即使发送方因 ACK/NAK 损坏而重传数据，接收方也不会重复处理相同的数据。</li></ul></li><li><p><strong>超时重传</strong>：</p><ul><li>为了防止无限等待，发送方可以使用超时机制。在未收到 ACK/NAK 的情况下，发送方等待一段时间后自动重传数据包。</li><li>超时机制确保数据包能够最终被成功接收，避免了无休止的等待。</li></ul></li></ol><h3 id="停止等待机制stop-and-wait"><a class="anchor" href="#停止等待机制stop-and-wait">#</a> <strong>“停止等待” 机制（Stop and Wait）</strong></h3><ul><li>在这种机制下，发送方每次仅发送一个数据包，然后等待接收方的 ACK 或 NAK 响应。</li><li>只有在接收到 ACK 后，发送方才会继续发送下一个数据包。如果未收到 ACK（例如 ACK 损坏或丢失），发送方则会重传当前数据包。</li><li>停止等待机制简化了协议的实现，但可能会导致传输效率下降，特别是在网络延迟较大时。</li></ul><h3 id="后续版本"><a class="anchor" href="#后续版本">#</a> 后续版本</h3><h3 id="1-rdt21解决acknak损坏问题"><a class="anchor" href="#1-rdt21解决acknak损坏问题">#</a> 1. <strong>rdt2.1：解决 ACK/NAK 损坏问题</strong></h3><ul><li><p><strong>问题</strong>：在 rdt2.0 中，如果 ACK 或 NAK 发生损坏，发送方无法判断接收方的状态，从而导致数据包的潜在重复或丢失。</p></li><li><p><strong>改进</strong>：</p><ul><li><strong>序列号</strong>：引入序列号来标记数据包的唯一性。每个数据包使用 0 或 1 的序列号，以便接收方可以检测到重复的数据包。</li><li><strong>冗余 ACK</strong>：如果 ACK 或 NAK 损坏，发送方会根据超时机制重发数据包。接收方在接收相同序列号的数据包时会丢弃重复的数据包，但仍会发送冗余 ACK。</li><li><strong>状态机调整</strong>：发送方和接收方都需要跟踪序列号，发送方根据接收的 ACK 或 NAK 来判断是否需要重传。</li></ul></li><li><p><strong>工作流程</strong>：</p><ol><li>发送方发送带序列号的包，并等待 ACK 或 NAK。</li><li>接收方收到包后，根据校验和检测是否有错误。若无错误，发送 ACK，若有错误，发送 NAK。</li><li>若 ACK/NAK 损坏，发送方超时后会重发数据包。接收方通过序列号来丢弃重复包。</li></ol></li><li><p><strong>优势</strong>：rdt2.1 通过序列号和 ACK 重传解决了 ACK/NAK 损坏的问题。</p></li></ul><h3 id="2-rdt22仅使用ack无nak"><a class="anchor" href="#2-rdt22仅使用ack无nak">#</a> 2. <strong>rdt2.2：仅使用 ACK，无 NAK</strong></h3><ul><li><strong>问题</strong>：rdt2.1 依赖 ACK 和 NAK 双重反馈，但在实际网络中，使用 NAK 可能会引入额外的复杂性。</li><li><strong>改进</strong>：<ul><li><strong>纯 ACK 机制</strong>：取消了 NAK，接收方只使用 ACK 来响应。</li><li><strong>冗余 ACK 机制</strong>：如果接收方检测到数据包有错误（如校验和失败），则不发送 NAK，而是重复发送上一条 ACK。发送方在接收冗余 ACK 后，将重传数据包。</li></ul></li><li><strong>工作流程</strong>：<ol><li>发送方发送带序列号的包，并等待 ACK。</li><li>接收方若检测到包无错误，则发送 ACK。如果检测到包有错误，发送上一个包的 ACK（即冗余 ACK）。</li><li>发送方在接收到冗余 ACK 时，将当前包重发。</li></ol></li><li><strong>优势</strong>：rdt2.2 避免了 NAK 的使用，简化了接收方逻辑。该版本仅依赖 ACK，进一步提高了效率。</li></ul><h3 id="3-rdt30处理信道丢包问题"><a class="anchor" href="#3-rdt30处理信道丢包问题">#</a> 3. <strong>rdt3.0：处理信道丢包问题</strong></h3><ul><li><strong>问题</strong>：rdt2.x 版本解决了比特错误问题，但假设信道不会丢包。然而，在实际网络中，数据包可能会丢失，因此 rdt2.x 无法保证在丢包信道上的可靠性。</li><li><strong>改进</strong>：<ul><li><strong>超时重传机制</strong>：rdt3.0 在发送方引入了超时重传机制。发送方在发送数据包后，启动一个定时器。如果在超时时间内未收到 ACK，则自动重传数据包。</li><li><strong>序列号</strong>：继续使用序列号来检测重复包，确保接收方不会交付重复数据。</li></ul></li><li><strong>工作流程</strong>：<ol><li>发送方发送带序列号的包，并等待 ACK，同时启动定时器。</li><li>接收方收到包后，若无错误，则发送 ACK 并交付数据；若有错误，发送冗余 ACK。</li><li>若发送方在超时时间内未收到 ACK，自动重传数据包。</li><li>接收方通过序列号丢弃重复包，保证数据无重复交付。</li></ol></li><li><strong>优势</strong>：rdt3.0 通过超时重传机制解决了丢包问题，能够在信道丢包和比特错误情况下实现可靠传输。</li></ul><h3 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h3><ul><li><strong>rdt2.1</strong>：在 rdt2.0 的基础上引入序列号，用 ACK 和 NAK 解决确认消息损坏的问题。</li><li><strong>rdt2.2</strong>：去除 NAK，仅使用 ACK 机制，通过冗余 ACK 实现重传，简化了协议。</li><li><strong>rdt3.0</strong>：引入超时重传机制，解决了信道丢包的问题，实现了在丢包和比特错误信道上的可靠数据传输。</li></ul><p>rdt3.0 是这几个版本中最可靠的协议，适用于丢包和比特错误的复杂信道环境。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-29 17:26:00" itemprop="dateModified" datetime="2024-10-29T17:26:00+08:00">2024-10-29</time> </span><span id="2024/10/28/computer/networks/network_lec_7 Design ofNetworks and DistributedSystems/" class="item leancloud_visitors" data-flag-title="lecture_7 Design ofNetworks and DistributedSystems" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="IRON 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="IRON 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="IRON 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>IRON <i class="ic i-at"><em>@</em></i>杂项笔记</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2024/10/28/computer/networks/network_lec_7%20Design%20ofNetworks%20and%20DistributedSystems/" title="lecture_7 Design ofNetworks and DistributedSystems">http://example.com/2024/10/28/computer/networks/network_lec_7 Design ofNetworks and DistributedSystems/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/10/25/game-engine/unity/unityCompetition/%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A0%81%E4%BA%91/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;dlink.host&#x2F;wx2.sinaimg.cn&#x2F;large&#x2F;006Tzddnly8htqg1keshmj30sg0sgjvu.jpg" title="创建并添加代码到gitee"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> unity创想赛</span><h3>创建并添加代码到gitee</h3></a></div><div class="item right"><a href="/2024/10/29/computer/database/final%E5%A4%8D%E4%B9%A001/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;dlink.host&#x2F;wx2.sinaimg.cn&#x2F;large&#x2F;006Tzddnly8htqg0x2lhcg3074074e7q.gif" title="final复习01"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 数据库</span><h3>final复习01</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2data-plane"><span class="toc-number">1.</span> <span class="toc-text">数据平面（Data Plane）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">1. 数据平面的功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AC%E5%8F%91%E8%A1%A8forwarding-table"><span class="toc-number">1.2.</span> <span class="toc-text">2. 转发表（Forwarding Table）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-openflow%E5%92%8C%E6%B5%81%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">3. OpenFlow 和流表：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91generalized-forwarding"><span class="toc-number">1.4.</span> <span class="toc-text">4. 通用转发（Generalized Forwarding）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2control-plane"><span class="toc-number">2.</span> <span class="toc-text">控制平面（Control Plane）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.</span> <span class="toc-text">1. 控制平面的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">2.2.</span> <span class="toc-text">2. 控制器与数据平面的交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%9A%84%E5%8F%91%E7%8E%B0%E5%92%8C%E7%9B%91%E6%8E%A7"><span class="toc-number">2.3.</span> <span class="toc-text">3. 网络拓扑的发现和监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.4.</span> <span class="toc-text">4. 控制平面的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.5.</span> <span class="toc-text">5. 典型应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%A7%A3%E8%AF%BB"><span class="toc-number">2.6.</span> <span class="toc-text">示例解读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transport-services%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">Transport Services（传输服务）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.</span> <span class="toc-text">1. 传输层的主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.2.</span> <span class="toc-text">2. 传输层的核心服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.</span> <span class="toc-text">3. 传输服务的典型应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-qos%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E6%94%AF%E6%8C%81"><span class="toc-number">3.4.</span> <span class="toc-text">4. QoS（服务质量）支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#udp"><span class="toc-number">4.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-udp%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">1. UDP 的主要特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-udp%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">2. UDP 头部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-udp%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="toc-number">4.3.</span> <span class="toc-text">3. UDP 的多路复用和多路分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-udp%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.4.</span> <span class="toc-text">4. UDP 的典型应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-udp%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.5.</span> <span class="toc-text">5. UDP 的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-udp%E5%92%8Ctcp%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">4.6.</span> <span class="toc-text">6. UDP 和 TCP 的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp"><span class="toc-number">5.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-tcp%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">1. TCP 的主要特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%96%AD%E5%BC%80"><span class="toc-number">5.2.</span> <span class="toc-text">2. TCP 连接的建立和断开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-tcp%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">3. TCP 的可靠性机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-tcp%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">4. TCP 的流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-tcp%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">5.5.</span> <span class="toc-text">5. TCP 的拥塞控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-tcp%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.6.</span> <span class="toc-text">6. TCP 的典型应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-tcp%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.7.</span> <span class="toc-text">7. TCP 的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-tcp%E5%92%8Cudp%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.8.</span> <span class="toc-text">8. TCP 和 UDP 的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rdt"><span class="toc-number">6.</span> <span class="toc-text">RDT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt20%E7%9A%84%E5%85%B3%E9%94%AE%E8%A6%81%E7%82%B9"><span class="toc-number">6.0.1.</span> <span class="toc-text">rdt2.0 的关键要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdt20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">6.0.2.</span> <span class="toc-text">rdt2.0 的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%8F%91%E9%80%81%E6%96%B9%E7%8A%B6%E6%80%81%E6%9C%BA%E8%A7%A3%E6%9E%90"><span class="toc-number">6.0.3.</span> <span class="toc-text">示例：发送方状态机解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E7%8A%B6%E6%80%81%E6%9C%BA%E8%A7%A3%E6%9E%90"><span class="toc-number">6.0.4.</span> <span class="toc-text">接收方状态机解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt20%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">6.1.</span> <span class="toc-text">rdt2.0 的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">处理重复数据包的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6stop-and-wait"><span class="toc-number">6.3.</span> <span class="toc-text">“停止等待” 机制（Stop and Wait）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC"><span class="toc-number">6.4.</span> <span class="toc-text">后续版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-rdt21%E8%A7%A3%E5%86%B3acknak%E6%8D%9F%E5%9D%8F%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.</span> <span class="toc-text">1. rdt2.1：解决 ACK&#x2F;NAK 损坏问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-rdt22%E4%BB%85%E4%BD%BF%E7%94%A8ack%E6%97%A0nak"><span class="toc-number">6.6.</span> <span class="toc-text">2. rdt2.2：仅使用 ACK，无 NAK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-rdt30%E5%A4%84%E7%90%86%E4%BF%A1%E9%81%93%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">6.7.</span> <span class="toc-text">3. rdt3.0：处理信道丢包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">6.8.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/09/16/computer/networks/hello-world/" rel="bookmark" title="Hello World">Hello World</a></li><li><a href="/2024/09/19/computer/networks/network_lec_6/" rel="bookmark" title="lecture_6Network Layer 3">lecture_6Network Layer 3</a></li><li><a href="/2024/10/23/computer/networks/assignment2%20%E9%A2%98%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/" rel="bookmark" title="assignment2">assignment2</a></li><li class="active"><a href="/2024/10/28/computer/networks/network_lec_7%20Design%20ofNetworks%20and%20DistributedSystems/" rel="bookmark" title="lecture_7 Design ofNetworks and DistributedSystems">lecture_7 Design ofNetworks and DistributedSystems</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="IRON" data-src="/images/avatar.jpg"><p class="name" itemprop="name">IRON</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">91</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTU1MDgyNDI1Nw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;550824257"><i class="ic i-cloud-music"></i></span> <a href="/zhouy6577@gmail.com" title="zhouy6577@gmail.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>主页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/10/25/game-engine/unity/unityCompetition/%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E5%88%B0%E7%A0%81%E4%BA%91/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/10/29/computer/database/final%E5%A4%8D%E4%B9%A001/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/prattle/" title="分类于 杂谈">杂谈</a></div><span><a href="/2024/03/01/computer/front/prattle/%E4%BA%8C%E3%80%81spring%E4%BA%8B%E5%8A%A1/" title="spring事务">spring事务</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于 游戏引擎">游戏引擎</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/" title="分类于 unity">unity</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/unityBasics/" title="分类于 unity基础">unity基础</a></div><span><a href="/2024/09/04/game-engine/unity/unityBasics/%E4%B8%80%E4%BA%9B%E5%8A%9F%E8%83%BD%E5%92%8C%E4%B8%8D%E6%87%82%E7%9A%84%E7%82%B9%E7%9A%84%E8%AE%B0%E5%BD%95/" title="一些功能和不懂的点的记录">一些功能和不懂的点的记录</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/09/17/temeplete/temeplete1/" title="wwwww">wwwww</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/2024/03/01/computer/front/JavaScript/3%E3%80%81JavaScript%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%A4%A9/" title="JavaScript03">JavaScript03</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/2024/03/01/computer/front/JavaScript/webapi%E7%AC%AC%E5%85%AD%E5%A4%A9/" title="webAPI06">webAPI06</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/prattle/" title="分类于 杂谈">杂谈</a></div><span><a href="/2024/03/01/computer/front/prattle/Do%20not%20access%20Object.prototype%20method%20'hasOwnProperty'%20from%20target%20object/" title="Do not access Object.prototype method &#39;hasOwnProperty&#39; from target object">Do not access Object.prototype method 'hasOwnProperty' from target object</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于 游戏引擎">游戏引擎</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/" title="分类于 unity">unity</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/unityBasics/" title="分类于 unity基础">unity基础</a></div><span><a href="/2024/08/05/game-engine/unity/unityBasics/unity%E4%B8%AD%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" title="unity中工具使用">unity中工具使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于 游戏引擎">游戏引擎</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/" title="分类于 unity">unity</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/unityBasics/" title="分类于 unity基础">unity基础</a></div><span><a href="/2024/08/03/game-engine/unity/unityBasics/unity%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8-2/" title="unity中基本类的使用-2">unity中基本类的使用-2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于 游戏引擎">游戏引擎</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/" title="分类于 unity">unity</a> <i class="ic i-angle-right"></i> <a href="/categories/game-engine/unity/unityProject01/" title="分类于 从零开始的恶魔城开发">从零开始的恶魔城开发</a></div><span><a href="/2025/01/23/game-engine/unity/unityProject01/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%20-%20%E5%89%AF%E6%9C%AC%20(3)/" title="背包系统优化">背包系统优化</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/computer/front/prattle/" title="分类于 杂谈">杂谈</a></div><span><a href="/2024/03/01/computer/front/prattle/hello-world/" title="介绍">介绍</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">IRON @ IRON</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/10/28/computer/networks/network_lec_7 Design ofNetworks and DistributedSystems/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->